PROGRAM  : Maestia.exe
FUNCTION : FUN_0055a1e0
ENTRY    : 0055a1e0
BODY     : [[0055a1e0, 0055a773]]

============================================================
DECOMPILED C CODE
============================================================

undefined4 FUN_0055a1e0(int param_1,float param_2,float param_3)

{
  GRefCountNTSImpl *pGVar1;
  bool bVar2;
  bool bVar3;
  char cVar4;
  ushort uVar5;
  int iVar6;
  uint uVar7;
  undefined4 uVar8;
  int *in_ECX;
  GRefCountNTSImpl *this;
  uint uVar9;
  int iVar10;
  int unaff_retaddr;
  float fVar11;
  float fStack_50;
  float fStack_4c;
  float fStack_48;
  float fStack_44;
  float fStack_40;
  int iStack_3c;
  int iStack_38;
  int local_34;
  int iStack_30;
  int iStack_2c;
  int iStack_28;
  undefined4 uStack_24;
  float fStack_20;
  float fStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  float fStack_10;
  float fStack_c;
  char cStack_8;
  
  this = (GRefCountNTSImpl *)0x0;
  local_34 = 0;
  iStack_2c = (**(code **)(*in_ECX + 0x28))(&local_34);
  if ((iStack_38 == 0) || (bVar3 = true, (*(byte *)(in_ECX + 9) & 0x40) == 0)) {
    bVar3 = false;
  }
  cVar4 = *(char *)(unaff_retaddr + 0x20);
  bVar2 = false;
  if (cVar4 != '\x01') {
    do {
      if (cVar4 == '\x02') {
        if (bVar2) goto LAB_0055a654;
        do {
          FUN_00553740();
        } while (*(char *)(unaff_retaddr + 0x20) == '\x03');
        bVar2 = false;
      }
      else {
        iStack_3c = *(int *)(unaff_retaddr + 0x1c);
        iVar6 = *(int *)(unaff_retaddr + 0x14);
        iVar10 = *(int *)(unaff_retaddr + 0x18);
        local_34 = iVar6;
        iStack_30 = iVar10;
        if ((iStack_3c == 0) && ((iVar6 == 0) == (iVar10 == 0))) {
          FUN_005564c0();
        }
        else {
          uStack_24 = 0;
          iStack_28 = unaff_retaddr;
          if ((-1 < *(char *)(unaff_retaddr + 0x20)) && (*(char *)(unaff_retaddr + 0x20) != '\x01'))
          {
            do {
              FUN_00553740();
            } while (*(char *)(unaff_retaddr + 0x20) == '\x03');
          }
          fVar11 = (float)*(int *)(unaff_retaddr + 0x2c);
          fStack_50 = (float)*(int *)(unaff_retaddr + 0x30);
          if ((*(byte *)(unaff_retaddr + 0x70) & 0x80) != 0) {
            fVar11 = *(float *)(unaff_retaddr + 0x6c) * fVar11;
            fStack_50 = *(float *)(unaff_retaddr + 0x6c) * fStack_50;
          }
          if (param_1 != 0) {
            FUN_005ac170(&stack0x00000000,&fStack_50);
          }
          if ((bVar3) && (iStack_3c != 0)) {
            if (this == (GRefCountNTSImpl *)0x0) {
              iVar6 = FUN_00515840(0xc4,0);
              if (iVar6 == 0) {
                this = (GRefCountNTSImpl *)0x0;
              }
              else {
                this = (GRefCountNTSImpl *)FUN_005595a0();
              }
              FUN_005dcbb0(0x41a00000);
              FUN_005dcbb0(*(undefined4 *)(this + 0x34));
              iVar6 = local_34;
              iVar10 = iStack_30;
            }
            FUN_005dd510(0xffffffff,0xffffffff,iStack_3c + -1,fVar11,fStack_50);
          }
          while ((*(char *)(iStack_28 + 0x20) != '\x01' && (*(char *)(iStack_28 + 0x20) < '\0'))) {
            FUN_005542d0(&uStack_18,0);
            if (param_1 != 0) {
              FUN_005ac170(&fStack_10,&fStack_c);
            }
            fStack_4c = fStack_50;
            fStack_44 = fStack_10;
            fStack_48 = fStack_c;
            fStack_40 = fVar11;
            if (fStack_c < fStack_50) {
              fStack_40 = fStack_10;
              fStack_4c = fStack_c;
              fStack_48 = fStack_50;
              fStack_44 = fVar11;
            }
            if (cStack_8 == '\0') {
              if (((((iVar6 == 0) != (iVar10 == 0)) &&
                   (fStack_4c < param_3 != (fStack_4c == param_3))) && (param_3 < fStack_48)) &&
                 (fStack_40 = (fStack_48 - fStack_4c) * (param_2 - fStack_44) -
                              (param_3 - fStack_48) * (fStack_44 - fStack_40), 0.0 < fStack_40)) {
                bVar2 = (bool)(bVar2 ^ 1);
              }
            }
            else {
              if (param_1 != 0) {
                FUN_005ac170(&uStack_18,&uStack_14);
              }
              if (((iVar6 == 0) != (iVar10 == 0)) &&
                 (cVar4 = FUN_00554e30(fStack_40,fStack_4c,uStack_18,uStack_14,fStack_44,fStack_48,
                                       param_2,param_3), cVar4 != '\0')) {
                bVar2 = (bool)(bVar2 ^ 1);
              }
            }
            if ((bVar3) && (iStack_3c != 0)) {
              if (cStack_8 == '\0') {
                pGVar1 = this + 0x3c;
                fStack_20 = fStack_10;
                uVar9 = *(uint *)(this + 0x3c) >> 8;
                fStack_1c = fStack_c;
                if (*(uint *)(this + 0x40) <= uVar9) {
                  FUN_00555d30(uVar9);
                }
                uVar7 = *(uint *)pGVar1;
                iVar6 = *(int *)(*(int *)(this + 0x48) + uVar9 * 4);
                *(float *)(iVar6 + (uVar7 & 0xff) * 8) = fStack_20;
                *(float *)(iVar6 + 4 + (uVar7 & 0xff) * 8) = fStack_1c;
                *(uint *)pGVar1 = *(uint *)pGVar1 + 1;
                *(int *)(*(int *)(this + 0x5c) + 4) = *(int *)(*(int *)(this + 0x5c) + 4) + 1;
                iVar6 = local_34;
                iVar10 = iStack_30;
                goto LAB_0055a63f;
              }
              FUN_005dd880(uStack_18,uStack_14,fStack_10,fStack_c);
              fStack_50 = fStack_c;
              fVar11 = fStack_10;
            }
            else {
LAB_0055a63f:
              fStack_50 = fStack_c;
              fVar11 = fStack_10;
            }
          }
        }
      }
      cVar4 = *(char *)(unaff_retaddr + 0x20);
    } while (cVar4 != '\x01');
    if (bVar2) {
LAB_0055a654:
      if (this != (GRefCountNTSImpl *)0x0) {
LAB_0055a658:
        GRefCountNTSImpl::Release(this);
      }
      return 1;
    }
    if (this != (GRefCountNTSImpl *)0x0) {
      uVar9 = 0;
      if (*(int *)(this + 0x4c) != 0) {
        do {
          iVar6 = *(int *)(*(int *)(this + 0x58) + (uVar9 >> 6) * 4) + (uVar9 & 0x3f) * 0x18;
          iVar10 = iStack_2c + *(int *)(iVar6 + 0x14) * 0x18;
          if (20.0 <= (double)*(ushort *)(iVar10 + 4)) {
            fVar11 = (float)*(ushort *)(iVar10 + 4);
          }
          else {
            fVar11 = 20.0;
          }
          fVar11 = fVar11 * 0.5;
          *(float *)(this + 8) = fVar11;
          if (fVar11 < 0.0) {
            fVar11 = -fVar11;
          }
          *(float *)(this + 0xc) = fVar11;
          uVar5 = *(ushort *)(iVar10 + 0x10) & 0x30;
          if (uVar5 == 0x10) {
            uVar7 = 4;
          }
          else {
            uVar7 = -(uint)(uVar5 != 0x20) & 3;
          }
          *(uint *)(this + 0x10) = uVar7;
          uVar5 = *(ushort *)(iVar10 + 0x10) & 0xc0;
          if (uVar5 == 0x40) {
            uVar8 = 0;
          }
          else if (uVar5 == 0x80) {
            uVar8 = 1;
          }
          else {
            uVar8 = 2;
          }
          *(undefined4 *)(this + 0x14) = uVar8;
          uVar5 = *(ushort *)(iVar10 + 0x10) >> 2 & 0xc0;
          if (uVar5 == 0x40) {
            uVar8 = 0;
          }
          else if (uVar5 == 0x80) {
            uVar8 = 1;
          }
          else {
            uVar8 = 2;
          }
          *(undefined4 *)(this + 0x18) = uVar8;
          if ((*(byte *)(iVar10 + 0x10) & 0x30) == 0x20) {
            *(undefined4 *)(this + 0x1c) = *(undefined4 *)(iVar10 + 0x14);
          }
          FUN_005dd100();
          FUN_005d8f40(iVar6,this + 0x7c,1);
          cVar4 = FUN_005dd240(param_2,param_3,1);
          if (cVar4 != '\0') goto LAB_0055a658;
          uVar9 = uVar9 + 1;
        } while (uVar9 < *(uint *)(this + 0x4c));
      }
      GRefCountNTSImpl::Release(this);
    }
  }
  return 0;
}



============================================================
DISASSEMBLY
============================================================
0055a1e0 : SUB ESP,0x54
0055a1e3 : PUSH EBX
0055a1e4 : PUSH EBP
0055a1e5 : PUSH ESI
0055a1e6 : MOV ESI,ECX
0055a1e8 : MOV EAX,dword ptr [ESI]
0055a1ea : MOV EDX,dword ptr [EAX + 0x28]
0055a1ed : PUSH EDI
0055a1ee : LEA ECX,[ESP + 0x30]
0055a1f2 : PUSH ECX
0055a1f3 : XOR EBP,EBP
0055a1f5 : MOV ECX,ESI
0055a1f7 : MOV dword ptr [ESP + 0x34],EBP
0055a1fb : CALL EDX
0055a1fd : MOV dword ptr [ESP + 0x3c],EAX
0055a201 : CMP dword ptr [ESP + 0x30],EBP
0055a205 : JZ 0x0055a212
0055a207 : TEST byte ptr [ESI + 0x24],0x40
0055a20b : MOV byte ptr [ESP + 0x13],0x1
0055a210 : JNZ 0x0055a217
0055a212 : MOV byte ptr [ESP + 0x13],0x0
0055a217 : MOV EBX,dword ptr [ESP + 0x68]
0055a21b : MOV AL,byte ptr [EBX + 0x20]
0055a21e : MOV dword ptr [ESP + 0x14],EBP
0055a222 : CMP AL,0x1
0055a224 : JZ 0x0055a768
0055a22a : LEA EBX,[EBX]
0055a230 : CMP AL,0x2
0055a232 : JNZ 0x0055a2cb
0055a238 : CMP dword ptr [ESP + 0x14],0x0
0055a23d : JNZ 0x0055a654
0055a243 : MOV ECX,EBX
0055a245 : CALL 0x00553740
0055a24a : CMP byte ptr [EBX + 0x20],0x3
0055a24e : JZ 0x0055a243
0055a250 : MOV dword ptr [ESP + 0x14],0x0
0055a258 : MOV AL,byte ptr [EBX + 0x20]
0055a25b : CMP AL,0x1
0055a25d : JNZ 0x0055a230
0055a25f : CMP dword ptr [ESP + 0x14],0x0
0055a264 : JNZ 0x0055a654
0055a26a : TEST EBP,EBP
0055a26c : JZ 0x0055a768
0055a272 : XOR EDI,EDI
0055a274 : CMP dword ptr [EBP + 0x4c],EDI
0055a277 : JBE 0x0055a761
0055a27d : LEA EBX,[EBP + 0x8]
0055a280 : MOV EDX,dword ptr [EBP + 0x58]
0055a283 : MOV ECX,EDI
0055a285 : SHR ECX,0x6
0055a288 : MOV ECX,dword ptr [EDX + ECX*0x4]
0055a28b : MOV EAX,EDI
0055a28d : AND EAX,0x3f
0055a290 : LEA EAX,[EAX + EAX*0x2]
0055a293 : LEA ESI,[ECX + EAX*0x8]
0055a296 : MOV EAX,dword ptr [ESI + 0x14]
0055a299 : LEA EDX,[EAX + EAX*0x2]
0055a29c : MOV EAX,dword ptr [ESP + 0x3c]
0055a2a0 : LEA ECX,[EAX + EDX*0x8]
0055a2a3 : MOVZX EDX,word ptr [ECX + 0x4]
0055a2a7 : MOV dword ptr [ESP + 0x6c],EDX
0055a2ab : FILD dword ptr [ESP + 0x6c]
0055a2af : FCOMP double ptr [0x00b86058]
0055a2b5 : FNSTSW AX
0055a2b7 : TEST AH,0x5
0055a2ba : JP 0x0055a66b
0055a2c0 : FLD float ptr [0x00cdf140]
0055a2c6 : JMP 0x0055a66f
0055a2cb : MOV EAX,dword ptr [EBX + 0x1c]
0055a2ce : MOV ESI,dword ptr [EBX + 0x14]
0055a2d1 : MOV EDI,dword ptr [EBX + 0x18]
0055a2d4 : MOV dword ptr [ESP + 0x34],ESI
0055a2d8 : MOV dword ptr [ESP + 0x38],EDI
0055a2dc : MOV dword ptr [ESP + 0x2c],EAX
0055a2e0 : TEST EAX,EAX
0055a2e2 : JA 0x0055a302
0055a2e4 : XOR EAX,EAX
0055a2e6 : TEST ESI,ESI
0055a2e8 : SETZ AL
0055a2eb : XOR ECX,ECX
0055a2ed : TEST EDI,EDI
0055a2ef : SETZ CL
0055a2f2 : CMP EAX,ECX
0055a2f4 : JNZ 0x0055a302
0055a2f6 : MOV ECX,EBX
0055a2f8 : CALL 0x005564c0
0055a2fd : JMP 0x0055a258
0055a302 : MOV AL,byte ptr [EBX + 0x20]
0055a305 : MOV dword ptr [ESP + 0x40],EBX
0055a309 : MOV dword ptr [ESP + 0x44],0x0
0055a311 : TEST AL,AL
0055a313 : JS 0x0055a32d
0055a315 : CMP AL,0x1
0055a317 : JZ 0x0055a32d
0055a319 : LEA ESP,[ESP]
0055a320 : MOV ECX,EBX
0055a322 : CALL 0x00553740
0055a327 : CMP byte ptr [EBX + 0x20],0x3
0055a32b : JZ 0x0055a320
0055a32d : FILD dword ptr [EBX + 0x2c]
0055a330 : FSTP float ptr [ESP + 0x68]
0055a334 : FILD dword ptr [EBX + 0x30]
0055a337 : FSTP float ptr [ESP + 0x18]
0055a33b : TEST byte ptr [EBX + 0x70],0x80
0055a33f : JZ 0x0055a357
0055a341 : FLD float ptr [EBX + 0x6c]
0055a344 : FMUL float ptr [ESP + 0x68]
0055a348 : FSTP float ptr [ESP + 0x68]
0055a34c : FLD float ptr [EBX + 0x6c]
0055a34f : FMUL float ptr [ESP + 0x18]
0055a353 : FSTP float ptr [ESP + 0x18]
0055a357 : CMP dword ptr [ESP + 0x6c],0x0
0055a35c : JZ 0x0055a371
0055a35e : MOV ECX,dword ptr [ESP + 0x6c]
0055a362 : LEA EDX,[ESP + 0x18]
0055a366 : PUSH EDX
0055a367 : LEA EAX,[ESP + 0x6c]
0055a36b : PUSH EAX
0055a36c : CALL 0x005ac170
0055a371 : CMP byte ptr [ESP + 0x13],0x0
0055a376 : JZ 0x0055a400
0055a37c : CMP dword ptr [ESP + 0x2c],0x0
0055a381 : JBE 0x0055a400
0055a383 : TEST EBP,EBP
0055a385 : JNZ 0x0055a3d5
0055a387 : MOV ECX,dword ptr [0x00d73250]
0055a38d : PUSH EBP
0055a38e : PUSH 0xc4
0055a393 : CALL 0x00515840
0055a398 : TEST EAX,EAX
0055a39a : JZ 0x0055a3a7
0055a39c : MOV ECX,EAX
0055a39e : CALL 0x005595a0
0055a3a3 : MOV ESI,EAX
0055a3a5 : JMP 0x0055a3a9
0055a3a7 : XOR ESI,ESI
0055a3a9 : FLD float ptr [0x00cdf140]
0055a3af : PUSH ECX
0055a3b0 : LEA EDI,[ESI + 0x34]
0055a3b3 : FSTP float ptr [ESP]
0055a3b6 : MOV ECX,EDI
0055a3b8 : MOV EBP,ESI
0055a3ba : CALL 0x005dcbb0
0055a3bf : FLD float ptr [EDI]
0055a3c1 : PUSH ECX
0055a3c2 : LEA ECX,[ESI + 0x7c]
0055a3c5 : FSTP float ptr [ESP]
0055a3c8 : CALL 0x005dcbb0
0055a3cd : MOV ESI,dword ptr [ESP + 0x34]
0055a3d1 : MOV EDI,dword ptr [ESP + 0x38]
0055a3d5 : FLD float ptr [ESP + 0x18]
0055a3d9 : MOV ECX,dword ptr [ESP + 0x2c]
0055a3dd : SUB ESP,0x8
0055a3e0 : FSTP float ptr [ESP + 0x4]
0055a3e4 : DEC ECX
0055a3e5 : FLD float ptr [ESP + 0x70]
0055a3e9 : FSTP float ptr [ESP]
0055a3ec : PUSH ECX
0055a3ed : PUSH -0x1
0055a3ef : PUSH -0x1
0055a3f1 : LEA ECX,[EBP + 0x34]
0055a3f4 : CALL 0x005dd510
0055a3f9 : LEA ESP,[ESP]
0055a400 : MOV EDX,dword ptr [ESP + 0x40]
0055a404 : MOV AL,byte ptr [EDX + 0x20]
0055a407 : CMP AL,0x1
0055a409 : JZ 0x0055a258
0055a40f : TEST AL,AL
0055a411 : JNS 0x0055a258
0055a417 : PUSH 0x0
0055a419 : LEA EAX,[ESP + 0x54]
0055a41d : PUSH EAX
0055a41e : LEA ECX,[ESP + 0x48]
0055a422 : CALL 0x005542d0
0055a427 : CMP dword ptr [ESP + 0x6c],0x0
0055a42c : JZ 0x0055a441
0055a42e : LEA ECX,[ESP + 0x5c]
0055a432 : PUSH ECX
0055a433 : MOV ECX,dword ptr [ESP + 0x70]
0055a437 : LEA EDX,[ESP + 0x5c]
0055a43b : PUSH EDX
0055a43c : CALL 0x005ac170
0055a441 : FLD float ptr [ESP + 0x68]
0055a445 : FST float ptr [ESP + 0x28]
0055a449 : FLD float ptr [ESP + 0x18]
0055a44d : FST float ptr [ESP + 0x1c]
0055a451 : FLD float ptr [ESP + 0x58]
0055a455 : FST float ptr [ESP + 0x24]
0055a459 : FLD float ptr [ESP + 0x5c]
0055a45d : FST float ptr [ESP + 0x20]
0055a461 : FCOM ST2
0055a463 : FNSTSW AX
0055a465 : TEST AH,0x5
0055a468 : JP 0x0055a482
0055a46a : FXCH
0055a46c : FSTP float ptr [ESP + 0x28]
0055a470 : FXCH ST2
0055a472 : FSTP float ptr [ESP + 0x24]
0055a476 : FXCH
0055a478 : FSTP float ptr [ESP + 0x1c]
0055a47c : FSTP float ptr [ESP + 0x20]
0055a480 : JMP 0x0055a48a
0055a482 : FSTP ST2
0055a484 : FSTP ST2
0055a486 : FSTP ST0
0055a488 : FSTP ST0
0055a48a : CMP byte ptr [ESP + 0x60],0x0
0055a48f : JZ 0x0055a51d
0055a495 : CMP dword ptr [ESP + 0x6c],0x0
0055a49a : JZ 0x0055a4af
0055a49c : LEA EAX,[ESP + 0x54]
0055a4a0 : PUSH EAX
0055a4a1 : LEA ECX,[ESP + 0x54]
0055a4a5 : PUSH ECX
0055a4a6 : MOV ECX,dword ptr [ESP + 0x74]
0055a4aa : CALL 0x005ac170
0055a4af : XOR EDX,EDX
0055a4b1 : TEST ESI,ESI
0055a4b3 : SETZ DL
0055a4b6 : XOR EAX,EAX
0055a4b8 : TEST EDI,EDI
0055a4ba : SETZ AL
0055a4bd : CMP EDX,EAX
0055a4bf : JZ 0x0055a591
0055a4c5 : FLD float ptr [ESP + 0x74]
0055a4c9 : SUB ESP,0x20
0055a4cc : FSTP float ptr [ESP + 0x1c]
0055a4d0 : FLD float ptr [ESP + 0x90]
0055a4d7 : FSTP float ptr [ESP + 0x18]
0055a4db : FLD float ptr [ESP + 0x40]
0055a4df : FSTP float ptr [ESP + 0x14]
0055a4e3 : FLD float ptr [ESP + 0x44]
0055a4e7 : FSTP float ptr [ESP + 0x10]
0055a4eb : FLD float ptr [ESP + 0x74]
0055a4ef : FSTP float ptr [ESP + 0xc]
0055a4f3 : FLD float ptr [ESP + 0x70]
0055a4f7 : FSTP float ptr [ESP + 0x8]
0055a4fb : FLD float ptr [ESP + 0x3c]
0055a4ff : FSTP float ptr [ESP + 0x4]
0055a503 : FLD float ptr [ESP + 0x48]
0055a507 : FSTP float ptr [ESP]
0055a50a : CALL 0x00554e30
0055a50f : ADD ESP,0x20
0055a512 : TEST AL,AL
0055a514 : JZ 0x0055a591
0055a516 : XOR dword ptr [ESP + 0x14],0x1
0055a51b : JMP 0x0055a591
0055a51d : XOR ECX,ECX
0055a51f : TEST ESI,ESI
0055a521 : SETZ CL
0055a524 : XOR EDX,EDX
0055a526 : TEST EDI,EDI
0055a528 : SETZ DL
0055a52b : CMP ECX,EDX
0055a52d : JZ 0x0055a591
0055a52f : FLD float ptr [ESP + 0x74]
0055a533 : FLD float ptr [ESP + 0x1c]
0055a537 : FCOM
0055a539 : FNSTSW AX
0055a53b : TEST AH,0x41
0055a53e : JP 0x0055a58d
0055a540 : FLD float ptr [ESP + 0x20]
0055a544 : FCOM ST2
0055a546 : FNSTSW AX
0055a548 : TEST AH,0x41
0055a54b : JNZ 0x0055a58b
0055a54d : FLD ST0
0055a54f : FSUBRP ST2,ST0
0055a551 : FLD float ptr [ESP + 0x70]
0055a555 : FLD float ptr [ESP + 0x24]
0055a559 : FLD ST0
0055a55b : FSUBP ST2,ST0
0055a55d : FXCH ST3
0055a55f : FMULP
0055a561 : FLD float ptr [ESP + 0x28]
0055a565 : FSUBP ST3,ST0
0055a567 : FXCH ST3
0055a569 : FSUBRP
0055a56b : FMULP
0055a56d : FSUBP
0055a56f : FSTP float ptr [ESP + 0x28]
0055a573 : FLD float ptr [ESP + 0x28]
0055a577 : FCOMP float ptr [0x00b9b0b4]
0055a57d : FNSTSW AX
0055a57f : TEST AH,0x41
0055a582 : JNZ 0x0055a591
0055a584 : XOR dword ptr [ESP + 0x14],0x1
0055a589 : JMP 0x0055a591
0055a58b : FSTP ST0
0055a58d : FSTP ST0
0055a58f : FSTP ST0
0055a591 : CMP byte ptr [ESP + 0x13],0x0
0055a596 : JZ 0x0055a63f
0055a59c : CMP dword ptr [ESP + 0x2c],0x0
0055a5a1 : JBE 0x0055a63f
0055a5a7 : CMP byte ptr [ESP + 0x60],0x0
0055a5ac : JZ 0x0055a5ed
0055a5ae : FLD float ptr [ESP + 0x5c]
0055a5b2 : SUB ESP,0x10
0055a5b5 : FSTP float ptr [ESP + 0xc]
0055a5b9 : LEA ECX,[EBP + 0x34]
0055a5bc : FLD float ptr [ESP + 0x68]
0055a5c0 : FSTP float ptr [ESP + 0x8]
0055a5c4 : FLD float ptr [ESP + 0x64]
0055a5c8 : FSTP float ptr [ESP + 0x4]
0055a5cc : FLD float ptr [ESP + 0x60]
0055a5d0 : FSTP float ptr [ESP]
0055a5d3 : CALL 0x005dd880
0055a5d8 : FLD float ptr [ESP + 0x58]
0055a5dc : FSTP float ptr [ESP + 0x68]
0055a5e0 : FLD float ptr [ESP + 0x5c]
0055a5e4 : FSTP float ptr [ESP + 0x18]
0055a5e8 : JMP 0x0055a400
0055a5ed : FLD float ptr [ESP + 0x58]
0055a5f1 : MOV EDI,dword ptr [EBP + 0x3c]
0055a5f4 : LEA ESI,[EBP + 0x3c]
0055a5f7 : FSTP float ptr [ESP + 0x48]
0055a5fb : FLD float ptr [ESP + 0x5c]
0055a5ff : SHR EDI,0x8
0055a602 : FSTP float ptr [ESP + 0x4c]
0055a606 : CMP EDI,dword ptr [ESI + 0x4]
0055a609 : JC 0x0055a613
0055a60b : PUSH EDI
0055a60c : MOV ECX,ESI
0055a60e : CALL 0x00555d30
0055a613 : MOV EAX,dword ptr [ESI]
0055a615 : MOV ECX,dword ptr [ESI + 0xc]
0055a618 : MOV ECX,dword ptr [ECX + EDI*0x4]
0055a61b : MOV EDX,dword ptr [ESP + 0x48]
0055a61f : MOV EDI,dword ptr [ESP + 0x38]
0055a623 : AND EAX,0xff
0055a628 : MOV dword ptr [ECX + EAX*0x8],EDX
0055a62b : MOV EDX,dword ptr [ESP + 0x4c]
0055a62f : MOV dword ptr [ECX + EAX*0x8 + 0x4],EDX
0055a633 : INC dword ptr [ESI]
0055a635 : MOV EAX,dword ptr [EBP + 0x5c]
0055a638 : INC dword ptr [EAX + 0x4]
0055a63b : MOV ESI,dword ptr [ESP + 0x34]
0055a63f : FLD float ptr [ESP + 0x58]
0055a643 : FSTP float ptr [ESP + 0x68]
0055a647 : FLD float ptr [ESP + 0x5c]
0055a64b : FSTP float ptr [ESP + 0x18]
0055a64f : JMP 0x0055a400
0055a654 : TEST EBP,EBP
0055a656 : JZ 0x0055a65f
0055a658 : MOV ECX,EBP
0055a65a : CALL 0x004ff7c0
0055a65f : POP EDI
0055a660 : POP ESI
0055a661 : POP EBP
0055a662 : MOV AL,0x1
0055a664 : POP EBX
0055a665 : ADD ESP,0x54
0055a668 : RET 0x10
0055a66b : FILD dword ptr [ESP + 0x6c]
0055a66f : FSTP float ptr [ESP + 0x6c]
0055a673 : FLD float ptr [ESP + 0x6c]
0055a677 : FMUL double ptr [0x00cdf120]
0055a67d : FSTP float ptr [ESP + 0x6c]
0055a681 : FLD float ptr [ESP + 0x6c]
0055a685 : FST float ptr [EBX]
0055a687 : FLDZ
0055a689 : FCOMP
0055a68b : FNSTSW AX
0055a68d : TEST AH,0x41
0055a690 : JNZ 0x0055a694
0055a692 : FCHS
0055a694 : FSTP float ptr [ESP + 0x6c]
0055a698 : FLD float ptr [ESP + 0x6c]
0055a69c : FSTP float ptr [EBX + 0x4]
0055a69f : MOVZX EAX,word ptr [ECX + 0x10]
0055a6a3 : AND EAX,0x30
0055a6a6 : CMP EAX,0x10
0055a6a9 : JZ 0x0055a6b7
0055a6ab : SUB EAX,0x20
0055a6ae : NEG EAX
0055a6b0 : SBB EAX,EAX
0055a6b2 : AND EAX,0x3
0055a6b5 : JMP 0x0055a6bc
0055a6b7 : MOV EAX,0x4
0055a6bc : MOV dword ptr [EBP + 0x10],EAX
0055a6bf : MOVZX EAX,word ptr [ECX + 0x10]
0055a6c3 : AND EAX,0xc0
0055a6c8 : SUB EAX,0x40
0055a6cb : JZ 0x0055a6e0
0055a6cd : SUB EAX,0x40
0055a6d0 : JZ 0x0055a6d9
0055a6d2 : MOV EAX,0x2
0055a6d7 : JMP 0x0055a6e2
0055a6d9 : MOV EAX,0x1
0055a6de : JMP 0x0055a6e2
0055a6e0 : XOR EAX,EAX
0055a6e2 : MOV dword ptr [EBP + 0x14],EAX
0055a6e5 : MOVZX EAX,word ptr [ECX + 0x10]
0055a6e9 : SHR EAX,0x2
0055a6ec : AND EAX,0xc0
0055a6f1 : SUB EAX,0x40
0055a6f4 : JZ 0x0055a709
0055a6f6 : SUB EAX,0x40
0055a6f9 : JZ 0x0055a702
0055a6fb : MOV EAX,0x2
0055a700 : JMP 0x0055a70b
0055a702 : MOV EAX,0x1
0055a707 : JMP 0x0055a70b
0055a709 : XOR EAX,EAX
0055a70b : MOV dword ptr [EBP + 0x18],EAX
0055a70e : MOV AL,byte ptr [ECX + 0x10]
0055a711 : AND AL,0x30
0055a713 : CMP AL,0x20
0055a715 : JNZ 0x0055a71d
0055a717 : FLD float ptr [ECX + 0x14]
0055a71a : FSTP float ptr [EBP + 0x1c]
0055a71d : LEA ECX,[EBP + 0x7c]
0055a720 : CALL 0x005dd100
0055a725 : PUSH 0x1
0055a727 : LEA EAX,[EBP + 0x7c]
0055a72a : PUSH EAX
0055a72b : PUSH ESI
0055a72c : MOV ECX,EBX
0055a72e : CALL 0x005d8f40
0055a733 : FLD float ptr [ESP + 0x74]
0055a737 : PUSH 0x1
0055a739 : SUB ESP,0x8
0055a73c : FSTP float ptr [ESP + 0x4]
0055a740 : LEA ECX,[EBP + 0x7c]
0055a743 : FLD float ptr [ESP + 0x7c]
0055a747 : FSTP float ptr [ESP]
0055a74a : CALL 0x005dd240
0055a74f : TEST AL,AL
0055a751 : JNZ 0x0055a658
0055a757 : INC EDI
0055a758 : CMP EDI,dword ptr [EBP + 0x4c]
0055a75b : JC 0x0055a280
0055a761 : MOV ECX,EBP
0055a763 : CALL 0x004ff7c0
0055a768 : POP EDI
0055a769 : POP ESI
0055a76a : POP EBP
0055a76b : XOR AL,AL
0055a76d : POP EBX
0055a76e : ADD ESP,0x54
0055a771 : RET 0x10
