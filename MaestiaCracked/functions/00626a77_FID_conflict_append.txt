PROGRAM  : Maestia.exe
FUNCTION : FID_conflict:append
ENTRY    : 00626a77
BODY     : [[00626a77, 00626b21]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Multiple Matches With Different Base Names
    public: class std::basic_string<unsigned short,struct std::char_traits<unsigned short>,class
   std::allocator<unsigned short> > & __thiscall std::basic_string<unsigned short,struct
   std::char_traits<unsigned short>,class std::allocator<unsigned short> >::append(class
   std::basic_string<unsigned short,struct std::char_traits<unsigned short>,class
   std::allocator<unsigned short> > const &,unsigned int,unsigned int)
    public: class std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> > & __thiscall std::basic_string<wchar_t,struct
   std::char_traits<wchar_t>,class std::allocator<wchar_t> >::append(class
   std::basic_string<wchar_t,struct std::char_traits<wchar_t>,class std::allocator<wchar_t> > const
   &,unsigned int,unsigned int)
   
   Library: Visual Studio 2008 Release */

void FID_conflict_append(int param_1,uint param_2,uint param_3)

{
  char cVar1;
  uint uVar2;
  int iVar3;
  int in_ECX;
  int iVar4;
  
  if (*(uint *)(param_1 + 0x14) < param_2) {
    FUN_00622f07();
  }
  uVar2 = *(int *)(param_1 + 0x14) - param_2;
  if (uVar2 < param_3) {
    param_3 = uVar2;
  }
  if ((-*(int *)(in_ECX + 0x14) - 1U <= param_3) ||
     (*(uint *)(in_ECX + 0x14) + param_3 < *(uint *)(in_ECX + 0x14))) {
    FUN_00622ecf();
  }
  if (param_3 != 0) {
    iVar3 = *(int *)(in_ECX + 0x14) + param_3;
    cVar1 = FID_conflict__Grow(iVar3,0);
    if (cVar1 != '\0') {
      if (*(uint *)(param_1 + 0x18) < 8) {
        param_1 = param_1 + 4;
      }
      else {
        param_1 = *(int *)(param_1 + 4);
      }
      if (*(uint *)(in_ECX + 0x18) < 8) {
        iVar4 = in_ECX + 4;
      }
      else {
        iVar4 = *(int *)(in_ECX + 4);
      }
      copy_s<>(iVar4 + *(int *)(in_ECX + 0x14) * 2,
               *(uint *)(in_ECX + 0x18) - *(int *)(in_ECX + 0x14),param_1 + param_2 * 2,param_3);
      FID_conflict__Eos(iVar3);
    }
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00626a77 : MOV EDI,EDI
00626a79 : PUSH EBP
00626a7a : MOV EBP,ESP
00626a7c : PUSH EBX
00626a7d : MOV EBX,dword ptr [EBP + 0xc]
00626a80 : PUSH ESI
00626a81 : PUSH EDI
00626a82 : MOV EDI,dword ptr [EBP + 0x8]
00626a85 : MOV ESI,ECX
00626a87 : CMP dword ptr [EDI + 0x14],EBX
00626a8a : JNC 0x00626a91
00626a8c : CALL 0x00622f07
00626a91 : MOV EAX,dword ptr [EDI + 0x14]
00626a94 : SUB EAX,EBX
00626a96 : MOV EBX,dword ptr [EBP + 0x10]
00626a99 : CMP EAX,EBX
00626a9b : JNC 0x00626aa2
00626a9d : MOV EBX,EAX
00626a9f : MOV dword ptr [EBP + 0x10],EBX
00626aa2 : OR EAX,0xffffffff
00626aa5 : SUB EAX,dword ptr [ESI + 0x14]
00626aa8 : CMP EAX,EBX
00626aaa : JBE 0x00626ab6
00626aac : MOV EAX,dword ptr [ESI + 0x14]
00626aaf : LEA ECX,[EAX + EBX*0x1]
00626ab2 : CMP ECX,EAX
00626ab4 : JNC 0x00626abb
00626ab6 : CALL 0x00622ecf
00626abb : TEST EBX,EBX
00626abd : JBE 0x00626b19
00626abf : MOV EAX,dword ptr [ESI + 0x14]
00626ac2 : ADD EAX,EBX
00626ac4 : PUSH 0x0
00626ac6 : PUSH EAX
00626ac7 : MOV ECX,ESI
00626ac9 : MOV dword ptr [EBP + 0x8],EAX
00626acc : CALL 0x006269f9
00626ad1 : TEST AL,AL
00626ad3 : JZ 0x00626b19
00626ad5 : CMP dword ptr [EDI + 0x18],0x8
00626ad9 : JC 0x00626ae0
00626adb : MOV EDI,dword ptr [EDI + 0x4]
00626ade : JMP 0x00626ae3
00626ae0 : ADD EDI,0x4
00626ae3 : MOV EAX,dword ptr [ESI + 0x18]
00626ae6 : CMP EAX,0x8
00626ae9 : JC 0x00626af0
00626aeb : MOV EDX,dword ptr [ESI + 0x4]
00626aee : JMP 0x00626af3
00626af0 : LEA EDX,[ESI + 0x4]
00626af3 : PUSH dword ptr [EBP + 0x10]
00626af6 : MOV ECX,dword ptr [ESI + 0x14]
00626af9 : MOV EBX,dword ptr [EBP + 0xc]
00626afc : LEA EDI,[EDI + EBX*0x2]
00626aff : SUB EAX,ECX
00626b01 : PUSH EDI
00626b02 : PUSH EAX
00626b03 : LEA EAX,[EDX + ECX*0x2]
00626b06 : PUSH EAX
00626b07 : CALL 0x0062634c
00626b0c : ADD ESP,0x10
00626b0f : PUSH dword ptr [EBP + 0x8]
00626b12 : MOV ECX,ESI
00626b14 : CALL 0x006262b6
00626b19 : POP EDI
00626b1a : MOV EAX,ESI
00626b1c : POP ESI
00626b1d : POP EBX
00626b1e : POP EBP
00626b1f : RET 0xc
