PROGRAM  : Maestia.exe
FUNCTION : FUN_005551b0
ENTRY    : 005551b0
BODY     : [[005551b0, 0055568f]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_005551b0(int param_1,int *param_2)

{
  int iVar1;
  short sVar2;
  uint uVar3;
  uint *in_ECX;
  undefined2 *puVar4;
  undefined2 *puVar5;
  int iVar6;
  uint *puVar7;
  ushort *puVar8;
  ushort *puVar9;
  ushort *puVar10;
  uint *puVar11;
  uint *puVar12;
  int iVar13;
  ushort *puVar14;
  ushort uVar15;
  uint uVar16;
  int iVar17;
  uint *puVar18;
  byte bVar19;
  byte local_7;
  byte local_6;
  byte local_5;
  byte *local_4;
  
  uVar3 = in_ECX[1] | *in_ECX | in_ECX[2];
  iVar13 = 4;
  if (uVar3 < 0x8000) {
    if (uVar3 < 0x80) {
      if (uVar3 < 8) {
        if (uVar3 < 2) {
          bVar19 = uVar3 != 0;
        }
        else {
          bVar19 = 3 - (uVar3 < 4);
        }
      }
      else if (uVar3 < 0x20) {
        bVar19 = 5 - (uVar3 < 0x10);
      }
      else {
        bVar19 = 7 - (uVar3 < 0x40);
      }
    }
    else if (uVar3 < 0x800) {
      if (uVar3 < 0x200) {
        bVar19 = 9 - (uVar3 < 0x100);
      }
      else {
        bVar19 = 0xb - (uVar3 < 0x400);
      }
    }
    else if (uVar3 < 0x2000) {
      bVar19 = 0xd - (uVar3 < 0x1000);
    }
    else {
      bVar19 = 0xf - (uVar3 < 0x4000);
    }
  }
  else if (uVar3 < 0x800000) {
    if (uVar3 < 0x80000) {
      if (uVar3 < 0x20000) {
        bVar19 = 0x11 - (uVar3 < 0x10000);
      }
      else {
        bVar19 = 0x13 - (uVar3 < 0x40000);
      }
    }
    else if (uVar3 < 0x200000) {
      bVar19 = 0x15 - (uVar3 < 0x100000);
    }
    else {
      bVar19 = 0x17 - (uVar3 < 0x400000);
    }
  }
  else if (uVar3 < 0x8000000) {
    if (uVar3 < 0x2000000) {
      bVar19 = 0x19 - (uVar3 < 0x1000000);
    }
    else {
      bVar19 = 0x1b - (uVar3 < 0x4000000);
    }
  }
  else if (uVar3 < 0x20000000) {
    bVar19 = 0x1d - (uVar3 < 0x10000000);
  }
  else if (uVar3 < 0x40000000) {
    bVar19 = 0x1e;
  }
  else {
    bVar19 = 0x20 - (uVar3 < 0x80000000);
  }
  if (*(char *)((int)in_ECX + 0x35) == '\0') {
    if (((bVar19 < 9) && ((byte)in_ECX[0xd] < 0x11)) && (in_ECX[10] < 5)) {
      uVar3 = in_ECX[10];
      local_6 = 0;
      local_4 = (byte *)FUN_005550f0((in_ECX[0xc] + in_ECX[0xb] * 2) * 4 + 4,1,2);
      local_4[1] = (byte)*in_ECX;
      local_4[2] = (byte)in_ECX[1];
      local_4[3] = (byte)in_ECX[2];
      puVar4 = (undefined2 *)((uint)(local_4 + 5) & 0xfffffffe);
      *puVar4 = (short)in_ECX[3];
      puVar4[1] = (short)in_ECX[4];
      local_7 = 1;
      local_5 = 0;
      if (in_ECX[10] != 0) {
        uVar16 = 0;
        do {
          puVar5 = puVar4 + 2;
          iVar13 = uVar16 * 0x14;
          if (*(char *)(in_ECX[7] + 0x10 + iVar13) == '\0') {
            *puVar5 = *(undefined2 *)(in_ECX[7] + iVar13);
            puVar4[3] = *(undefined2 *)(in_ECX[7] + 4 + iVar13);
            puVar5 = puVar4 + 4;
            local_6 = local_6 | local_7;
          }
          local_7 = local_7 << 1;
          *puVar5 = *(undefined2 *)(in_ECX[7] + 8 + iVar13);
          local_5 = local_5 + 1;
          uVar16 = (uint)local_5;
          puVar5[1] = *(undefined2 *)(in_ECX[7] + 0xc + iVar13);
          puVar4 = puVar5;
        } while (uVar16 < in_ECX[10]);
      }
      *local_4 = (local_6 & 0xf) * '\b' | ((char)uVar3 - 1U & 3) * '\x02' | 1;
    }
    else {
      iVar17 = 1;
      if (bVar19 < 9) {
        bVar19 = 2;
      }
      else if (bVar19 < 0x11) {
        bVar19 = 4;
        iVar17 = 2;
      }
      else {
        bVar19 = 6;
        iVar17 = 4;
      }
      if (((byte)in_ECX[0xd] < 0x11) && (in_ECX[10] < 0x10000)) {
        iVar13 = 2;
      }
      else {
        bVar19 = bVar19 | 8;
      }
      uVar3 = in_ECX[10];
      iVar6 = iVar13;
      if (uVar3 < 0x10) {
        bVar19 = bVar19 | (char)uVar3 << 4;
        iVar6 = 0;
      }
      if ((byte)in_ECX[0xd] < 0x11) {
        iVar1 = (uVar3 + 0xf >> 4) * 2;
      }
      else {
        iVar1 = (uVar3 + 0x1f >> 5) * 4;
      }
      local_4 = (byte *)FUN_005550f0(iVar6 + iVar1 +
                                     (in_ECX[0xc] + 1 + in_ECX[0xb] * 2) * iVar13 * 2,iVar17,iVar13)
      ;
      *local_4 = bVar19;
      puVar7 = (uint *)((uint)(local_4 + iVar17) & ~(iVar17 - 1U));
      if (iVar17 == 1) {
        *(char *)puVar7 = (char)*in_ECX;
        *(char *)((int)puVar7 + 1) = (char)in_ECX[1];
        *(char *)((int)puVar7 + 2) = (char)in_ECX[2];
      }
      else if (iVar17 == 2) {
        *(short *)puVar7 = (short)*in_ECX;
        *(short *)((int)puVar7 + 2) = (short)in_ECX[1];
        *(short *)(puVar7 + 1) = (short)in_ECX[2];
      }
      else if (iVar17 == 4) {
        *puVar7 = *in_ECX;
        puVar7[1] = in_ECX[1];
        puVar7[2] = in_ECX[2];
      }
      if (iVar13 == 2) {
        puVar8 = (ushort *)((uint)(iVar17 * 3 + 1 + (int)puVar7) & 0xfffffffe);
        if (0xf < in_ECX[10]) {
          *puVar8 = (ushort)in_ECX[10];
          puVar8 = puVar8 + 1;
        }
        *puVar8 = (ushort)in_ECX[3];
        puVar8[1] = (ushort)in_ECX[4];
        uVar3 = 0;
        puVar14 = (ushort *)0x0;
        uVar15 = 0;
        if (in_ECX[10] != 0) {
          iVar13 = 0;
          do {
            puVar9 = puVar8 + 2;
            puVar10 = puVar9;
            if ((uVar3 & 0xf) == 0) {
              puVar10 = puVar8 + 3;
              *puVar9 = 0;
              uVar15 = 1;
              puVar14 = puVar9;
            }
            if ((char)((ushort *)(in_ECX[7] + iVar13))[8] == '\0') {
              *puVar10 = *(ushort *)(in_ECX[7] + iVar13);
              puVar10[1] = *(ushort *)(in_ECX[7] + 4 + iVar13);
              puVar10 = puVar10 + 2;
              *puVar14 = *puVar14 | uVar15;
            }
            *puVar10 = *(ushort *)(in_ECX[7] + 8 + iVar13);
            puVar10[1] = *(ushort *)(in_ECX[7] + 0xc + iVar13);
            uVar3 = uVar3 + 1;
            iVar13 = iVar13 + 0x14;
            uVar15 = uVar15 * 2;
            puVar8 = puVar10;
          } while (uVar3 < in_ECX[10]);
        }
      }
      else {
        puVar7 = (uint *)((uint)((int)puVar7 + iVar13 + iVar17 * 3 + -1) & ~(iVar13 - 1U));
        if (0xf < in_ECX[10]) {
          *puVar7 = in_ECX[10];
          puVar7 = puVar7 + 1;
        }
        *puVar7 = in_ECX[3];
        puVar7[1] = in_ECX[4];
        uVar16 = 0;
        puVar18 = (uint *)0x0;
        uVar3 = 0;
        if (in_ECX[10] != 0) {
          iVar13 = 0;
          do {
            puVar11 = puVar7 + 2;
            puVar12 = puVar11;
            if ((uVar16 & 0x1f) == 0) {
              puVar12 = puVar7 + 3;
              *puVar11 = 0;
              uVar3 = 1;
              puVar18 = puVar11;
            }
            if ((char)((uint *)(in_ECX[7] + iVar13))[4] == '\0') {
              *puVar12 = *(uint *)(in_ECX[7] + iVar13);
              puVar12[1] = *(uint *)(in_ECX[7] + 4 + iVar13);
              puVar12 = puVar12 + 2;
              *puVar18 = *puVar18 | uVar3;
            }
            *puVar12 = *(uint *)(in_ECX[7] + 8 + iVar13);
            puVar12[1] = *(uint *)(in_ECX[7] + 0xc + iVar13);
            uVar16 = uVar16 + 1;
            iVar13 = iVar13 + 0x14;
            uVar3 = uVar3 * 2;
            puVar7 = puVar12;
          } while (uVar16 < in_ECX[10]);
        }
      }
    }
  }
  else {
    local_4 = (byte *)FUN_00553570(1,1);
    *local_4 = 0;
  }
  if (param_2 != (int *)0x0) {
    if (*param_2 == 0) {
      sVar2 = *(short *)(param_1 + 4);
      *param_2 = (int)local_4;
      *(short *)(param_2 + 3) = (short)local_4 - sVar2;
    }
    if (*(char *)((int)in_ECX + 0x35) != '\0') {
      param_2[2] = param_2[2] + 1;
    }
    param_2[1] = param_2[1] + 1;
  }
  in_ECX[0xb] = 0;
  in_ECX[0xc] = 0;
  in_ECX[10] = 0;
  *(undefined1 *)((int)in_ECX + 0x35) = 0;
  return;
}



============================================================
DISASSEMBLY
============================================================
005551b0 : SUB ESP,0x8
005551b3 : PUSH EBX
005551b4 : PUSH EBP
005551b5 : PUSH ESI
005551b6 : MOV ESI,ECX
005551b8 : MOV EAX,dword ptr [ESI + 0x4]
005551bb : OR EAX,dword ptr [ESI]
005551bd : PUSH EDI
005551be : OR EAX,dword ptr [ESI + 0x8]
005551c1 : MOV EBP,0x4
005551c6 : CMP EAX,0x8000
005551cb : JNC 0x00555269
005551d1 : CMP EAX,0x80
005551d6 : JNC 0x00555218
005551d8 : CMP EAX,0x8
005551db : JNC 0x005551f9
005551dd : CMP EAX,0x2
005551e0 : JNC 0x005551ed
005551e2 : CMP EAX,0x1
005551e5 : SBB EAX,EAX
005551e7 : INC EAX
005551e8 : JMP 0x00555306
005551ed : CMP EAX,EBP
005551ef : SBB EAX,EAX
005551f1 : ADD EAX,0x3
005551f4 : JMP 0x00555306
005551f9 : CMP EAX,0x20
005551fc : JNC 0x0055520b
005551fe : CMP EAX,0x10
00555201 : SBB EAX,EAX
00555203 : ADD EAX,0x5
00555206 : JMP 0x00555306
0055520b : CMP EAX,0x40
0055520e : SBB EAX,EAX
00555210 : ADD EAX,0x7
00555213 : JMP 0x00555306
00555218 : CMP EAX,0x800
0055521d : JNC 0x00555244
0055521f : CMP EAX,0x200
00555224 : JNC 0x00555235
00555226 : CMP EAX,0x100
0055522b : SBB EAX,EAX
0055522d : ADD EAX,0x9
00555230 : JMP 0x00555306
00555235 : CMP EAX,0x400
0055523a : SBB EAX,EAX
0055523c : ADD EAX,0xb
0055523f : JMP 0x00555306
00555244 : CMP EAX,0x2000
00555249 : JNC 0x0055525a
0055524b : CMP EAX,0x1000
00555250 : SBB EAX,EAX
00555252 : ADD EAX,0xd
00555255 : JMP 0x00555306
0055525a : CMP EAX,0x4000
0055525f : SBB EAX,EAX
00555261 : ADD EAX,0xf
00555264 : JMP 0x00555306
00555269 : CMP EAX,0x800000
0055526e : JNC 0x005552b5
00555270 : CMP EAX,0x80000
00555275 : JNC 0x00555296
00555277 : CMP EAX,0x20000
0055527c : JNC 0x0055528a
0055527e : CMP EAX,0x10000
00555283 : SBB EAX,EAX
00555285 : ADD EAX,0x11
00555288 : JMP 0x00555306
0055528a : CMP EAX,0x40000
0055528f : SBB EAX,EAX
00555291 : ADD EAX,0x13
00555294 : JMP 0x00555306
00555296 : CMP EAX,0x200000
0055529b : JNC 0x005552a9
0055529d : CMP EAX,0x100000
005552a2 : SBB EAX,EAX
005552a4 : ADD EAX,0x15
005552a7 : JMP 0x00555306
005552a9 : CMP EAX,0x400000
005552ae : SBB EAX,EAX
005552b0 : ADD EAX,0x17
005552b3 : JMP 0x00555306
005552b5 : CMP EAX,0x8000000
005552ba : JNC 0x005552db
005552bc : CMP EAX,0x2000000
005552c1 : JNC 0x005552cf
005552c3 : CMP EAX,0x1000000
005552c8 : SBB EAX,EAX
005552ca : ADD EAX,0x19
005552cd : JMP 0x00555306
005552cf : CMP EAX,0x4000000
005552d4 : SBB EAX,EAX
005552d6 : ADD EAX,0x1b
005552d9 : JMP 0x00555306
005552db : CMP EAX,0x20000000
005552e0 : JNC 0x005552ee
005552e2 : CMP EAX,0x10000000
005552e7 : SBB EAX,EAX
005552e9 : ADD EAX,0x1d
005552ec : JMP 0x00555306
005552ee : CMP EAX,0x40000000
005552f3 : JNC 0x005552fc
005552f5 : MOV EAX,0x1e
005552fa : JMP 0x00555306
005552fc : CMP EAX,0x80000000
00555301 : SBB EAX,EAX
00555303 : ADD EAX,0x20
00555306 : CMP byte ptr [ESI + 0x35],0x0
0055530a : MOVZX EAX,AL
0055530d : JZ 0x00555328
0055530f : MOV ECX,dword ptr [ESP + 0x1c]
00555313 : PUSH 0x1
00555315 : PUSH 0x1
00555317 : CALL 0x00553570
0055531c : MOV dword ptr [ESP + 0x14],EAX
00555320 : MOV byte ptr [EAX],0x0
00555323 : JMP 0x0055564a
00555328 : CMP EAX,0x8
0055532b : JA 0x00555432
00555331 : CMP byte ptr [ESI + 0x34],0x10
00555335 : JA 0x00555432
0055533b : CMP dword ptr [ESI + 0x28],EBP
0055533e : JA 0x00555432
00555344 : MOV BL,byte ptr [ESI + 0x28]
00555347 : MOV EAX,dword ptr [ESI + 0x2c]
0055534a : MOV ECX,dword ptr [ESI + 0x30]
0055534d : DEC BL
0055534f : PUSH 0x2
00555351 : LEA EDX,[ECX + EAX*0x2]
00555354 : MOV ECX,dword ptr [ESP + 0x20]
00555358 : AND BL,0x3
0055535b : PUSH 0x1
0055535d : LEA EAX,[EDX*0x4 + 0x4]
00555364 : ADD BL,BL
00555366 : PUSH EAX
00555367 : OR BL,0x1
0055536a : MOV byte ptr [ESP + 0x1e],0x0
0055536f : CALL 0x005550f0
00555374 : MOV CL,byte ptr [ESI]
00555376 : MOV EBP,EAX
00555378 : MOV byte ptr [EBP + 0x1],CL
0055537b : MOV DL,byte ptr [ESI + 0x4]
0055537e : MOV byte ptr [EBP + 0x2],DL
00555381 : MOV AL,byte ptr [ESI + 0x8]
00555384 : MOV byte ptr [EBP + 0x3],AL
00555387 : MOV DX,word ptr [ESI + 0xc]
0055538b : LEA ECX,[EBP + 0x5]
0055538e : AND ECX,0xfffffffe
00555391 : MOV word ptr [ECX],DX
00555394 : MOV AX,word ptr [ESI + 0x10]
00555398 : ADD ECX,0x2
0055539b : MOV word ptr [ECX],AX
0055539e : ADD ECX,0x2
005553a1 : CMP dword ptr [ESI + 0x28],0x0
005553a5 : MOV dword ptr [ESP + 0x14],EBP
005553a9 : MOV byte ptr [ESP + 0x11],0x1
005553ae : MOV byte ptr [ESP + 0x13],0x0
005553b3 : JBE 0x0055541c
005553b5 : XOR EDI,EDI
005553b7 : MOV EDX,dword ptr [ESI + 0x1c]
005553ba : LEA EDI,[EDI + EDI*0x4]
005553bd : ADD EDI,EDI
005553bf : ADD EDI,EDI
005553c1 : CMP byte ptr [EDX + EDI*0x1 + 0x10],0x0
005553c6 : LEA EAX,[EDX + EDI*0x1]
005553c9 : JNZ 0x005553ea
005553cb : MOVZX EAX,word ptr [EAX]
005553ce : MOV word ptr [ECX],AX
005553d1 : MOV EDX,dword ptr [ESI + 0x1c]
005553d4 : MOVZX EAX,word ptr [EDX + EDI*0x1 + 0x4]
005553d9 : MOV DL,byte ptr [ESP + 0x11]
005553dd : ADD ECX,0x2
005553e0 : MOV word ptr [ECX],AX
005553e3 : ADD ECX,0x2
005553e6 : OR byte ptr [ESP + 0x12],DL
005553ea : MOV EAX,dword ptr [ESI + 0x1c]
005553ed : MOVZX EDX,word ptr [EAX + EDI*0x1 + 0x8]
005553f2 : SHL byte ptr [ESP + 0x11],0x1
005553f6 : MOV word ptr [ECX],DX
005553f9 : MOV EAX,dword ptr [ESI + 0x1c]
005553fc : MOVZX EDX,word ptr [EAX + EDI*0x1 + 0xc]
00555401 : MOV AL,byte ptr [ESP + 0x13]
00555405 : INC AL
00555407 : ADD ECX,0x2
0055540a : MOVZX EDI,AL
0055540d : MOV word ptr [ECX],DX
00555410 : ADD ECX,0x2
00555413 : MOV byte ptr [ESP + 0x13],AL
00555417 : CMP EDI,dword ptr [ESI + 0x28]
0055541a : JC 0x005553b7
0055541c : MOV AL,byte ptr [ESP + 0x12]
00555420 : AND AL,0xf
00555422 : ADD AL,AL
00555424 : ADD AL,AL
00555426 : ADD AL,AL
00555428 : OR AL,BL
0055542a : MOV byte ptr [EBP],AL
0055542d : JMP 0x0055564a
00555432 : MOV EDI,0x1
00555437 : CMP EAX,0x8
0055543a : JA 0x00555440
0055543c : MOV BL,0x2
0055543e : JMP 0x00555452
00555440 : CMP EAX,0x10
00555443 : JA 0x0055544e
00555445 : MOV BL,0x4
00555447 : MOV EDI,0x2
0055544c : JMP 0x00555452
0055544e : MOV BL,0x6
00555450 : MOV EDI,EBP
00555452 : XOR ECX,ECX
00555454 : CMP byte ptr [ESI + 0x34],0x10
00555458 : JA 0x00555468
0055545a : CMP dword ptr [ESI + 0x28],0xffff
00555461 : JA 0x00555468
00555463 : LEA EBP,[ECX + 0x2]
00555466 : JMP 0x0055546b
00555468 : OR BL,0x8
0055546b : MOV EAX,dword ptr [ESI + 0x28]
0055546e : CMP EAX,0x10
00555471 : JNC 0x0055547c
00555473 : MOV DL,AL
00555475 : SHL DL,0x4
00555478 : OR BL,DL
0055547a : JMP 0x0055547e
0055547c : MOV ECX,EBP
0055547e : CMP byte ptr [ESI + 0x34],0x10
00555482 : JA 0x0055548f
00555484 : ADD EAX,0xf
00555487 : SHR EAX,0x4
0055548a : LEA EAX,[ECX + EAX*0x2]
0055548d : JMP 0x00555498
0055548f : ADD EAX,0x1f
00555492 : SHR EAX,0x5
00555495 : LEA EAX,[ECX + EAX*0x4]
00555498 : MOV EDX,dword ptr [ESI + 0x30]
0055549b : MOV ECX,dword ptr [ESI + 0x2c]
0055549e : LEA ECX,[EDX + ECX*0x2 + 0x1]
005554a2 : IMUL ECX,EBP
005554a5 : PUSH EBP
005554a6 : LEA EDX,[EAX + ECX*0x2]
005554a9 : MOV ECX,dword ptr [ESP + 0x20]
005554ad : PUSH EDI
005554ae : PUSH EDX
005554af : CALL 0x005550f0
005554b4 : LEA ECX,[EDI + EAX*0x1]
005554b7 : MOV dword ptr [ESP + 0x14],EAX
005554bb : MOV byte ptr [EAX],BL
005554bd : LEA EAX,[EDI + -0x1]
005554c0 : NOT EAX
005554c2 : AND ECX,EAX
005554c4 : MOV EAX,EDI
005554c6 : SUB EAX,0x1
005554c9 : JZ 0x005554ff
005554cb : SUB EAX,0x1
005554ce : JZ 0x005554e7
005554d0 : SUB EAX,0x2
005554d3 : JNZ 0x00555511
005554d5 : MOV EDX,dword ptr [ESI]
005554d7 : MOV dword ptr [ECX],EDX
005554d9 : MOV EAX,dword ptr [ESI + 0x4]
005554dc : MOV dword ptr [ECX + 0x4],EAX
005554df : MOV EDX,dword ptr [ESI + 0x8]
005554e2 : MOV dword ptr [ECX + 0x8],EDX
005554e5 : JMP 0x00555511
005554e7 : MOVZX EAX,word ptr [ESI]
005554ea : MOV word ptr [ECX],AX
005554ed : MOV DX,word ptr [ESI + 0x4]
005554f1 : MOV word ptr [ECX + 0x2],DX
005554f5 : MOVZX EAX,word ptr [ESI + 0x8]
005554f9 : MOV word ptr [ECX + 0x4],AX
005554fd : JMP 0x00555511
005554ff : MOVZX EDX,byte ptr [ESI]
00555502 : MOV byte ptr [ECX],DL
00555504 : MOV AL,byte ptr [ESI + 0x4]
00555507 : MOV byte ptr [ECX + 0x1],AL
0055550a : MOVZX EDX,byte ptr [ESI + 0x8]
0055550e : MOV byte ptr [ECX + 0x2],DL
00555511 : LEA EDI,[EDI + EDI*0x2]
00555514 : CMP EBP,0x2
00555517 : JNZ 0x005555bd
0055551d : LEA ECX,[EDI + ECX*0x1 + 0x1]
00555521 : AND ECX,0xfffffffe
00555524 : CMP dword ptr [ESI + 0x28],0x10
00555528 : JC 0x00555533
0055552a : MOV AX,word ptr [ESI + 0x28]
0055552e : MOV word ptr [ECX],AX
00555531 : ADD ECX,EBP
00555533 : MOV DX,word ptr [ESI + 0xc]
00555537 : MOV word ptr [ECX],DX
0055553a : MOV AX,word ptr [ESI + 0x10]
0055553e : ADD ECX,0x2
00555541 : MOV word ptr [ECX],AX
00555544 : XOR EBX,EBX
00555546 : ADD ECX,0x2
00555549 : XOR EBP,EBP
0055554b : XOR EDI,EDI
0055554d : CMP dword ptr [ESI + 0x28],EBX
00555550 : JBE 0x0055564a
00555556 : XOR EDX,EDX
00555558 : TEST BL,0xf
0055555b : JNZ 0x0055556b
0055555d : MOV EBP,ECX
0055555f : ADD ECX,0x2
00555562 : XOR EAX,EAX
00555564 : MOV word ptr [EBP],AX
00555568 : LEA EDI,[EAX + 0x1]
0055556b : MOV EAX,dword ptr [ESI + 0x1c]
0055556e : ADD EAX,EDX
00555570 : CMP byte ptr [EAX + 0x10],0x0
00555574 : JNZ 0x00555591
00555576 : MOVZX EAX,word ptr [EAX]
00555579 : MOV word ptr [ECX],AX
0055557c : MOV EAX,dword ptr [ESI + 0x1c]
0055557f : MOVZX EAX,word ptr [EAX + EDX*0x1 + 0x4]
00555584 : ADD ECX,0x2
00555587 : MOV word ptr [ECX],AX
0055558a : ADD ECX,0x2
0055558d : OR word ptr [EBP],DI
00555591 : MOV EAX,dword ptr [ESI + 0x1c]
00555594 : MOVZX EAX,word ptr [EAX + EDX*0x1 + 0x8]
00555599 : MOV word ptr [ECX],AX
0055559c : MOV EAX,dword ptr [ESI + 0x1c]
0055559f : MOVZX EAX,word ptr [EAX + EDX*0x1 + 0xc]
005555a4 : ADD ECX,0x2
005555a7 : MOV word ptr [ECX],AX
005555aa : INC EBX
005555ab : ADD ECX,0x2
005555ae : ADD EDX,0x14
005555b1 : ADD EDI,EDI
005555b3 : CMP EBX,dword ptr [ESI + 0x28]
005555b6 : JC 0x00555558
005555b8 : JMP 0x0055564a
005555bd : MOV EAX,dword ptr [ESI + 0x28]
005555c0 : ADD EDI,ECX
005555c2 : LEA ECX,[EDI + EBP*0x1 + -0x1]
005555c6 : DEC EBP
005555c7 : NOT EBP
005555c9 : AND ECX,EBP
005555cb : CMP EAX,0x10
005555ce : JC 0x005555d5
005555d0 : MOV dword ptr [ECX],EAX
005555d2 : ADD ECX,0x4
005555d5 : MOV EDX,dword ptr [ESI + 0xc]
005555d8 : MOV dword ptr [ECX],EDX
005555da : MOV EAX,dword ptr [ESI + 0x10]
005555dd : ADD ECX,0x4
005555e0 : MOV dword ptr [ECX],EAX
005555e2 : XOR EBX,EBX
005555e4 : ADD ECX,0x4
005555e7 : XOR EDI,EDI
005555e9 : XOR EBP,EBP
005555eb : CMP dword ptr [ESI + 0x28],EBX
005555ee : JBE 0x0055564a
005555f0 : XOR EDX,EDX
005555f2 : TEST BL,0x1f
005555f5 : JNZ 0x00555607
005555f7 : MOV EDI,ECX
005555f9 : ADD ECX,0x4
005555fc : MOV dword ptr [EDI],0x0
00555602 : MOV EBP,0x1
00555607 : MOV EAX,dword ptr [ESI + 0x1c]
0055560a : ADD EAX,EDX
0055560c : CMP byte ptr [EAX + 0x10],0x0
00555610 : JNZ 0x00555627
00555612 : MOV EAX,dword ptr [EAX]
00555614 : MOV dword ptr [ECX],EAX
00555616 : MOV EAX,dword ptr [ESI + 0x1c]
00555619 : MOV EAX,dword ptr [EAX + EDX*0x1 + 0x4]
0055561d : ADD ECX,0x4
00555620 : MOV dword ptr [ECX],EAX
00555622 : ADD ECX,0x4
00555625 : OR dword ptr [EDI],EBP
00555627 : MOV EAX,dword ptr [ESI + 0x1c]
0055562a : MOV EAX,dword ptr [EAX + EDX*0x1 + 0x8]
0055562e : MOV dword ptr [ECX],EAX
00555630 : MOV EAX,dword ptr [ESI + 0x1c]
00555633 : MOV EAX,dword ptr [EAX + EDX*0x1 + 0xc]
00555637 : ADD ECX,0x4
0055563a : MOV dword ptr [ECX],EAX
0055563c : INC EBX
0055563d : ADD ECX,0x4
00555640 : ADD EDX,0x14
00555643 : ADD EBP,EBP
00555645 : CMP EBX,dword ptr [ESI + 0x28]
00555648 : JC 0x005555f2
0055564a : MOV EAX,dword ptr [ESP + 0x20]
0055564e : XOR EDX,EDX
00555650 : CMP EAX,EDX
00555652 : JZ 0x00555679
00555654 : CMP dword ptr [EAX],EDX
00555656 : JNZ 0x0055566d
00555658 : MOV ECX,dword ptr [ESP + 0x14]
0055565c : MOV EBX,dword ptr [ESP + 0x1c]
00555660 : MOV DI,CX
00555663 : SUB DI,word ptr [EBX + 0x4]
00555667 : MOV dword ptr [EAX],ECX
00555669 : MOV word ptr [EAX + 0xc],DI
0055566d : CMP byte ptr [ESI + 0x35],0x0
00555671 : JZ 0x00555676
00555673 : INC dword ptr [EAX + 0x8]
00555676 : INC dword ptr [EAX + 0x4]
00555679 : POP EDI
0055567a : MOV dword ptr [ESI + 0x2c],EDX
0055567d : MOV dword ptr [ESI + 0x30],EDX
00555680 : MOV dword ptr [ESI + 0x28],EDX
00555683 : MOV byte ptr [ESI + 0x35],0x0
00555687 : POP ESI
00555688 : POP EBP
00555689 : POP EBX
0055568a : ADD ESP,0x8
0055568d : RET 0x8
