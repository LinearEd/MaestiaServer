PROGRAM  : Maestia.exe
FUNCTION : FUN_0054fbe0
ENTRY    : 0054fbe0
BODY     : [[0054fbe0, 0054fc1c] [0054fc20, 0054fd24]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0054fbe0(undefined4 param_1,int *param_2,uint param_3)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int *in_ECX;
  int *piVar7;
  int *piVar8;
  int *local_1c;
  int *local_18;
  undefined1 auStack_10 [12];
  undefined4 uStack_4;
  
  piVar8 = in_ECX + 2;
  iVar3 = *piVar8;
  local_1c = in_ECX;
  if (iVar3 == 0) {
    uVar6 = 0;
    piVar8 = (int *)0x0;
    local_18 = piVar8;
  }
  else {
    uVar6 = 0;
    piVar7 = (int *)(iVar3 + 8);
    do {
      local_18 = piVar8;
      if (*piVar7 != -2) break;
      uVar6 = uVar6 + 1;
      piVar7 = piVar7 + 6;
    } while (uVar6 <= *(uint *)(iVar3 + 4));
  }
  do {
    do {
      if (((piVar8 == (int *)0x0) || (iVar3 = *piVar8, iVar3 == 0)) ||
         (*(int *)(iVar3 + 4) < (int)uVar6)) {
        if (((param_3 & 1) != 0) && (local_1c[1] != 0)) {
          (**(code **)(*(int *)(local_1c[1] + 0x10) + 0x20))(param_1,param_2,param_3);
        }
        return;
      }
      iVar5 = uVar6 * 0x18;
      bVar2 = *(byte *)(iVar5 + 0x11 + iVar3);
      if (((bVar2 & 1) == 0) || ((param_3 & 4) != 0)) {
        iVar1 = iVar5 + 0xc + iVar3;
        if (*(char *)(iVar5 + 0x10 + iVar3) == '\n') {
          auStack_10[0] = 0;
          (**(code **)(*local_1c + 0x2c))(param_1,iVar1,auStack_10);
          (**(code **)(*param_2 + 4))(*piVar8 + 0xc + iVar5,&local_1c,uStack_4);
          FUN_00526bc0();
        }
        else {
          (**(code **)(*param_2 + 4))(iVar1,iVar5 + 0x10 + iVar3,bVar2);
          piVar8 = local_18;
        }
      }
      uVar4 = *(uint *)(*piVar8 + 4);
    } while (((int)uVar4 < (int)uVar6) || (uVar6 = uVar6 + 1, uVar4 < uVar6));
    piVar7 = (int *)(*piVar8 + 8 + uVar6 * 0x18);
    do {
      if (*piVar7 != -2) break;
      uVar6 = uVar6 + 1;
      piVar7 = piVar7 + 6;
    } while (uVar6 <= uVar4);
  } while( true );
}



============================================================
DISASSEMBLY
============================================================
0054fbe0 : SUB ESP,0x1c
0054fbe3 : PUSH EBX
0054fbe4 : PUSH EBP
0054fbe5 : PUSH ESI
0054fbe6 : LEA ESI,[ECX + 0x8]
0054fbe9 : MOV dword ptr [ESP + 0xc],ECX
0054fbed : MOV ECX,dword ptr [ESI]
0054fbef : PUSH EDI
0054fbf0 : TEST ECX,ECX
0054fbf2 : JNZ 0x0054fbf8
0054fbf4 : XOR EAX,EAX
0054fbf6 : JMP 0x0054fc0f
0054fbf8 : MOV EDX,dword ptr [ECX + 0x4]
0054fbfb : XOR EAX,EAX
0054fbfd : ADD ECX,0x8
0054fc00 : CMP dword ptr [ECX],-0x2
0054fc03 : JNZ 0x0054fc0d
0054fc05 : INC EAX
0054fc06 : ADD ECX,0x18
0054fc09 : CMP EAX,EDX
0054fc0b : JBE 0x0054fc00
0054fc0d : MOV ECX,ESI
0054fc0f : MOV EBP,dword ptr [ESP + 0x34]
0054fc13 : MOV EBX,ECX
0054fc15 : MOV dword ptr [ESP + 0x14],EBX
0054fc19 : MOV EDI,EAX
0054fc1b : JMP 0x0054fc20
0054fc20 : TEST EBX,EBX
0054fc22 : JZ 0x0054fcf6
0054fc28 : MOV EAX,dword ptr [EBX]
0054fc2a : TEST EAX,EAX
0054fc2c : JZ 0x0054fcf6
0054fc32 : CMP EDI,dword ptr [EAX + 0x4]
0054fc35 : JG 0x0054fcf6
0054fc3b : LEA ESI,[EDI + EDI*0x2]
0054fc3e : ADD ESI,ESI
0054fc40 : ADD ESI,ESI
0054fc42 : ADD ESI,ESI
0054fc44 : MOV CL,byte ptr [ESI + EAX*0x1 + 0x11]
0054fc48 : MOV byte ptr [ESP + 0x34],CL
0054fc4c : TEST CL,0x1
0054fc4f : JZ 0x0054fc58
0054fc51 : TEST byte ptr [ESP + 0x38],0x4
0054fc56 : JZ 0x0054fcc1
0054fc58 : CMP byte ptr [ESI + EAX*0x1 + 0x10],0xa
0054fc5d : LEA ECX,[ESI + EAX*0x1 + 0x10]
0054fc61 : LEA EAX,[ESI + EAX*0x1 + 0xc]
0054fc65 : JZ 0x0054fc7e
0054fc67 : MOV EBX,dword ptr [ESP + 0x34]
0054fc6b : MOV EDX,dword ptr [EBP]
0054fc6e : MOV EDX,dword ptr [EDX + 0x4]
0054fc71 : PUSH EBX
0054fc72 : PUSH ECX
0054fc73 : PUSH EAX
0054fc74 : MOV ECX,EBP
0054fc76 : CALL EDX
0054fc78 : MOV EBX,dword ptr [ESP + 0x14]
0054fc7c : JMP 0x0054fcc1
0054fc7e : MOV ECX,dword ptr [ESP + 0x10]
0054fc82 : MOV EDX,dword ptr [ECX]
0054fc84 : MOV EDX,dword ptr [EDX + 0x2c]
0054fc87 : LEA ECX,[ESP + 0x1c]
0054fc8b : PUSH ECX
0054fc8c : MOV ECX,dword ptr [ESP + 0x34]
0054fc90 : PUSH EAX
0054fc91 : PUSH ECX
0054fc92 : MOV ECX,dword ptr [ESP + 0x1c]
0054fc96 : MOV byte ptr [ESP + 0x28],0x0
0054fc9b : CALL EDX
0054fc9d : MOV ECX,dword ptr [ESP + 0x34]
0054fca1 : MOV EAX,dword ptr [EBP]
0054fca4 : MOV EAX,dword ptr [EAX + 0x4]
0054fca7 : PUSH ECX
0054fca8 : MOV ECX,dword ptr [EBX]
0054fcaa : LEA EDX,[ESP + 0x20]
0054fcae : PUSH EDX
0054fcaf : LEA EDX,[ECX + ESI*0x1 + 0xc]
0054fcb3 : PUSH EDX
0054fcb4 : MOV ECX,EBP
0054fcb6 : CALL EAX
0054fcb8 : LEA ECX,[ESP + 0x1c]
0054fcbc : CALL 0x00526bc0
0054fcc1 : MOV ECX,dword ptr [EBX]
0054fcc3 : MOV EAX,dword ptr [ECX + 0x4]
0054fcc6 : CMP EDI,EAX
0054fcc8 : JG 0x0054fc20
0054fcce : INC EDI
0054fccf : CMP EDI,EAX
0054fcd1 : JA 0x0054fc20
0054fcd7 : LEA EDX,[EDI + EDI*0x2]
0054fcda : LEA ECX,[ECX + EDX*0x8 + 0x8]
0054fcde : MOV EDI,EDI
0054fce0 : CMP dword ptr [ECX],-0x2
0054fce3 : JNZ 0x0054fc20
0054fce9 : INC EDI
0054fcea : ADD ECX,0x18
0054fced : CMP EDI,EAX
0054fcef : JBE 0x0054fce0
0054fcf1 : JMP 0x0054fc20
0054fcf6 : MOV EDX,dword ptr [ESP + 0x38]
0054fcfa : TEST DL,0x1
0054fcfd : JZ 0x0054fd1b
0054fcff : MOV EAX,dword ptr [ESP + 0x10]
0054fd03 : MOV EAX,dword ptr [EAX + 0x4]
0054fd06 : TEST EAX,EAX
0054fd08 : JZ 0x0054fd1b
0054fd0a : LEA ECX,[EAX + 0x10]
0054fd0d : MOV EAX,dword ptr [ECX]
0054fd0f : MOV EAX,dword ptr [EAX + 0x20]
0054fd12 : PUSH EDX
0054fd13 : MOV EDX,dword ptr [ESP + 0x34]
0054fd17 : PUSH EBP
0054fd18 : PUSH EDX
0054fd19 : CALL EAX
0054fd1b : POP EDI
0054fd1c : POP ESI
0054fd1d : POP EBP
0054fd1e : POP EBX
0054fd1f : ADD ESP,0x1c
0054fd22 : RET 0xc
