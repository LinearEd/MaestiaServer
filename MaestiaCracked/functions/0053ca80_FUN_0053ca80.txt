PROGRAM  : Maestia.exe
FUNCTION : FUN_0053ca80
ENTRY    : 0053ca80
BODY     : [[0053ca80, 0053cc9e]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0053ca80(undefined4 *param_1,uint *param_2)

{
  uint *puVar1;
  void *pvVar2;
  ushort *puVar3;
  bool bVar4;
  uint uVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  int iVar9;
  int in_ECX;
  uint uVar10;
  
  puVar1 = (uint *)(in_ECX + 8);
  *param_1 = *(undefined4 *)(in_ECX + 8);
  *param_2 = 0;
  bVar4 = false;
  if (*puVar1 < *(uint *)(in_ECX + 0x10)) {
    do {
      uVar5 = *(uint *)(in_ECX + 0x14);
      if ((((uVar5 == 0x3d) || (uVar5 == 0x3e)) || (uVar5 == 0x3c)) || (uVar5 == 0x2f)) break;
      uVar5 = uVar5 & 0xffff;
      uVar10 = (uint)*(ushort *)(&DAT_00b88408 + (uVar5 >> 8) * 2);
      if ((uVar10 != 0) &&
         ((uVar10 == 1 ||
          ((1 << ((byte)uVar5 & 0xf) &
           (uint)*(ushort *)(&DAT_00b88408 + ((uVar5 >> 4 & 0xf) + uVar10) * 2)) != 0)))) break;
      if ((*(char *)(in_ECX + 0x18) == '\0') || (*(short *)*puVar1 != 0x26)) {
        if (bVar4) {
          pvVar2 = (void *)*puVar1;
          iVar6 = *(int *)(in_ECX + 0xc) - (int)pvVar2 >> 1;
          if (*(uint *)(in_ECX + 0x20) < (uint)(*(int *)(in_ECX + 0x24) + iVar6)) {
            iVar9 = *(uint *)(in_ECX + 0x20) + iVar6;
            *(int *)(in_ECX + 0x20) = iVar9;
            iVar9 = iVar9 * 2;
            if (*(int *)(in_ECX + 0x1c) == 0) {
              uVar7 = FUN_00515840(iVar9,0);
            }
            else {
              uVar7 = FUN_00515c80(*(int *)(in_ECX + 0x1c),iVar9);
            }
            *(undefined4 *)(in_ECX + 0x1c) = uVar7;
          }
          _memcpy((void *)(*(int *)(in_ECX + 0x1c) + *(int *)(in_ECX + 0x24) * 2),pvVar2,iVar6 * 2);
          *(int *)(in_ECX + 0x24) = *(int *)(in_ECX + 0x24) + iVar6;
        }
        else {
          *param_2 = *param_2 + ((int)(*(int *)(in_ECX + 0xc) - *puVar1) >> 1);
        }
      }
      else {
        if (!bVar4) {
          *(undefined4 *)(in_ECX + 0x24) = 0;
          uVar5 = *param_2;
          pvVar2 = (void *)*param_1;
          if (*(uint *)(in_ECX + 0x20) < uVar5) {
            iVar6 = *(uint *)(in_ECX + 0x20) + uVar5;
            *(int *)(in_ECX + 0x20) = iVar6;
            iVar6 = iVar6 * 2;
            if (*(int *)(in_ECX + 0x1c) == 0) {
              uVar7 = FUN_00515840(iVar6,0);
            }
            else {
              uVar7 = FUN_00515c80(*(int *)(in_ECX + 0x1c),iVar6);
            }
            *(undefined4 *)(in_ECX + 0x1c) = uVar7;
          }
          _memcpy((void *)(*(int *)(in_ECX + 0x1c) + *(int *)(in_ECX + 0x24) * 2),pvVar2,uVar5 * 2);
          *(int *)(in_ECX + 0x24) = *(int *)(in_ECX + 0x24) + uVar5;
          bVar4 = true;
        }
        uVar7 = *(undefined4 *)(in_ECX + 0x14);
        if (*(uint *)(in_ECX + 0x20) < *(int *)(in_ECX + 0x24) + 6U) {
          iVar6 = *(uint *)(in_ECX + 0x20) + 6;
          *(int *)(in_ECX + 0x20) = iVar6;
          iVar6 = iVar6 * 2;
          if (*(int *)(in_ECX + 0x1c) == 0) {
            uVar8 = FUN_00515840(iVar6,0);
          }
          else {
            uVar8 = FUN_00515c80(*(int *)(in_ECX + 0x1c),iVar6);
          }
          *(undefined4 *)(in_ECX + 0x1c) = uVar8;
        }
        *(short *)(*(int *)(in_ECX + 0x1c) + *(int *)(in_ECX + 0x24) * 2) = (short)uVar7;
        *(int *)(in_ECX + 0x24) = *(int *)(in_ECX + 0x24) + 1;
      }
      puVar3 = *(ushort **)(in_ECX + 0xc);
      *puVar1 = (uint)puVar3;
      if ((*(char *)(in_ECX + 0x18) == '\0') || (*puVar3 != 0x26)) {
        if (puVar3 < *(ushort **)(in_ECX + 0x10)) {
          *(uint *)(in_ECX + 0x14) = (uint)*puVar3;
          *(ushort **)(in_ECX + 0xc) = puVar3 + 1;
        }
      }
      else {
        FUN_0053bdd0();
      }
    } while (*puVar1 < *(uint *)(in_ECX + 0x10));
    if (bVar4) {
      *param_1 = *(undefined4 *)(in_ECX + 0x1c);
      *param_2 = *(uint *)(in_ECX + 0x24);
    }
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
0053ca80 : SUB ESP,0x8
0053ca83 : PUSH EBX
0053ca84 : MOV EBX,dword ptr [ESP + 0x14]
0053ca88 : PUSH EBP
0053ca89 : PUSH ESI
0053ca8a : MOV ESI,ECX
0053ca8c : MOV EAX,dword ptr [ESI + 0x8]
0053ca8f : MOV ECX,dword ptr [ESP + 0x18]
0053ca93 : LEA EBP,[ESI + 0x8]
0053ca96 : MOV dword ptr [ECX],EAX
0053ca98 : MOV dword ptr [EBX],0x0
0053ca9e : MOV EDX,dword ptr [EBP]
0053caa1 : MOV byte ptr [ESP + 0xf],0x0
0053caa6 : CMP EDX,dword ptr [EBP + 0x8]
0053caa9 : JNC 0x0053cc96
0053caaf : PUSH EDI
0053cab0 : MOV EAX,dword ptr [ESI + 0x14]
0053cab3 : CMP EAX,0x3d
0053cab6 : JZ 0x0053cc80
0053cabc : CMP EAX,0x3e
0053cabf : JZ 0x0053cc80
0053cac5 : CMP EAX,0x3c
0053cac8 : JZ 0x0053cc80
0053cace : CMP EAX,0x2f
0053cad1 : JZ 0x0053cc80
0053cad7 : MOVZX EAX,AX
0053cada : MOV ECX,EAX
0053cadc : SHR ECX,0x8
0053cadf : MOVZX EDX,word ptr [ECX*0x2 + 0xb88408]
0053cae7 : TEST EDX,EDX
0053cae9 : JZ 0x0053cb1e
0053caeb : CMP EDX,0x1
0053caee : JZ 0x0053cc80
0053caf4 : MOV ECX,EAX
0053caf6 : SHR EAX,0x4
0053caf9 : AND EAX,0xf
0053cafc : AND ECX,0xf
0053caff : ADD EAX,EDX
0053cb01 : MOVZX EDX,word ptr [EAX*0x2 + 0xb88408]
0053cb09 : MOV EDI,0x1
0053cb0e : SHL EDI,CL
0053cb10 : AND EDI,EDX
0053cb12 : NEG EDI
0053cb14 : SBB EDI,EDI
0053cb16 : NEG EDI
0053cb18 : JNZ 0x0053cc80
0053cb1e : CMP byte ptr [EBP + 0x10],0x0
0053cb22 : JZ 0x0053cbdd
0053cb28 : MOV EAX,dword ptr [EBP]
0053cb2b : CMP word ptr [EAX],0x26
0053cb2f : JNZ 0x0053cbdd
0053cb35 : CMP byte ptr [ESP + 0x13],0x0
0053cb3a : JNZ 0x0053cb99
0053cb3c : MOV EAX,dword ptr [ESI + 0x20]
0053cb3f : MOV ECX,dword ptr [ESP + 0x1c]
0053cb43 : MOV dword ptr [ESI + 0x24],0x0
0053cb4a : MOV EDI,dword ptr [EBX]
0053cb4c : MOV EBX,dword ptr [ECX]
0053cb4e : CMP EDI,EAX
0053cb50 : JBE 0x0053cb76
0053cb52 : MOV ECX,dword ptr [ESI + 0x1c]
0053cb55 : ADD EAX,EDI
0053cb57 : MOV dword ptr [ESI + 0x20],EAX
0053cb5a : ADD EAX,EAX
0053cb5c : TEST ECX,ECX
0053cb5e : JNZ 0x0053cb6c
0053cb60 : MOV ECX,dword ptr [ESI]
0053cb62 : PUSH 0x0
0053cb64 : PUSH EAX
0053cb65 : CALL 0x00515840
0053cb6a : JMP 0x0053cb73
0053cb6c : PUSH EAX
0053cb6d : PUSH ECX
0053cb6e : CALL 0x00515c80
0053cb73 : MOV dword ptr [ESI + 0x1c],EAX
0053cb76 : MOV EAX,dword ptr [ESI + 0x24]
0053cb79 : MOV ECX,dword ptr [ESI + 0x1c]
0053cb7c : LEA EDX,[EDI + EDI*0x1]
0053cb7f : PUSH EDX
0053cb80 : LEA EDX,[ECX + EAX*0x2]
0053cb83 : PUSH EBX
0053cb84 : PUSH EDX
0053cb85 : CALL 0x0063ae40
0053cb8a : MOV EBX,dword ptr [ESP + 0x2c]
0053cb8e : ADD ESP,0xc
0053cb91 : ADD dword ptr [ESI + 0x24],EDI
0053cb94 : MOV byte ptr [ESP + 0x13],0x1
0053cb99 : MOV ECX,dword ptr [ESI + 0x24]
0053cb9c : MOV EAX,dword ptr [ESI + 0x20]
0053cb9f : MOV EDI,dword ptr [ESI + 0x14]
0053cba2 : ADD ECX,0x6
0053cba5 : CMP ECX,EAX
0053cba7 : JBE 0x0053cbce
0053cba9 : MOV ECX,dword ptr [ESI + 0x1c]
0053cbac : ADD EAX,0x6
0053cbaf : MOV dword ptr [ESI + 0x20],EAX
0053cbb2 : ADD EAX,EAX
0053cbb4 : TEST ECX,ECX
0053cbb6 : JNZ 0x0053cbc4
0053cbb8 : MOV ECX,dword ptr [ESI]
0053cbba : PUSH 0x0
0053cbbc : PUSH EAX
0053cbbd : CALL 0x00515840
0053cbc2 : JMP 0x0053cbcb
0053cbc4 : PUSH EAX
0053cbc5 : PUSH ECX
0053cbc6 : CALL 0x00515c80
0053cbcb : MOV dword ptr [ESI + 0x1c],EAX
0053cbce : MOV EDX,dword ptr [ESI + 0x24]
0053cbd1 : MOV EAX,dword ptr [ESI + 0x1c]
0053cbd4 : MOV word ptr [EAX + EDX*0x2],DI
0053cbd8 : INC dword ptr [ESI + 0x24]
0053cbdb : JMP 0x0053cc48
0053cbdd : CMP byte ptr [ESP + 0x13],0x0
0053cbe2 : JZ 0x0053cc3e
0053cbe4 : MOV EBX,dword ptr [EBP]
0053cbe7 : MOV EDI,dword ptr [EBP + 0x4]
0053cbea : MOV ECX,dword ptr [ESI + 0x24]
0053cbed : MOV EAX,dword ptr [ESI + 0x20]
0053cbf0 : SUB EDI,EBX
0053cbf2 : SAR EDI,0x1
0053cbf4 : ADD ECX,EDI
0053cbf6 : CMP ECX,EAX
0053cbf8 : JBE 0x0053cc1e
0053cbfa : MOV ECX,dword ptr [ESI + 0x1c]
0053cbfd : ADD EAX,EDI
0053cbff : MOV dword ptr [ESI + 0x20],EAX
0053cc02 : ADD EAX,EAX
0053cc04 : TEST ECX,ECX
0053cc06 : JNZ 0x0053cc14
0053cc08 : MOV ECX,dword ptr [ESI]
0053cc0a : PUSH 0x0
0053cc0c : PUSH EAX
0053cc0d : CALL 0x00515840
0053cc12 : JMP 0x0053cc1b
0053cc14 : PUSH EAX
0053cc15 : PUSH ECX
0053cc16 : CALL 0x00515c80
0053cc1b : MOV dword ptr [ESI + 0x1c],EAX
0053cc1e : MOV EAX,dword ptr [ESI + 0x24]
0053cc21 : MOV ECX,dword ptr [ESI + 0x1c]
0053cc24 : LEA EDX,[EDI + EDI*0x1]
0053cc27 : PUSH EDX
0053cc28 : LEA EDX,[ECX + EAX*0x2]
0053cc2b : PUSH EBX
0053cc2c : PUSH EDX
0053cc2d : CALL 0x0063ae40
0053cc32 : MOV EBX,dword ptr [ESP + 0x2c]
0053cc36 : ADD ESP,0xc
0053cc39 : ADD dword ptr [ESI + 0x24],EDI
0053cc3c : JMP 0x0053cc48
0053cc3e : MOV EAX,dword ptr [EBP + 0x4]
0053cc41 : SUB EAX,dword ptr [EBP]
0053cc44 : SAR EAX,0x1
0053cc46 : ADD dword ptr [EBX],EAX
0053cc48 : CMP byte ptr [EBP + 0x10],0x0
0053cc4c : MOV EAX,dword ptr [EBP + 0x4]
0053cc4f : MOV dword ptr [EBP],EAX
0053cc52 : JZ 0x0053cc63
0053cc54 : CMP word ptr [EAX],0x26
0053cc58 : JNZ 0x0053cc63
0053cc5a : MOV ECX,EBP
0053cc5c : CALL 0x0053bdd0
0053cc61 : JMP 0x0053cc74
0053cc63 : CMP EAX,dword ptr [EBP + 0x8]
0053cc66 : JNC 0x0053cc74
0053cc68 : MOVZX ECX,word ptr [EAX]
0053cc6b : ADD EAX,0x2
0053cc6e : MOV dword ptr [EBP + 0xc],ECX
0053cc71 : MOV dword ptr [EBP + 0x4],EAX
0053cc74 : MOV EDX,dword ptr [EBP]
0053cc77 : CMP EDX,dword ptr [EBP + 0x8]
0053cc7a : JC 0x0053cab0
0053cc80 : CMP byte ptr [ESP + 0x13],0x0
0053cc85 : POP EDI
0053cc86 : JZ 0x0053cc96
0053cc88 : MOV EAX,dword ptr [ESI + 0x1c]
0053cc8b : MOV ECX,dword ptr [ESP + 0x18]
0053cc8f : MOV dword ptr [ECX],EAX
0053cc91 : MOV EDX,dword ptr [ESI + 0x24]
0053cc94 : MOV dword ptr [EBX],EDX
0053cc96 : POP ESI
0053cc97 : POP EBP
0053cc98 : POP EBX
0053cc99 : ADD ESP,0x8
0053cc9c : RET 0x8
