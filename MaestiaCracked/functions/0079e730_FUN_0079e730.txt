PROGRAM  : Maestia.exe
FUNCTION : FUN_0079e730
ENTRY    : 0079e730
BODY     : [[0079e730, 0079e835]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0079e730(void)

{
  DWORD DVar1;
  int iVar2;
  int in_ECX;
  int iVar3;
  
  if (*(char *)(in_ECX + 4) == '\0') {
    return;
  }
  if (*(char *)(in_ECX + 300) != '\0') {
    if (*(int *)(in_ECX + 0xac) == 0) {
      return;
    }
    if (*(char *)(in_ECX + 300) != '\0') goto LAB_0079e76e;
  }
  if ((*(int *)(in_ECX + 0x10c) == 0) && (*(int *)(in_ECX + 0xdc) == 0)) {
    return;
  }
LAB_0079e76e:
  if (*(char *)(in_ECX + 5) != '\0') {
    if ((*(int *)(in_ECX + 0x13c) == -1) ||
       (DVar1 = GetTickCount(), DVar1 - *(int *)(in_ECX + 0x140) <= *(uint *)(in_ECX + 0x13c))) {
      return;
    }
    if (*(char *)(in_ECX + 300) == '\0') {
      *(DWORD *)(in_ECX + 0xf8) = DVar1;
      *(DWORD *)(in_ECX + 200) = DVar1;
    }
    else {
      *(DWORD *)(in_ECX + 0x98) = DVar1;
    }
    iVar2 = (*(int *)(in_ECX + 0x124) - *(int *)(in_ECX + 0x120)) / 0x30;
    if (0 < iVar2) {
      iVar3 = 0;
      do {
        *(DWORD *)(*(int *)(in_ECX + 0x120) + 0xc + iVar3) = DVar1;
        iVar3 = iVar3 + 0x30;
        iVar2 = iVar2 + -1;
      } while (iVar2 != 0);
    }
    *(undefined1 *)(in_ECX + 5) = 0;
  }
  FUN_0079bcb0();
  FUN_0079ca40();
  FUN_0079c4a0(in_ECX);
  if (*(char *)(in_ECX + 300) != '\0') {
    FUN_0079e660(in_ECX);
    FUN_0079c8b0();
    return;
  }
  FUN_0079e590();
  FUN_0079e4c0();
  FUN_0079c8b0();
  return;
}



============================================================
DISASSEMBLY
============================================================
0079e730 : PUSH ESI
0079e731 : MOV ESI,ECX
0079e733 : CMP byte ptr [ESI + 0x4],0x0
0079e737 : JZ 0x0079e834
0079e73d : MOV AL,byte ptr [ESI + 0x12c]
0079e743 : TEST AL,AL
0079e745 : JZ 0x0079e758
0079e747 : CMP dword ptr [ESI + 0xac],0x0
0079e74e : JZ 0x0079e834
0079e754 : TEST AL,AL
0079e756 : JNZ 0x0079e76e
0079e758 : CMP dword ptr [ESI + 0x10c],0x0
0079e75f : JNZ 0x0079e76e
0079e761 : CMP dword ptr [ESI + 0xdc],0x0
0079e768 : JZ 0x0079e834
0079e76e : CMP byte ptr [ESI + 0x5],0x0
0079e772 : PUSH EDI
0079e773 : JZ 0x0079e7f6
0079e779 : CMP dword ptr [ESI + 0x13c],-0x1
0079e780 : JZ 0x0079e833
0079e786 : CALL dword ptr [0x00b850d8]
0079e78c : MOV EDI,EAX
0079e78e : SUB EAX,dword ptr [ESI + 0x140]
0079e794 : CMP EAX,dword ptr [ESI + 0x13c]
0079e79a : JBE 0x0079e833
0079e7a0 : CMP byte ptr [ESI + 0x12c],0x0
0079e7a7 : JZ 0x0079e7b1
0079e7a9 : MOV dword ptr [ESI + 0x98],EDI
0079e7af : JMP 0x0079e7bd
0079e7b1 : MOV dword ptr [ESI + 0xf8],EDI
0079e7b7 : MOV dword ptr [ESI + 0xc8],EDI
0079e7bd : MOV ECX,dword ptr [ESI + 0x124]
0079e7c3 : SUB ECX,dword ptr [ESI + 0x120]
0079e7c9 : MOV EAX,0x2aaaaaab
0079e7ce : IMUL ECX
0079e7d0 : SAR EDX,0x3
0079e7d3 : MOV EAX,EDX
0079e7d5 : SHR EAX,0x1f
0079e7d8 : ADD EAX,EDX
0079e7da : TEST EAX,EAX
0079e7dc : JLE 0x0079e7f2
0079e7de : XOR ECX,ECX
0079e7e0 : MOV EDX,dword ptr [ESI + 0x120]
0079e7e6 : MOV dword ptr [EDX + ECX*0x1 + 0xc],EDI
0079e7ea : ADD ECX,0x30
0079e7ed : SUB EAX,0x1
0079e7f0 : JNZ 0x0079e7e0
0079e7f2 : MOV byte ptr [ESI + 0x5],0x0
0079e7f6 : CALL 0x0079bcb0
0079e7fb : CALL 0x0079ca40
0079e800 : PUSH ESI
0079e801 : CALL 0x0079c4a0
0079e806 : CMP byte ptr [ESI + 0x12c],0x0
0079e80d : JZ 0x0079e81e
0079e80f : PUSH ESI
0079e810 : CALL 0x0079e660
0079e815 : POP EDI
0079e816 : MOV EAX,ESI
0079e818 : POP ESI
0079e819 : JMP 0x0079c8b0
0079e81e : MOV EDI,ESI
0079e820 : CALL 0x0079e590
0079e825 : CALL 0x0079e4c0
0079e82a : POP EDI
0079e82b : MOV EAX,ESI
0079e82d : POP ESI
0079e82e : JMP 0x0079c8b0
0079e833 : POP EDI
0079e834 : POP ESI
0079e835 : RET
