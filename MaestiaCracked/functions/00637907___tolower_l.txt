PROGRAM  : Maestia.exe
FUNCTION : __tolower_l
ENTRY    : 00637907
BODY     : [[00637907, 00637a1b]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    __tolower_l
   
   Library: Visual Studio 2008 Release */

int __cdecl __tolower_l(int _C,_locale_t _Locale)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  CHAR CVar5;
  localeinfo_struct local_1c;
  int local_14;
  char local_10;
  byte local_c;
  undefined1 local_b;
  CHAR local_8;
  CHAR local_7;
  undefined1 local_6;
  
  iVar1 = _C;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_1c,_Locale);
  if ((uint)_C < 0x100) {
    if ((int)(local_1c.locinfo)->locale_name[3] < 2) {
      uVar2 = *(ushort *)(local_1c.locinfo[1].lc_category[0].locale + _C * 2) & 1;
    }
    else {
      uVar2 = __isctype_l(_C,1,&local_1c);
    }
    if (uVar2 == 0) {
LAB_00637968:
      if (local_10 == '\0') {
        return iVar1;
      }
      *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)local_1c.locinfo[1].lc_category[0].wlocale + _C);
  }
  else {
    CVar5 = (CHAR)_C;
    if (((int)(local_1c.locinfo)->locale_name[3] < 2) ||
       (iVar3 = __isleadbyte_l(_C >> 8 & 0xff,&local_1c), iVar3 == 0)) {
      piVar4 = __errno();
      *piVar4 = 0x2a;
      local_7 = '\0';
      iVar3 = 1;
      local_8 = CVar5;
    }
    else {
      _C._0_1_ = (CHAR)((uint)_C >> 8);
      local_8 = (CHAR)_C;
      local_6 = 0;
      iVar3 = 2;
      local_7 = CVar5;
    }
    iVar3 = ___crtLCMapStringA(&local_1c,(local_1c.locinfo)->lc_category[0].wlocale,0x100,&local_8,
                               iVar3,(LPSTR)&local_c,3,(local_1c.locinfo)->lc_codepage,1);
    if (iVar3 == 0) goto LAB_00637968;
    uVar2 = (uint)local_c;
    if (iVar3 != 1) {
      uVar2 = (uint)CONCAT11(local_c,local_b);
    }
  }
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return uVar2;
}



============================================================
DISASSEMBLY
============================================================
00637907 : MOV EDI,EDI
00637909 : PUSH EBP
0063790a : MOV EBP,ESP
0063790c : SUB ESP,0x18
0063790f : PUSH EBX
00637910 : PUSH ESI
00637911 : PUSH dword ptr [EBP + 0xc]
00637914 : LEA ECX,[EBP + -0x18]
00637917 : CALL 0x00637880
0063791c : MOV EBX,dword ptr [EBP + 0x8]
0063791f : MOV ESI,0x100
00637924 : CMP EBX,ESI
00637926 : JNC 0x0063797c
00637928 : MOV ECX,dword ptr [EBP + -0x18]
0063792b : CMP dword ptr [ECX + 0xac],0x1
00637932 : JLE 0x00637948
00637934 : LEA EAX,[EBP + -0x18]
00637937 : PUSH EAX
00637938 : PUSH 0x1
0063793a : PUSH EBX
0063793b : CALL 0x00651518
00637940 : MOV ECX,dword ptr [EBP + -0x18]
00637943 : ADD ESP,0xc
00637946 : JMP 0x00637955
00637948 : MOV EAX,dword ptr [ECX + 0xc8]
0063794e : MOVZX EAX,word ptr [EAX + EBX*0x2]
00637952 : AND EAX,0x1
00637955 : TEST EAX,EAX
00637957 : JZ 0x00637968
00637959 : MOV EAX,dword ptr [ECX + 0xcc]
0063795f : MOVZX EAX,byte ptr [EAX + EBX*0x1]
00637963 : JMP 0x00637a0b
00637968 : CMP byte ptr [EBP + -0xc],0x0
0063796c : JZ 0x00637975
0063796e : MOV EAX,dword ptr [EBP + -0x10]
00637971 : AND dword ptr [EAX + 0x70],0xfffffffd
00637975 : MOV EAX,EBX
00637977 : JMP 0x00637a18
0063797c : MOV EAX,dword ptr [EBP + -0x18]
0063797f : CMP dword ptr [EAX + 0xac],0x1
00637986 : JLE 0x006379b9
00637988 : MOV dword ptr [EBP + 0x8],EBX
0063798b : SAR dword ptr [EBP + 0x8],0x8
0063798f : LEA EAX,[EBP + -0x18]
00637992 : PUSH EAX
00637993 : MOV EAX,dword ptr [EBP + 0x8]
00637996 : AND EAX,0xff
0063799b : PUSH EAX
0063799c : CALL 0x006390f8
006379a1 : POP ECX
006379a2 : POP ECX
006379a3 : TEST EAX,EAX
006379a5 : JZ 0x006379b9
006379a7 : MOV AL,byte ptr [EBP + 0x8]
006379aa : PUSH 0x2
006379ac : MOV byte ptr [EBP + -0x4],AL
006379af : MOV byte ptr [EBP + -0x3],BL
006379b2 : MOV byte ptr [EBP + -0x2],0x0
006379b6 : POP ECX
006379b7 : JMP 0x006379ce
006379b9 : CALL 0x0063ab82
006379be : MOV dword ptr [EAX],0x2a
006379c4 : XOR ECX,ECX
006379c6 : MOV byte ptr [EBP + -0x4],BL
006379c9 : MOV byte ptr [EBP + -0x3],0x0
006379cd : INC ECX
006379ce : MOV EAX,dword ptr [EBP + -0x18]
006379d1 : PUSH 0x1
006379d3 : PUSH dword ptr [EAX + 0x4]
006379d6 : LEA EDX,[EBP + -0x8]
006379d9 : PUSH 0x3
006379db : PUSH EDX
006379dc : PUSH ECX
006379dd : LEA ECX,[EBP + -0x4]
006379e0 : PUSH ECX
006379e1 : PUSH ESI
006379e2 : PUSH dword ptr [EAX + 0x14]
006379e5 : LEA EAX,[EBP + -0x18]
006379e8 : PUSH EAX
006379e9 : CALL 0x00643b47
006379ee : ADD ESP,0x24
006379f1 : TEST EAX,EAX
006379f3 : JZ 0x00637968
006379f9 : CMP EAX,0x1
006379fc : MOVZX EAX,byte ptr [EBP + -0x8]
00637a00 : JZ 0x00637a0b
00637a02 : MOVZX ECX,byte ptr [EBP + -0x7]
00637a06 : SHL EAX,0x8
00637a09 : OR EAX,ECX
00637a0b : CMP byte ptr [EBP + -0xc],0x0
00637a0f : JZ 0x00637a18
00637a11 : MOV ECX,dword ptr [EBP + -0x10]
00637a14 : AND dword ptr [ECX + 0x70],0xfffffffd
00637a18 : POP ESI
00637a19 : POP EBX
00637a1a : LEAVE
00637a1b : RET
