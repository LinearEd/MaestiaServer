PROGRAM  : Maestia.exe
FUNCTION : _memcmp
ENTRY    : 00640edf
BODY     : [[00640edf, 006424de]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    _memcmp
   
   Library: Visual Studio 2008 Release */

int __cdecl _memcmp(void *_Buf1,void *_Buf2,size_t _Size)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  if (_Size == 0) {
    return 0;
  }
  if (_Size == 1) {
    uVar2 = (uint)*(byte *)_Buf1;
    uVar3 = (uint)*(byte *)_Buf2;
LAB_00642438:
    if (uVar2 == uVar3) {
      return 0;
    }
    return (uint)(0 < (int)(uVar2 - uVar3)) * 2 + -1;
  }
  if (_Size == 2) {
    uVar2 = (uint)*(byte *)_Buf1;
    uVar3 = (uint)*(byte *)_Buf2;
    if ((uVar2 != uVar3) &&
       (iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar3 = (uint)*(byte *)((int)_Buf2 + 1);
    goto LAB_00642438;
  }
  if (_Size == 3) {
    uVar2 = (uint)*(byte *)_Buf1;
    uVar3 = (uint)*(byte *)_Buf2;
    if ((uVar2 != uVar3) &&
       (iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar3 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar2 != uVar3) &&
       (iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar3 = (uint)*(byte *)((int)_Buf2 + 2);
    goto LAB_00642438;
  }
  if (_Size == 4) {
    uVar2 = (uint)*(byte *)_Buf1;
    uVar3 = (uint)*(byte *)_Buf2;
    if ((uVar2 != uVar3) &&
       (iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 1);
    uVar3 = (uint)*(byte *)((int)_Buf2 + 1);
    if ((uVar2 != uVar3) &&
       (iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 2);
    uVar3 = (uint)*(byte *)((int)_Buf2 + 2);
    if ((uVar2 != uVar3) &&
       (iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    uVar2 = (uint)*(byte *)((int)_Buf1 + 3);
    uVar3 = (uint)*(byte *)((int)_Buf2 + 3);
    goto LAB_00642438;
  }
  for (; 0x1f < _Size; _Size = _Size - 0x20) {
    if (*(int *)_Buf1 == *(int *)_Buf2) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)_Buf1;
      uVar2 = (uint)*(byte *)_Buf2;
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 1);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 1);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 2);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 2);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 3) != (uint)*(byte *)((int)_Buf2 + 3)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 3) - (uint)*(byte *)((int)_Buf2 + 3)))
                * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 4) == *(int *)((int)_Buf2 + 4)) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)((int)_Buf1 + 4);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 4);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 5);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 5);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 6);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 6);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 7) != (uint)*(byte *)((int)_Buf2 + 7)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 7) - (uint)*(byte *)((int)_Buf2 + 7)))
                * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 8) == *(int *)((int)_Buf2 + 8)) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)((int)_Buf1 + 8);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 8);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 9);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 9);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 10);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 10);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 0xb) != (uint)*(byte *)((int)_Buf2 + 0xb)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 0xb) -
                                (uint)*(byte *)((int)_Buf2 + 0xb))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 0xc) == *(int *)((int)_Buf2 + 0xc)) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0xc);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0xc);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0xd);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0xd);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0xe);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0xe);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 0xf) != (uint)*(byte *)((int)_Buf2 + 0xf)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 0xf) -
                                (uint)*(byte *)((int)_Buf2 + 0xf))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 0x10) == *(int *)((int)_Buf2 + 0x10)) {
      iVar1 = 0;
    }
    else {
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x10);
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x10);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x11);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x11);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x12);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x12);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 0x13) != (uint)*(byte *)((int)_Buf2 + 0x13)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 0x13) -
                                (uint)*(byte *)((int)_Buf2 + 0x13))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 0x14) == *(int *)((int)_Buf2 + 0x14)) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x14);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x14);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x15);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x15);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x16);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x16);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 0x17) != (uint)*(byte *)((int)_Buf2 + 0x17)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 0x17) -
                                (uint)*(byte *)((int)_Buf2 + 0x17))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 0x18) == *(int *)((int)_Buf2 + 0x18)) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x18);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x18);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x19);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x19);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x1a);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x1a);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 0x1b) != (uint)*(byte *)((int)_Buf2 + 0x1b)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 0x1b) -
                                (uint)*(byte *)((int)_Buf2 + 0x1b))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    if (*(int *)((int)_Buf1 + 0x1c) == *(int *)((int)_Buf2 + 0x1c)) {
      iVar1 = 0;
    }
    else {
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x1c);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x1c);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x1d);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x1d);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + 0x1e);
      uVar2 = (uint)*(byte *)((int)_Buf2 + 0x1e);
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + 0x1f) != (uint)*(byte *)((int)_Buf2 + 0x1f)) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + 0x1f) -
                                (uint)*(byte *)((int)_Buf2 + 0x1f))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
    _Buf1 = (void *)((int)_Buf1 + 0x20);
    _Buf2 = (void *)((int)_Buf2 + 0x20);
  }
  switch(_Size) {
  default:
    goto switchD_006413a6_caseD_0;
  case 1:
    goto switchD_006413a6_caseD_1;
  case 2:
    goto switchD_006413a6_caseD_2;
  case 3:
    goto switchD_006413a6_caseD_3;
  case 4:
    goto switchD_006413a6_caseD_4;
  case 5:
    goto switchD_006413a6_caseD_5;
  case 6:
    goto switchD_006413a6_caseD_6;
  case 7:
    goto switchD_006413a6_caseD_7;
  case 8:
    goto switchD_006413a6_caseD_8;
  case 9:
    goto switchD_006413a6_caseD_9;
  case 10:
    goto switchD_006413a6_caseD_a;
  case 0xb:
    goto switchD_006413a6_caseD_b;
  case 0xc:
    goto switchD_006413a6_caseD_c;
  case 0xd:
    goto switchD_006413a6_caseD_d;
  case 0xe:
    goto switchD_006413a6_caseD_e;
  case 0xf:
    goto switchD_006413a6_caseD_f;
  case 0x10:
    goto switchD_006413a6_caseD_10;
  case 0x11:
    goto switchD_006413a6_caseD_11;
  case 0x12:
    goto switchD_006413a6_caseD_12;
  case 0x13:
    goto switchD_006413a6_caseD_13;
  case 0x14:
    goto switchD_006413a6_caseD_14;
  case 0x15:
    goto switchD_006413a6_caseD_15;
  case 0x16:
    goto switchD_006413a6_caseD_16;
  case 0x17:
    goto switchD_006413a6_caseD_17;
  case 0x18:
    goto switchD_006413a6_caseD_18;
  case 0x1a:
    goto switchD_006413a6_caseD_1a;
  case 0x1b:
    goto switchD_006413a6_caseD_1b;
  case 0x1c:
    if (*(uint *)((int)_Buf1 + (_Size - 0x1c)) == *(uint *)((int)_Buf2 + (_Size - 0x1c))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x1c)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x19))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x19)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_18:
    if (*(uint *)((int)_Buf1 + (_Size - 0x18)) == *(uint *)((int)_Buf2 + (_Size - 0x18))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x18)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x15))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x15)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_14:
    if (*(uint *)((int)_Buf1 + (_Size - 0x14)) == *(uint *)((int)_Buf2 + (_Size - 0x14))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x14)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x11))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x11)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_10:
    if (*(uint *)((int)_Buf1 + (_Size - 0x10)) == *(uint *)((int)_Buf2 + (_Size - 0x10))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x10)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) != (uint)*(byte *)((int)_Buf2 + (_Size - 0xd))
         ) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0xd)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_c:
    if (*(int *)((int)_Buf1 + (_Size - 0xc)) == *(int *)((int)_Buf2 + (_Size - 0xc))) {
      iVar1 = 0;
    }
    else {
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 9)) != (uint)*(byte *)((int)_Buf2 + (_Size - 9))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 9)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 9)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_8:
    if (*(uint *)((int)_Buf1 + (_Size - 8)) == *(uint *)((int)_Buf2 + (_Size - 8))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 8)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 5)) != (uint)*(byte *)((int)_Buf2 + (_Size - 5))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 5)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 5)))) * 2 + -1;
      }
    }
    if (iVar1 == 0) {
switchD_006413a6_caseD_4:
      if (*(uint *)((int)_Buf1 + (_Size - 4)) == *(uint *)((int)_Buf2 + (_Size - 4))) {
        iVar1 = 0;
      }
      else {
        uVar3 = *(uint *)((int)_Buf1 + (_Size - 4)) & 0xff;
        uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));
        if ((uVar3 == uVar2) ||
           (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 == 0)) {
          uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));
          uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));
          if ((uVar3 == uVar2) ||
             (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 == 0)) {
            uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2));
            uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 2));
            if ((uVar3 == uVar2) ||
               (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 == 0)) {
              iVar1 = 0;
              if ((uint)*(byte *)((int)_Buf1 + (_Size - 1)) !=
                  (uint)*(byte *)((int)_Buf2 + (_Size - 1))) {
                iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 1)) -
                                        (uint)*(byte *)((int)_Buf2 + (_Size - 1)))) * 2 + -1;
              }
            }
          }
        }
      }
      if (iVar1 == 0) {
switchD_006413a6_caseD_0:
        iVar1 = 0;
      }
    }
    return iVar1;
  case 0x1d:
    if (*(uint *)((int)_Buf1 + (_Size - 0x1d)) == *(uint *)((int)_Buf2 + (_Size - 0x1d))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x1d)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
  case 0x19:
    if (*(uint *)((int)_Buf1 + (_Size - 0x19)) == *(uint *)((int)_Buf2 + (_Size - 0x19))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x19)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x16))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x16)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_15:
    if (*(uint *)((int)_Buf1 + (_Size - 0x15)) == *(uint *)((int)_Buf2 + (_Size - 0x15))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x15)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x12))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x12)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_11:
    if (*(uint *)((int)_Buf1 + (_Size - 0x11)) == *(uint *)((int)_Buf2 + (_Size - 0x11))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x11)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) != (uint)*(byte *)((int)_Buf2 + (_Size - 0xe))
         ) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0xe)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_d:
    if (*(uint *)((int)_Buf1 + (_Size - 0xd)) == *(uint *)((int)_Buf2 + (_Size - 0xd))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0xd)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 10)) != (uint)*(byte *)((int)_Buf2 + (_Size - 10)))
      {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 10)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 10)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_9:
    if (*(int *)((int)_Buf1 + (_Size - 9)) == *(int *)((int)_Buf2 + (_Size - 9))) {
      iVar1 = 0;
    }
    else {
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 6)) != (uint)*(byte *)((int)_Buf2 + (_Size - 6))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 6)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 6)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_5:
    if (*(uint *)((int)_Buf1 + (_Size - 5)) == *(uint *)((int)_Buf2 + (_Size - 5))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 5)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 2)) != (uint)*(byte *)((int)_Buf2 + (_Size - 2))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 2)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 2)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_1:
    if ((uint)*(byte *)((int)_Buf1 + (_Size - 1)) == (uint)*(byte *)((int)_Buf2 + (_Size - 1))) {
      return 0;
    }
    return (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 1)) -
                           (uint)*(byte *)((int)_Buf2 + (_Size - 1)))) * 2 + -1;
  case 0x1e:
    if (*(uint *)((int)_Buf1 + (_Size - 0x1e)) == *(uint *)((int)_Buf2 + (_Size - 0x1e))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x1e)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_1a:
    if (*(uint *)((int)_Buf1 + (_Size - 0x1a)) == *(uint *)((int)_Buf2 + (_Size - 0x1a))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x1a)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x17))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x17)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_16:
    if (*(uint *)((int)_Buf1 + (_Size - 0x16)) == *(uint *)((int)_Buf2 + (_Size - 0x16))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x16)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x13))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x13)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_12:
    if (*(uint *)((int)_Buf1 + (_Size - 0x12)) == *(uint *)((int)_Buf2 + (_Size - 0x12))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x12)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) != (uint)*(byte *)((int)_Buf2 + (_Size - 0xf))
         ) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0xf)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_e:
    if (*(uint *)((int)_Buf1 + (_Size - 0xe)) == *(uint *)((int)_Buf2 + (_Size - 0xe))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0xe)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) != (uint)*(byte *)((int)_Buf2 + (_Size - 0xb))
         ) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0xb)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_a:
    if (*(int *)((int)_Buf1 + (_Size - 10)) == *(int *)((int)_Buf2 + (_Size - 10))) {
      iVar1 = 0;
    }
    else {
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 7)) != (uint)*(byte *)((int)_Buf2 + (_Size - 7))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 7)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 7)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_6:
    if (*(uint *)((int)_Buf1 + (_Size - 6)) == *(uint *)((int)_Buf2 + (_Size - 6))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 6)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 3)) != (uint)*(byte *)((int)_Buf2 + (_Size - 3))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 3)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 3)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_2:
    if (*(short *)((int)_Buf1 + (_Size - 2)) != *(short *)((int)_Buf2 + (_Size - 2))) {
LAB_00641f8c:
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 2));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      goto switchD_006413a6_caseD_1;
    }
    goto switchD_006413a6_caseD_0;
  case 0x1f:
    if (*(int *)((int)_Buf1 + (_Size - 0x1f)) == *(int *)((int)_Buf2 + (_Size - 0x1f))) {
      iVar1 = 0;
    }
    else {
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1f));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1f));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1e));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_1b:
    if (*(uint *)((int)_Buf1 + (_Size - 0x1b)) == *(uint *)((int)_Buf2 + (_Size - 0x1b))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x1b)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x18))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x18)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_17:
    if (*(uint *)((int)_Buf1 + (_Size - 0x17)) == *(uint *)((int)_Buf2 + (_Size - 0x17))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x17)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x14))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x14)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_13:
    if (*(uint *)((int)_Buf1 + (_Size - 0x13)) == *(uint *)((int)_Buf2 + (_Size - 0x13))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0x13)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) !=
          (uint)*(byte *)((int)_Buf2 + (_Size - 0x10))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0x10)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_f:
    if (*(int *)((int)_Buf1 + (_Size - 0xf)) == *(int *)((int)_Buf2 + (_Size - 0xf))) {
      iVar1 = 0;
    }
    else {
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) != (uint)*(byte *)((int)_Buf2 + (_Size - 0xc))
         ) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 0xc)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_b:
    if (*(uint *)((int)_Buf1 + (_Size - 0xb)) == *(uint *)((int)_Buf2 + (_Size - 0xb))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 0xb)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 8)) != (uint)*(byte *)((int)_Buf2 + (_Size - 8))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 8)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 8)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_7:
    if (*(uint *)((int)_Buf1 + (_Size - 7)) == *(uint *)((int)_Buf2 + (_Size - 7))) {
      iVar1 = 0;
    }
    else {
      uVar3 = *(uint *)((int)_Buf1 + (_Size - 7)) & 0xff;
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5));
      uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));
      if ((uVar3 != uVar2) &&
         (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
        return iVar1;
      }
      iVar1 = 0;
      if ((uint)*(byte *)((int)_Buf1 + (_Size - 4)) != (uint)*(byte *)((int)_Buf2 + (_Size - 4))) {
        iVar1 = (uint)(0 < (int)((uint)*(byte *)((int)_Buf1 + (_Size - 4)) -
                                (uint)*(byte *)((int)_Buf2 + (_Size - 4)))) * 2 + -1;
      }
    }
    if (iVar1 != 0) {
      return iVar1;
    }
switchD_006413a6_caseD_3:
    uVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));
    uVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));
    if ((uVar3 != uVar2) &&
       (iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {
      return iVar1;
    }
    goto LAB_00641f8c;
  }
}



============================================================
DISASSEMBLY
============================================================
00640edf : MOV EDI,EDI
00640ee1 : PUSH EBP
00640ee2 : MOV EBP,ESP
00640ee4 : PUSH ESI
00640ee5 : PUSH EDI
00640ee6 : MOV EDI,dword ptr [EBP + 0x10]
00640ee9 : MOV EAX,EDI
00640eeb : SUB EAX,0x0
00640eee : JZ 0x006424d9
00640ef4 : DEC EAX
00640ef5 : JZ 0x006424c8
00640efb : DEC EAX
00640efc : JZ 0x0064249a
00640f02 : DEC EAX
00640f03 : JZ 0x00642452
00640f09 : DEC EAX
00640f0a : JZ 0x006423c9
00640f10 : MOV ECX,dword ptr [EBP + 0xc]
00640f13 : MOV EAX,dword ptr [EBP + 0x8]
00640f16 : PUSH EBX
00640f17 : PUSH 0x20
00640f19 : POP EDX
00640f1a : JMP 0x00641391
00640f1f : MOV ESI,dword ptr [EAX]
00640f21 : CMP ESI,dword ptr [ECX]
00640f23 : JZ 0x00640fa1
00640f25 : MOVZX ESI,byte ptr [EAX]
00640f28 : MOVZX EBX,byte ptr [ECX]
00640f2b : SUB ESI,EBX
00640f2d : JZ 0x00640f44
00640f2f : XOR EBX,EBX
00640f31 : TEST ESI,ESI
00640f33 : SETG BL
00640f36 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00640f3a : MOV ESI,EBX
00640f3c : TEST ESI,ESI
00640f3e : JNZ 0x006413ad
00640f44 : MOVZX ESI,byte ptr [EAX + 0x1]
00640f48 : MOVZX EBX,byte ptr [ECX + 0x1]
00640f4c : SUB ESI,EBX
00640f4e : JZ 0x00640f65
00640f50 : XOR EBX,EBX
00640f52 : TEST ESI,ESI
00640f54 : SETG BL
00640f57 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00640f5b : MOV ESI,EBX
00640f5d : TEST ESI,ESI
00640f5f : JNZ 0x006413ad
00640f65 : MOVZX ESI,byte ptr [EAX + 0x2]
00640f69 : MOVZX EBX,byte ptr [ECX + 0x2]
00640f6d : SUB ESI,EBX
00640f6f : JZ 0x00640f86
00640f71 : XOR EBX,EBX
00640f73 : TEST ESI,ESI
00640f75 : SETG BL
00640f78 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00640f7c : MOV ESI,EBX
00640f7e : TEST ESI,ESI
00640f80 : JNZ 0x006413ad
00640f86 : MOVZX ESI,byte ptr [EAX + 0x3]
00640f8a : MOVZX EBX,byte ptr [ECX + 0x3]
00640f8e : SUB ESI,EBX
00640f90 : JZ 0x00640fa3
00640f92 : XOR EBX,EBX
00640f94 : TEST ESI,ESI
00640f96 : SETG BL
00640f99 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00640f9d : MOV ESI,EBX
00640f9f : JMP 0x00640fa3
00640fa1 : XOR ESI,ESI
00640fa3 : TEST ESI,ESI
00640fa5 : JNZ 0x006413ad
00640fab : MOV ESI,dword ptr [EAX + 0x4]
00640fae : CMP ESI,dword ptr [ECX + 0x4]
00640fb1 : JZ 0x00641031
00640fb3 : MOVZX ESI,byte ptr [EAX + 0x4]
00640fb7 : MOVZX EBX,byte ptr [ECX + 0x4]
00640fbb : SUB ESI,EBX
00640fbd : JZ 0x00640fd4
00640fbf : XOR EBX,EBX
00640fc1 : TEST ESI,ESI
00640fc3 : SETG BL
00640fc6 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00640fca : MOV ESI,EBX
00640fcc : TEST ESI,ESI
00640fce : JNZ 0x006413ad
00640fd4 : MOVZX ESI,byte ptr [EAX + 0x5]
00640fd8 : MOVZX EBX,byte ptr [ECX + 0x5]
00640fdc : SUB ESI,EBX
00640fde : JZ 0x00640ff5
00640fe0 : XOR EBX,EBX
00640fe2 : TEST ESI,ESI
00640fe4 : SETG BL
00640fe7 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00640feb : MOV ESI,EBX
00640fed : TEST ESI,ESI
00640fef : JNZ 0x006413ad
00640ff5 : MOVZX ESI,byte ptr [EAX + 0x6]
00640ff9 : MOVZX EBX,byte ptr [ECX + 0x6]
00640ffd : SUB ESI,EBX
00640fff : JZ 0x00641016
00641001 : XOR EBX,EBX
00641003 : TEST ESI,ESI
00641005 : SETG BL
00641008 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064100c : MOV ESI,EBX
0064100e : TEST ESI,ESI
00641010 : JNZ 0x006413ad
00641016 : MOVZX ESI,byte ptr [EAX + 0x7]
0064101a : MOVZX EBX,byte ptr [ECX + 0x7]
0064101e : SUB ESI,EBX
00641020 : JZ 0x00641033
00641022 : XOR EBX,EBX
00641024 : TEST ESI,ESI
00641026 : SETG BL
00641029 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064102d : MOV ESI,EBX
0064102f : JMP 0x00641033
00641031 : XOR ESI,ESI
00641033 : TEST ESI,ESI
00641035 : JNZ 0x006413ad
0064103b : MOV ESI,dword ptr [EAX + 0x8]
0064103e : CMP ESI,dword ptr [ECX + 0x8]
00641041 : JZ 0x006410c1
00641043 : MOVZX ESI,byte ptr [EAX + 0x8]
00641047 : MOVZX EBX,byte ptr [ECX + 0x8]
0064104b : SUB ESI,EBX
0064104d : JZ 0x00641064
0064104f : XOR EBX,EBX
00641051 : TEST ESI,ESI
00641053 : SETG BL
00641056 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064105a : MOV ESI,EBX
0064105c : TEST ESI,ESI
0064105e : JNZ 0x006413ad
00641064 : MOVZX ESI,byte ptr [EAX + 0x9]
00641068 : MOVZX EBX,byte ptr [ECX + 0x9]
0064106c : SUB ESI,EBX
0064106e : JZ 0x00641085
00641070 : XOR EBX,EBX
00641072 : TEST ESI,ESI
00641074 : SETG BL
00641077 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064107b : MOV ESI,EBX
0064107d : TEST ESI,ESI
0064107f : JNZ 0x006413ad
00641085 : MOVZX ESI,byte ptr [EAX + 0xa]
00641089 : MOVZX EBX,byte ptr [ECX + 0xa]
0064108d : SUB ESI,EBX
0064108f : JZ 0x006410a6
00641091 : XOR EBX,EBX
00641093 : TEST ESI,ESI
00641095 : SETG BL
00641098 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064109c : MOV ESI,EBX
0064109e : TEST ESI,ESI
006410a0 : JNZ 0x006413ad
006410a6 : MOVZX ESI,byte ptr [EAX + 0xb]
006410aa : MOVZX EBX,byte ptr [ECX + 0xb]
006410ae : SUB ESI,EBX
006410b0 : JZ 0x006410c3
006410b2 : XOR EBX,EBX
006410b4 : TEST ESI,ESI
006410b6 : SETG BL
006410b9 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006410bd : MOV ESI,EBX
006410bf : JMP 0x006410c3
006410c1 : XOR ESI,ESI
006410c3 : TEST ESI,ESI
006410c5 : JNZ 0x006413ad
006410cb : MOV ESI,dword ptr [EAX + 0xc]
006410ce : CMP ESI,dword ptr [ECX + 0xc]
006410d1 : JZ 0x00641151
006410d3 : MOVZX ESI,byte ptr [EAX + 0xc]
006410d7 : MOVZX EBX,byte ptr [ECX + 0xc]
006410db : SUB ESI,EBX
006410dd : JZ 0x006410f4
006410df : XOR EBX,EBX
006410e1 : TEST ESI,ESI
006410e3 : SETG BL
006410e6 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006410ea : MOV ESI,EBX
006410ec : TEST ESI,ESI
006410ee : JNZ 0x006413ad
006410f4 : MOVZX ESI,byte ptr [EAX + 0xd]
006410f8 : MOVZX EBX,byte ptr [ECX + 0xd]
006410fc : SUB ESI,EBX
006410fe : JZ 0x00641115
00641100 : XOR EBX,EBX
00641102 : TEST ESI,ESI
00641104 : SETG BL
00641107 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064110b : MOV ESI,EBX
0064110d : TEST ESI,ESI
0064110f : JNZ 0x006413ad
00641115 : MOVZX ESI,byte ptr [EAX + 0xe]
00641119 : MOVZX EBX,byte ptr [ECX + 0xe]
0064111d : SUB ESI,EBX
0064111f : JZ 0x00641136
00641121 : XOR EBX,EBX
00641123 : TEST ESI,ESI
00641125 : SETG BL
00641128 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064112c : MOV ESI,EBX
0064112e : TEST ESI,ESI
00641130 : JNZ 0x006413ad
00641136 : MOVZX ESI,byte ptr [EAX + 0xf]
0064113a : MOVZX EBX,byte ptr [ECX + 0xf]
0064113e : SUB ESI,EBX
00641140 : JZ 0x00641153
00641142 : XOR EBX,EBX
00641144 : TEST ESI,ESI
00641146 : SETG BL
00641149 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064114d : MOV ESI,EBX
0064114f : JMP 0x00641153
00641151 : XOR ESI,ESI
00641153 : TEST ESI,ESI
00641155 : JNZ 0x006413ad
0064115b : MOV ESI,dword ptr [EAX + 0x10]
0064115e : CMP ESI,dword ptr [ECX + 0x10]
00641161 : JZ 0x006411e1
00641163 : MOVZX EBX,byte ptr [ECX + 0x10]
00641167 : MOVZX ESI,byte ptr [EAX + 0x10]
0064116b : SUB ESI,EBX
0064116d : JZ 0x00641184
0064116f : XOR EBX,EBX
00641171 : TEST ESI,ESI
00641173 : SETG BL
00641176 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064117a : MOV ESI,EBX
0064117c : TEST ESI,ESI
0064117e : JNZ 0x006413ad
00641184 : MOVZX ESI,byte ptr [EAX + 0x11]
00641188 : MOVZX EBX,byte ptr [ECX + 0x11]
0064118c : SUB ESI,EBX
0064118e : JZ 0x006411a5
00641190 : XOR EBX,EBX
00641192 : TEST ESI,ESI
00641194 : SETG BL
00641197 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064119b : MOV ESI,EBX
0064119d : TEST ESI,ESI
0064119f : JNZ 0x006413ad
006411a5 : MOVZX ESI,byte ptr [EAX + 0x12]
006411a9 : MOVZX EBX,byte ptr [ECX + 0x12]
006411ad : SUB ESI,EBX
006411af : JZ 0x006411c6
006411b1 : XOR EBX,EBX
006411b3 : TEST ESI,ESI
006411b5 : SETG BL
006411b8 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006411bc : MOV ESI,EBX
006411be : TEST ESI,ESI
006411c0 : JNZ 0x006413ad
006411c6 : MOVZX ESI,byte ptr [EAX + 0x13]
006411ca : MOVZX EBX,byte ptr [ECX + 0x13]
006411ce : SUB ESI,EBX
006411d0 : JZ 0x006411e3
006411d2 : XOR EBX,EBX
006411d4 : TEST ESI,ESI
006411d6 : SETG BL
006411d9 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006411dd : MOV ESI,EBX
006411df : JMP 0x006411e3
006411e1 : XOR ESI,ESI
006411e3 : TEST ESI,ESI
006411e5 : JNZ 0x006413ad
006411eb : MOV ESI,dword ptr [EAX + 0x14]
006411ee : CMP ESI,dword ptr [ECX + 0x14]
006411f1 : JZ 0x00641271
006411f3 : MOVZX ESI,byte ptr [EAX + 0x14]
006411f7 : MOVZX EBX,byte ptr [ECX + 0x14]
006411fb : SUB ESI,EBX
006411fd : JZ 0x00641214
006411ff : XOR EBX,EBX
00641201 : TEST ESI,ESI
00641203 : SETG BL
00641206 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064120a : MOV ESI,EBX
0064120c : TEST ESI,ESI
0064120e : JNZ 0x006413ad
00641214 : MOVZX ESI,byte ptr [EAX + 0x15]
00641218 : MOVZX EBX,byte ptr [ECX + 0x15]
0064121c : SUB ESI,EBX
0064121e : JZ 0x00641235
00641220 : XOR EBX,EBX
00641222 : TEST ESI,ESI
00641224 : SETG BL
00641227 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064122b : MOV ESI,EBX
0064122d : TEST ESI,ESI
0064122f : JNZ 0x006413ad
00641235 : MOVZX ESI,byte ptr [EAX + 0x16]
00641239 : MOVZX EBX,byte ptr [ECX + 0x16]
0064123d : SUB ESI,EBX
0064123f : JZ 0x00641256
00641241 : XOR EBX,EBX
00641243 : TEST ESI,ESI
00641245 : SETG BL
00641248 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064124c : MOV ESI,EBX
0064124e : TEST ESI,ESI
00641250 : JNZ 0x006413ad
00641256 : MOVZX ESI,byte ptr [EAX + 0x17]
0064125a : MOVZX EBX,byte ptr [ECX + 0x17]
0064125e : SUB ESI,EBX
00641260 : JZ 0x00641273
00641262 : XOR EBX,EBX
00641264 : TEST ESI,ESI
00641266 : SETG BL
00641269 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064126d : MOV ESI,EBX
0064126f : JMP 0x00641273
00641271 : XOR ESI,ESI
00641273 : TEST ESI,ESI
00641275 : JNZ 0x006413ad
0064127b : MOV ESI,dword ptr [EAX + 0x18]
0064127e : CMP ESI,dword ptr [ECX + 0x18]
00641281 : JZ 0x00641301
00641283 : MOVZX ESI,byte ptr [EAX + 0x18]
00641287 : MOVZX EBX,byte ptr [ECX + 0x18]
0064128b : SUB ESI,EBX
0064128d : JZ 0x006412a4
0064128f : XOR EBX,EBX
00641291 : TEST ESI,ESI
00641293 : SETG BL
00641296 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064129a : MOV ESI,EBX
0064129c : TEST ESI,ESI
0064129e : JNZ 0x006413ad
006412a4 : MOVZX ESI,byte ptr [EAX + 0x19]
006412a8 : MOVZX EBX,byte ptr [ECX + 0x19]
006412ac : SUB ESI,EBX
006412ae : JZ 0x006412c5
006412b0 : XOR EBX,EBX
006412b2 : TEST ESI,ESI
006412b4 : SETG BL
006412b7 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006412bb : MOV ESI,EBX
006412bd : TEST ESI,ESI
006412bf : JNZ 0x006413ad
006412c5 : MOVZX ESI,byte ptr [EAX + 0x1a]
006412c9 : MOVZX EBX,byte ptr [ECX + 0x1a]
006412cd : SUB ESI,EBX
006412cf : JZ 0x006412e6
006412d1 : XOR EBX,EBX
006412d3 : TEST ESI,ESI
006412d5 : SETG BL
006412d8 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006412dc : MOV ESI,EBX
006412de : TEST ESI,ESI
006412e0 : JNZ 0x006413ad
006412e6 : MOVZX ESI,byte ptr [EAX + 0x1b]
006412ea : MOVZX EBX,byte ptr [ECX + 0x1b]
006412ee : SUB ESI,EBX
006412f0 : JZ 0x00641303
006412f2 : XOR EBX,EBX
006412f4 : TEST ESI,ESI
006412f6 : SETG BL
006412f9 : LEA EBX,[EBX + EBX*0x1 + -0x1]
006412fd : MOV ESI,EBX
006412ff : JMP 0x00641303
00641301 : XOR ESI,ESI
00641303 : TEST ESI,ESI
00641305 : JNZ 0x006413ad
0064130b : MOV ESI,dword ptr [EAX + 0x1c]
0064130e : CMP ESI,dword ptr [ECX + 0x1c]
00641311 : JZ 0x00641385
00641313 : MOVZX ESI,byte ptr [EAX + 0x1c]
00641317 : MOVZX EBX,byte ptr [ECX + 0x1c]
0064131b : SUB ESI,EBX
0064131d : JZ 0x00641330
0064131f : XOR EBX,EBX
00641321 : TEST ESI,ESI
00641323 : SETG BL
00641326 : LEA EBX,[EBX + EBX*0x1 + -0x1]
0064132a : MOV ESI,EBX
0064132c : TEST ESI,ESI
0064132e : JNZ 0x006413ad
00641330 : MOVZX ESI,byte ptr [EAX + 0x1d]
00641334 : MOVZX EBX,byte ptr [ECX + 0x1d]
00641338 : SUB ESI,EBX
0064133a : JZ 0x0064134d
0064133c : XOR EBX,EBX
0064133e : TEST ESI,ESI
00641340 : SETG BL
00641343 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00641347 : MOV ESI,EBX
00641349 : TEST ESI,ESI
0064134b : JNZ 0x006413ad
0064134d : MOVZX ESI,byte ptr [EAX + 0x1e]
00641351 : MOVZX EBX,byte ptr [ECX + 0x1e]
00641355 : SUB ESI,EBX
00641357 : JZ 0x0064136a
00641359 : XOR EBX,EBX
0064135b : TEST ESI,ESI
0064135d : SETG BL
00641360 : LEA EBX,[EBX + EBX*0x1 + -0x1]
00641364 : MOV ESI,EBX
00641366 : TEST ESI,ESI
00641368 : JNZ 0x006413ad
0064136a : MOVZX ESI,byte ptr [EAX + 0x1f]
0064136e : MOVZX EBX,byte ptr [ECX + 0x1f]
00641372 : SUB ESI,EBX
00641374 : JZ 0x00641387
00641376 : XOR EBX,EBX
00641378 : TEST ESI,ESI
0064137a : SETG BL
0064137d : LEA EBX,[EBX + EBX*0x1 + -0x1]
00641381 : MOV ESI,EBX
00641383 : JMP 0x00641387
00641385 : XOR ESI,ESI
00641387 : TEST ESI,ESI
00641389 : JNZ 0x006413ad
0064138b : ADD EAX,EDX
0064138d : ADD ECX,EDX
0064138f : SUB EDI,EDX
00641391 : CMP EDI,EDX
00641393 : JNC 0x00640f1f
00641399 : ADD EAX,EDI
0064139b : ADD ECX,EDI
0064139d : CMP EDI,0x1f
006413a0 : JA 0x00641780
006413a6 : JMP dword ptr [EDI*0x4 + 0x6424df]
006413ad : MOV EAX,ESI
006413af : JMP 0x00641782
006413b4 : MOV EDX,dword ptr [EAX + -0x1c]
006413b7 : CMP EDX,dword ptr [ECX + -0x1c]
006413ba : JZ 0x0064142d
006413bc : MOVZX ESI,DL
006413bf : MOVZX EDX,byte ptr [ECX + -0x1c]
006413c3 : SUB ESI,EDX
006413c5 : JZ 0x006413d8
006413c7 : XOR EDX,EDX
006413c9 : TEST ESI,ESI
006413cb : SETG DL
006413ce : LEA EDX,[EDX + EDX*0x1 + -0x1]
006413d2 : MOV ESI,EDX
006413d4 : TEST ESI,ESI
006413d6 : JNZ 0x006413ad
006413d8 : MOVZX ESI,byte ptr [EAX + -0x1b]
006413dc : MOVZX EDX,byte ptr [ECX + -0x1b]
006413e0 : SUB ESI,EDX
006413e2 : JZ 0x006413f5
006413e4 : XOR EDX,EDX
006413e6 : TEST ESI,ESI
006413e8 : SETG DL
006413eb : LEA EDX,[EDX + EDX*0x1 + -0x1]
006413ef : MOV ESI,EDX
006413f1 : TEST ESI,ESI
006413f3 : JNZ 0x006413ad
006413f5 : MOVZX ESI,byte ptr [EAX + -0x1a]
006413f9 : MOVZX EDX,byte ptr [ECX + -0x1a]
006413fd : SUB ESI,EDX
006413ff : JZ 0x00641412
00641401 : XOR EDX,EDX
00641403 : TEST ESI,ESI
00641405 : SETG DL
00641408 : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064140c : MOV ESI,EDX
0064140e : TEST ESI,ESI
00641410 : JNZ 0x006413ad
00641412 : MOVZX ESI,byte ptr [EAX + -0x19]
00641416 : MOVZX EDX,byte ptr [ECX + -0x19]
0064141a : SUB ESI,EDX
0064141c : JZ 0x0064142f
0064141e : XOR EDX,EDX
00641420 : TEST ESI,ESI
00641422 : SETG DL
00641425 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641429 : MOV ESI,EDX
0064142b : JMP 0x0064142f
0064142d : XOR ESI,ESI
0064142f : TEST ESI,ESI
00641431 : JNZ 0x006413ad
00641437 : MOV EDX,dword ptr [EAX + -0x18]
0064143a : CMP EDX,dword ptr [ECX + -0x18]
0064143d : JZ 0x006414bc
0064143f : MOVZX ESI,DL
00641442 : MOVZX EDX,byte ptr [ECX + -0x18]
00641446 : SUB ESI,EDX
00641448 : JZ 0x0064145f
0064144a : XOR EDX,EDX
0064144c : TEST ESI,ESI
0064144e : SETG DL
00641451 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641455 : MOV ESI,EDX
00641457 : TEST ESI,ESI
00641459 : JNZ 0x006413ad
0064145f : MOVZX ESI,byte ptr [EAX + -0x17]
00641463 : MOVZX EDX,byte ptr [ECX + -0x17]
00641467 : SUB ESI,EDX
00641469 : JZ 0x00641480
0064146b : XOR EDX,EDX
0064146d : TEST ESI,ESI
0064146f : SETG DL
00641472 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641476 : MOV ESI,EDX
00641478 : TEST ESI,ESI
0064147a : JNZ 0x006413ad
00641480 : MOVZX ESI,byte ptr [EAX + -0x16]
00641484 : MOVZX EDX,byte ptr [ECX + -0x16]
00641488 : SUB ESI,EDX
0064148a : JZ 0x006414a1
0064148c : XOR EDX,EDX
0064148e : TEST ESI,ESI
00641490 : SETG DL
00641493 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641497 : MOV ESI,EDX
00641499 : TEST ESI,ESI
0064149b : JNZ 0x006413ad
006414a1 : MOVZX ESI,byte ptr [EAX + -0x15]
006414a5 : MOVZX EDX,byte ptr [ECX + -0x15]
006414a9 : SUB ESI,EDX
006414ab : JZ 0x006414be
006414ad : XOR EDX,EDX
006414af : TEST ESI,ESI
006414b1 : SETG DL
006414b4 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006414b8 : MOV ESI,EDX
006414ba : JMP 0x006414be
006414bc : XOR ESI,ESI
006414be : TEST ESI,ESI
006414c0 : JNZ 0x006413ad
006414c6 : MOV EDX,dword ptr [EAX + -0x14]
006414c9 : CMP EDX,dword ptr [ECX + -0x14]
006414cc : JZ 0x0064154b
006414ce : MOVZX ESI,DL
006414d1 : MOVZX EDX,byte ptr [ECX + -0x14]
006414d5 : SUB ESI,EDX
006414d7 : JZ 0x006414ee
006414d9 : XOR EDX,EDX
006414db : TEST ESI,ESI
006414dd : SETG DL
006414e0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006414e4 : MOV ESI,EDX
006414e6 : TEST ESI,ESI
006414e8 : JNZ 0x006413ad
006414ee : MOVZX ESI,byte ptr [EAX + -0x13]
006414f2 : MOVZX EDX,byte ptr [ECX + -0x13]
006414f6 : SUB ESI,EDX
006414f8 : JZ 0x0064150f
006414fa : XOR EDX,EDX
006414fc : TEST ESI,ESI
006414fe : SETG DL
00641501 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641505 : MOV ESI,EDX
00641507 : TEST ESI,ESI
00641509 : JNZ 0x006413ad
0064150f : MOVZX ESI,byte ptr [EAX + -0x12]
00641513 : MOVZX EDX,byte ptr [ECX + -0x12]
00641517 : SUB ESI,EDX
00641519 : JZ 0x00641530
0064151b : XOR EDX,EDX
0064151d : TEST ESI,ESI
0064151f : SETG DL
00641522 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641526 : MOV ESI,EDX
00641528 : TEST ESI,ESI
0064152a : JNZ 0x006413ad
00641530 : MOVZX ESI,byte ptr [EAX + -0x11]
00641534 : MOVZX EDX,byte ptr [ECX + -0x11]
00641538 : SUB ESI,EDX
0064153a : JZ 0x0064154d
0064153c : XOR EDX,EDX
0064153e : TEST ESI,ESI
00641540 : SETG DL
00641543 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641547 : MOV ESI,EDX
00641549 : JMP 0x0064154d
0064154b : XOR ESI,ESI
0064154d : TEST ESI,ESI
0064154f : JNZ 0x006413ad
00641555 : MOV EDX,dword ptr [EAX + -0x10]
00641558 : CMP EDX,dword ptr [ECX + -0x10]
0064155b : JZ 0x006415da
0064155d : MOVZX ESI,DL
00641560 : MOVZX EDX,byte ptr [ECX + -0x10]
00641564 : SUB ESI,EDX
00641566 : JZ 0x0064157d
00641568 : XOR EDX,EDX
0064156a : TEST ESI,ESI
0064156c : SETG DL
0064156f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641573 : MOV ESI,EDX
00641575 : TEST ESI,ESI
00641577 : JNZ 0x006413ad
0064157d : MOVZX ESI,byte ptr [EAX + -0xf]
00641581 : MOVZX EDX,byte ptr [ECX + -0xf]
00641585 : SUB ESI,EDX
00641587 : JZ 0x0064159e
00641589 : XOR EDX,EDX
0064158b : TEST ESI,ESI
0064158d : SETG DL
00641590 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641594 : MOV ESI,EDX
00641596 : TEST ESI,ESI
00641598 : JNZ 0x006413ad
0064159e : MOVZX ESI,byte ptr [EAX + -0xe]
006415a2 : MOVZX EDX,byte ptr [ECX + -0xe]
006415a6 : SUB ESI,EDX
006415a8 : JZ 0x006415bf
006415aa : XOR EDX,EDX
006415ac : TEST ESI,ESI
006415ae : SETG DL
006415b1 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006415b5 : MOV ESI,EDX
006415b7 : TEST ESI,ESI
006415b9 : JNZ 0x006413ad
006415bf : MOVZX ESI,byte ptr [EAX + -0xd]
006415c3 : MOVZX EDX,byte ptr [ECX + -0xd]
006415c7 : SUB ESI,EDX
006415c9 : JZ 0x006415dc
006415cb : XOR EDX,EDX
006415cd : TEST ESI,ESI
006415cf : SETG DL
006415d2 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006415d6 : MOV ESI,EDX
006415d8 : JMP 0x006415dc
006415da : XOR ESI,ESI
006415dc : TEST ESI,ESI
006415de : JNZ 0x006413ad
006415e4 : MOV EDX,dword ptr [EAX + -0xc]
006415e7 : CMP EDX,dword ptr [ECX + -0xc]
006415ea : JZ 0x0064166a
006415ec : MOVZX EDX,byte ptr [ECX + -0xc]
006415f0 : MOVZX ESI,byte ptr [EAX + -0xc]
006415f4 : SUB ESI,EDX
006415f6 : JZ 0x0064160d
006415f8 : XOR EDX,EDX
006415fa : TEST ESI,ESI
006415fc : SETG DL
006415ff : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641603 : MOV ESI,EDX
00641605 : TEST ESI,ESI
00641607 : JNZ 0x006413ad
0064160d : MOVZX ESI,byte ptr [EAX + -0xb]
00641611 : MOVZX EDX,byte ptr [ECX + -0xb]
00641615 : SUB ESI,EDX
00641617 : JZ 0x0064162e
00641619 : XOR EDX,EDX
0064161b : TEST ESI,ESI
0064161d : SETG DL
00641620 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641624 : MOV ESI,EDX
00641626 : TEST ESI,ESI
00641628 : JNZ 0x006413ad
0064162e : MOVZX ESI,byte ptr [EAX + -0xa]
00641632 : MOVZX EDX,byte ptr [ECX + -0xa]
00641636 : SUB ESI,EDX
00641638 : JZ 0x0064164f
0064163a : XOR EDX,EDX
0064163c : TEST ESI,ESI
0064163e : SETG DL
00641641 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641645 : MOV ESI,EDX
00641647 : TEST ESI,ESI
00641649 : JNZ 0x006413ad
0064164f : MOVZX ESI,byte ptr [EAX + -0x9]
00641653 : MOVZX EDX,byte ptr [ECX + -0x9]
00641657 : SUB ESI,EDX
00641659 : JZ 0x0064166c
0064165b : XOR EDX,EDX
0064165d : TEST ESI,ESI
0064165f : SETG DL
00641662 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641666 : MOV ESI,EDX
00641668 : JMP 0x0064166c
0064166a : XOR ESI,ESI
0064166c : TEST ESI,ESI
0064166e : JNZ 0x006413ad
00641674 : MOV EDX,dword ptr [EAX + -0x8]
00641677 : CMP EDX,dword ptr [ECX + -0x8]
0064167a : JZ 0x006416f9
0064167c : MOVZX ESI,DL
0064167f : MOVZX EDX,byte ptr [ECX + -0x8]
00641683 : SUB ESI,EDX
00641685 : JZ 0x0064169c
00641687 : XOR EDX,EDX
00641689 : TEST ESI,ESI
0064168b : SETG DL
0064168e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641692 : MOV ESI,EDX
00641694 : TEST ESI,ESI
00641696 : JNZ 0x006413ad
0064169c : MOVZX ESI,byte ptr [EAX + -0x7]
006416a0 : MOVZX EDX,byte ptr [ECX + -0x7]
006416a4 : SUB ESI,EDX
006416a6 : JZ 0x006416bd
006416a8 : XOR EDX,EDX
006416aa : TEST ESI,ESI
006416ac : SETG DL
006416af : LEA EDX,[EDX + EDX*0x1 + -0x1]
006416b3 : MOV ESI,EDX
006416b5 : TEST ESI,ESI
006416b7 : JNZ 0x006413ad
006416bd : MOVZX ESI,byte ptr [EAX + -0x6]
006416c1 : MOVZX EDX,byte ptr [ECX + -0x6]
006416c5 : SUB ESI,EDX
006416c7 : JZ 0x006416de
006416c9 : XOR EDX,EDX
006416cb : TEST ESI,ESI
006416cd : SETG DL
006416d0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006416d4 : MOV ESI,EDX
006416d6 : TEST ESI,ESI
006416d8 : JNZ 0x006413ad
006416de : MOVZX ESI,byte ptr [EAX + -0x5]
006416e2 : MOVZX EDX,byte ptr [ECX + -0x5]
006416e6 : SUB ESI,EDX
006416e8 : JZ 0x006416fb
006416ea : XOR EDX,EDX
006416ec : TEST ESI,ESI
006416ee : SETG DL
006416f1 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006416f5 : MOV ESI,EDX
006416f7 : JMP 0x006416fb
006416f9 : XOR ESI,ESI
006416fb : TEST ESI,ESI
006416fd : JNZ 0x006413ad
00641703 : MOV EDX,dword ptr [EAX + -0x4]
00641706 : CMP EDX,dword ptr [ECX + -0x4]
00641709 : JZ 0x0064177a
0064170b : MOVZX ESI,DL
0064170e : MOVZX EDX,byte ptr [ECX + -0x4]
00641712 : SUB ESI,EDX
00641714 : JZ 0x00641725
00641716 : XOR EDX,EDX
00641718 : TEST ESI,ESI
0064171a : SETG DL
0064171d : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641721 : TEST EDX,EDX
00641723 : JNZ 0x0064175b
00641725 : MOVZX ESI,byte ptr [EAX + -0x3]
00641729 : MOVZX EDX,byte ptr [ECX + -0x3]
0064172d : SUB ESI,EDX
0064172f : JZ 0x00641740
00641731 : XOR EDX,EDX
00641733 : TEST ESI,ESI
00641735 : SETG DL
00641738 : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064173c : TEST EDX,EDX
0064173e : JNZ 0x0064175b
00641740 : MOVZX ESI,byte ptr [EAX + -0x2]
00641744 : MOVZX EDX,byte ptr [ECX + -0x2]
00641748 : SUB ESI,EDX
0064174a : JZ 0x0064175f
0064174c : XOR EDX,EDX
0064174e : TEST ESI,ESI
00641750 : SETG DL
00641753 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641757 : TEST EDX,EDX
00641759 : JZ 0x0064175f
0064175b : MOV EAX,EDX
0064175d : JMP 0x0064177c
0064175f : MOVZX EAX,byte ptr [EAX + -0x1]
00641763 : MOVZX ECX,byte ptr [ECX + -0x1]
00641767 : SUB EAX,ECX
00641769 : JZ 0x0064177c
0064176b : XOR ECX,ECX
0064176d : TEST EAX,EAX
0064176f : SETG CL
00641772 : LEA ECX,[ECX + ECX*0x1 + -0x1]
00641776 : MOV EAX,ECX
00641778 : JMP 0x0064177c
0064177a : XOR EAX,EAX
0064177c : TEST EAX,EAX
0064177e : JNZ 0x00641782
00641780 : XOR EAX,EAX
00641782 : POP EBX
00641783 : JMP 0x006424db
00641788 : MOV EDX,dword ptr [EAX + -0x1d]
0064178b : CMP EDX,dword ptr [ECX + -0x1d]
0064178e : JZ 0x0064180d
00641790 : MOVZX ESI,DL
00641793 : MOVZX EDX,byte ptr [ECX + -0x1d]
00641797 : SUB ESI,EDX
00641799 : JZ 0x006417b0
0064179b : XOR EDX,EDX
0064179d : TEST ESI,ESI
0064179f : SETG DL
006417a2 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006417a6 : MOV ESI,EDX
006417a8 : TEST ESI,ESI
006417aa : JNZ 0x006413ad
006417b0 : MOVZX ESI,byte ptr [EAX + -0x1c]
006417b4 : MOVZX EDX,byte ptr [ECX + -0x1c]
006417b8 : SUB ESI,EDX
006417ba : JZ 0x006417d1
006417bc : XOR EDX,EDX
006417be : TEST ESI,ESI
006417c0 : SETG DL
006417c3 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006417c7 : MOV ESI,EDX
006417c9 : TEST ESI,ESI
006417cb : JNZ 0x006413ad
006417d1 : MOVZX ESI,byte ptr [EAX + -0x1b]
006417d5 : MOVZX EDX,byte ptr [ECX + -0x1b]
006417d9 : SUB ESI,EDX
006417db : JZ 0x006417f2
006417dd : XOR EDX,EDX
006417df : TEST ESI,ESI
006417e1 : SETG DL
006417e4 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006417e8 : MOV ESI,EDX
006417ea : TEST ESI,ESI
006417ec : JNZ 0x006413ad
006417f2 : MOVZX ESI,byte ptr [EAX + -0x1a]
006417f6 : MOVZX EDX,byte ptr [ECX + -0x1a]
006417fa : SUB ESI,EDX
006417fc : JZ 0x0064180f
006417fe : XOR EDX,EDX
00641800 : TEST ESI,ESI
00641802 : SETG DL
00641805 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641809 : MOV ESI,EDX
0064180b : JMP 0x0064180f
0064180d : XOR ESI,ESI
0064180f : TEST ESI,ESI
00641811 : JNZ 0x006413ad
00641817 : MOV EDX,dword ptr [EAX + -0x19]
0064181a : CMP EDX,dword ptr [ECX + -0x19]
0064181d : JZ 0x0064189c
0064181f : MOVZX ESI,DL
00641822 : MOVZX EDX,byte ptr [ECX + -0x19]
00641826 : SUB ESI,EDX
00641828 : JZ 0x0064183f
0064182a : XOR EDX,EDX
0064182c : TEST ESI,ESI
0064182e : SETG DL
00641831 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641835 : MOV ESI,EDX
00641837 : TEST ESI,ESI
00641839 : JNZ 0x006413ad
0064183f : MOVZX ESI,byte ptr [EAX + -0x18]
00641843 : MOVZX EDX,byte ptr [ECX + -0x18]
00641847 : SUB ESI,EDX
00641849 : JZ 0x00641860
0064184b : XOR EDX,EDX
0064184d : TEST ESI,ESI
0064184f : SETG DL
00641852 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641856 : MOV ESI,EDX
00641858 : TEST ESI,ESI
0064185a : JNZ 0x006413ad
00641860 : MOVZX ESI,byte ptr [EAX + -0x17]
00641864 : MOVZX EDX,byte ptr [ECX + -0x17]
00641868 : SUB ESI,EDX
0064186a : JZ 0x00641881
0064186c : XOR EDX,EDX
0064186e : TEST ESI,ESI
00641870 : SETG DL
00641873 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641877 : MOV ESI,EDX
00641879 : TEST ESI,ESI
0064187b : JNZ 0x006413ad
00641881 : MOVZX ESI,byte ptr [EAX + -0x16]
00641885 : MOVZX EDX,byte ptr [ECX + -0x16]
00641889 : SUB ESI,EDX
0064188b : JZ 0x0064189e
0064188d : XOR EDX,EDX
0064188f : TEST ESI,ESI
00641891 : SETG DL
00641894 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641898 : MOV ESI,EDX
0064189a : JMP 0x0064189e
0064189c : XOR ESI,ESI
0064189e : TEST ESI,ESI
006418a0 : JNZ 0x006413ad
006418a6 : MOV EDX,dword ptr [EAX + -0x15]
006418a9 : CMP EDX,dword ptr [ECX + -0x15]
006418ac : JZ 0x0064192b
006418ae : MOVZX ESI,DL
006418b1 : MOVZX EDX,byte ptr [ECX + -0x15]
006418b5 : SUB ESI,EDX
006418b7 : JZ 0x006418ce
006418b9 : XOR EDX,EDX
006418bb : TEST ESI,ESI
006418bd : SETG DL
006418c0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006418c4 : MOV ESI,EDX
006418c6 : TEST ESI,ESI
006418c8 : JNZ 0x006413ad
006418ce : MOVZX ESI,byte ptr [EAX + -0x14]
006418d2 : MOVZX EDX,byte ptr [ECX + -0x14]
006418d6 : SUB ESI,EDX
006418d8 : JZ 0x006418ef
006418da : XOR EDX,EDX
006418dc : TEST ESI,ESI
006418de : SETG DL
006418e1 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006418e5 : MOV ESI,EDX
006418e7 : TEST ESI,ESI
006418e9 : JNZ 0x006413ad
006418ef : MOVZX ESI,byte ptr [EAX + -0x13]
006418f3 : MOVZX EDX,byte ptr [ECX + -0x13]
006418f7 : SUB ESI,EDX
006418f9 : JZ 0x00641910
006418fb : XOR EDX,EDX
006418fd : TEST ESI,ESI
006418ff : SETG DL
00641902 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641906 : MOV ESI,EDX
00641908 : TEST ESI,ESI
0064190a : JNZ 0x006413ad
00641910 : MOVZX ESI,byte ptr [EAX + -0x12]
00641914 : MOVZX EDX,byte ptr [ECX + -0x12]
00641918 : SUB ESI,EDX
0064191a : JZ 0x0064192d
0064191c : XOR EDX,EDX
0064191e : TEST ESI,ESI
00641920 : SETG DL
00641923 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641927 : MOV ESI,EDX
00641929 : JMP 0x0064192d
0064192b : XOR ESI,ESI
0064192d : TEST ESI,ESI
0064192f : JNZ 0x006413ad
00641935 : MOV EDX,dword ptr [EAX + -0x11]
00641938 : CMP EDX,dword ptr [ECX + -0x11]
0064193b : JZ 0x006419ba
0064193d : MOVZX ESI,DL
00641940 : MOVZX EDX,byte ptr [ECX + -0x11]
00641944 : SUB ESI,EDX
00641946 : JZ 0x0064195d
00641948 : XOR EDX,EDX
0064194a : TEST ESI,ESI
0064194c : SETG DL
0064194f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641953 : MOV ESI,EDX
00641955 : TEST ESI,ESI
00641957 : JNZ 0x006413ad
0064195d : MOVZX ESI,byte ptr [EAX + -0x10]
00641961 : MOVZX EDX,byte ptr [ECX + -0x10]
00641965 : SUB ESI,EDX
00641967 : JZ 0x0064197e
00641969 : XOR EDX,EDX
0064196b : TEST ESI,ESI
0064196d : SETG DL
00641970 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641974 : MOV ESI,EDX
00641976 : TEST ESI,ESI
00641978 : JNZ 0x006413ad
0064197e : MOVZX ESI,byte ptr [EAX + -0xf]
00641982 : MOVZX EDX,byte ptr [ECX + -0xf]
00641986 : SUB ESI,EDX
00641988 : JZ 0x0064199f
0064198a : XOR EDX,EDX
0064198c : TEST ESI,ESI
0064198e : SETG DL
00641991 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641995 : MOV ESI,EDX
00641997 : TEST ESI,ESI
00641999 : JNZ 0x006413ad
0064199f : MOVZX ESI,byte ptr [EAX + -0xe]
006419a3 : MOVZX EDX,byte ptr [ECX + -0xe]
006419a7 : SUB ESI,EDX
006419a9 : JZ 0x006419bc
006419ab : XOR EDX,EDX
006419ad : TEST ESI,ESI
006419af : SETG DL
006419b2 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006419b6 : MOV ESI,EDX
006419b8 : JMP 0x006419bc
006419ba : XOR ESI,ESI
006419bc : TEST ESI,ESI
006419be : JNZ 0x006413ad
006419c4 : MOV EDX,dword ptr [EAX + -0xd]
006419c7 : CMP EDX,dword ptr [ECX + -0xd]
006419ca : JZ 0x00641a49
006419cc : MOVZX ESI,DL
006419cf : MOVZX EDX,byte ptr [ECX + -0xd]
006419d3 : SUB ESI,EDX
006419d5 : JZ 0x006419ec
006419d7 : XOR EDX,EDX
006419d9 : TEST ESI,ESI
006419db : SETG DL
006419de : LEA EDX,[EDX + EDX*0x1 + -0x1]
006419e2 : MOV ESI,EDX
006419e4 : TEST ESI,ESI
006419e6 : JNZ 0x006413ad
006419ec : MOVZX ESI,byte ptr [EAX + -0xc]
006419f0 : MOVZX EDX,byte ptr [ECX + -0xc]
006419f4 : SUB ESI,EDX
006419f6 : JZ 0x00641a0d
006419f8 : XOR EDX,EDX
006419fa : TEST ESI,ESI
006419fc : SETG DL
006419ff : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641a03 : MOV ESI,EDX
00641a05 : TEST ESI,ESI
00641a07 : JNZ 0x006413ad
00641a0d : MOVZX ESI,byte ptr [EAX + -0xb]
00641a11 : MOVZX EDX,byte ptr [ECX + -0xb]
00641a15 : SUB ESI,EDX
00641a17 : JZ 0x00641a2e
00641a19 : XOR EDX,EDX
00641a1b : TEST ESI,ESI
00641a1d : SETG DL
00641a20 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641a24 : MOV ESI,EDX
00641a26 : TEST ESI,ESI
00641a28 : JNZ 0x006413ad
00641a2e : MOVZX ESI,byte ptr [EAX + -0xa]
00641a32 : MOVZX EDX,byte ptr [ECX + -0xa]
00641a36 : SUB ESI,EDX
00641a38 : JZ 0x00641a4b
00641a3a : XOR EDX,EDX
00641a3c : TEST ESI,ESI
00641a3e : SETG DL
00641a41 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641a45 : MOV ESI,EDX
00641a47 : JMP 0x00641a4b
00641a49 : XOR ESI,ESI
00641a4b : TEST ESI,ESI
00641a4d : JNZ 0x006413ad
00641a53 : MOV EDX,dword ptr [EAX + -0x9]
00641a56 : CMP EDX,dword ptr [ECX + -0x9]
00641a59 : JZ 0x00641ad9
00641a5b : MOVZX EDX,byte ptr [ECX + -0x9]
00641a5f : MOVZX ESI,byte ptr [EAX + -0x9]
00641a63 : SUB ESI,EDX
00641a65 : JZ 0x00641a7c
00641a67 : XOR EDX,EDX
00641a69 : TEST ESI,ESI
00641a6b : SETG DL
00641a6e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641a72 : MOV ESI,EDX
00641a74 : TEST ESI,ESI
00641a76 : JNZ 0x006413ad
00641a7c : MOVZX ESI,byte ptr [EAX + -0x8]
00641a80 : MOVZX EDX,byte ptr [ECX + -0x8]
00641a84 : SUB ESI,EDX
00641a86 : JZ 0x00641a9d
00641a88 : XOR EDX,EDX
00641a8a : TEST ESI,ESI
00641a8c : SETG DL
00641a8f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641a93 : MOV ESI,EDX
00641a95 : TEST ESI,ESI
00641a97 : JNZ 0x006413ad
00641a9d : MOVZX ESI,byte ptr [EAX + -0x7]
00641aa1 : MOVZX EDX,byte ptr [ECX + -0x7]
00641aa5 : SUB ESI,EDX
00641aa7 : JZ 0x00641abe
00641aa9 : XOR EDX,EDX
00641aab : TEST ESI,ESI
00641aad : SETG DL
00641ab0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641ab4 : MOV ESI,EDX
00641ab6 : TEST ESI,ESI
00641ab8 : JNZ 0x006413ad
00641abe : MOVZX ESI,byte ptr [EAX + -0x6]
00641ac2 : MOVZX EDX,byte ptr [ECX + -0x6]
00641ac6 : SUB ESI,EDX
00641ac8 : JZ 0x00641adb
00641aca : XOR EDX,EDX
00641acc : TEST ESI,ESI
00641ace : SETG DL
00641ad1 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641ad5 : MOV ESI,EDX
00641ad7 : JMP 0x00641adb
00641ad9 : XOR ESI,ESI
00641adb : TEST ESI,ESI
00641add : JNZ 0x006413ad
00641ae3 : MOV EDX,dword ptr [EAX + -0x5]
00641ae6 : CMP EDX,dword ptr [ECX + -0x5]
00641ae9 : JZ 0x00641b68
00641aeb : MOVZX ESI,DL
00641aee : MOVZX EDX,byte ptr [ECX + -0x5]
00641af2 : SUB ESI,EDX
00641af4 : JZ 0x00641b0b
00641af6 : XOR EDX,EDX
00641af8 : TEST ESI,ESI
00641afa : SETG DL
00641afd : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641b01 : MOV ESI,EDX
00641b03 : TEST ESI,ESI
00641b05 : JNZ 0x006413ad
00641b0b : MOVZX ESI,byte ptr [EAX + -0x4]
00641b0f : MOVZX EDX,byte ptr [ECX + -0x4]
00641b13 : SUB ESI,EDX
00641b15 : JZ 0x00641b2c
00641b17 : XOR EDX,EDX
00641b19 : TEST ESI,ESI
00641b1b : SETG DL
00641b1e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641b22 : MOV ESI,EDX
00641b24 : TEST ESI,ESI
00641b26 : JNZ 0x006413ad
00641b2c : MOVZX ESI,byte ptr [EAX + -0x3]
00641b30 : MOVZX EDX,byte ptr [ECX + -0x3]
00641b34 : SUB ESI,EDX
00641b36 : JZ 0x00641b4d
00641b38 : XOR EDX,EDX
00641b3a : TEST ESI,ESI
00641b3c : SETG DL
00641b3f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641b43 : MOV ESI,EDX
00641b45 : TEST ESI,ESI
00641b47 : JNZ 0x006413ad
00641b4d : MOVZX ESI,byte ptr [EAX + -0x2]
00641b51 : MOVZX EDX,byte ptr [ECX + -0x2]
00641b55 : SUB ESI,EDX
00641b57 : JZ 0x00641b6a
00641b59 : XOR EDX,EDX
00641b5b : TEST ESI,ESI
00641b5d : SETG DL
00641b60 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641b64 : MOV ESI,EDX
00641b66 : JMP 0x00641b6a
00641b68 : XOR ESI,ESI
00641b6a : TEST ESI,ESI
00641b6c : JNZ 0x006413ad
00641b72 : MOVZX ECX,byte ptr [ECX + -0x1]
00641b76 : MOVZX EAX,byte ptr [EAX + -0x1]
00641b7a : SUB EAX,ECX
00641b7c : JZ 0x00641782
00641b82 : XOR ECX,ECX
00641b84 : TEST EAX,EAX
00641b86 : SETG CL
00641b89 : LEA ECX,[ECX + ECX*0x1 + -0x1]
00641b8d : MOV EAX,ECX
00641b8f : JMP 0x00641782
00641b94 : MOV EDX,dword ptr [EAX + -0x1e]
00641b97 : CMP EDX,dword ptr [ECX + -0x1e]
00641b9a : JZ 0x00641c19
00641b9c : MOVZX ESI,DL
00641b9f : MOVZX EDX,byte ptr [ECX + -0x1e]
00641ba3 : SUB ESI,EDX
00641ba5 : JZ 0x00641bbc
00641ba7 : XOR EDX,EDX
00641ba9 : TEST ESI,ESI
00641bab : SETG DL
00641bae : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641bb2 : MOV ESI,EDX
00641bb4 : TEST ESI,ESI
00641bb6 : JNZ 0x006413ad
00641bbc : MOVZX ESI,byte ptr [EAX + -0x1d]
00641bc0 : MOVZX EDX,byte ptr [ECX + -0x1d]
00641bc4 : SUB ESI,EDX
00641bc6 : JZ 0x00641bdd
00641bc8 : XOR EDX,EDX
00641bca : TEST ESI,ESI
00641bcc : SETG DL
00641bcf : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641bd3 : MOV ESI,EDX
00641bd5 : TEST ESI,ESI
00641bd7 : JNZ 0x006413ad
00641bdd : MOVZX ESI,byte ptr [EAX + -0x1c]
00641be1 : MOVZX EDX,byte ptr [ECX + -0x1c]
00641be5 : SUB ESI,EDX
00641be7 : JZ 0x00641bfe
00641be9 : XOR EDX,EDX
00641beb : TEST ESI,ESI
00641bed : SETG DL
00641bf0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641bf4 : MOV ESI,EDX
00641bf6 : TEST ESI,ESI
00641bf8 : JNZ 0x006413ad
00641bfe : MOVZX ESI,byte ptr [EAX + -0x1b]
00641c02 : MOVZX EDX,byte ptr [ECX + -0x1b]
00641c06 : SUB ESI,EDX
00641c08 : JZ 0x00641c1b
00641c0a : XOR EDX,EDX
00641c0c : TEST ESI,ESI
00641c0e : SETG DL
00641c11 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641c15 : MOV ESI,EDX
00641c17 : JMP 0x00641c1b
00641c19 : XOR ESI,ESI
00641c1b : TEST ESI,ESI
00641c1d : JNZ 0x006413ad
00641c23 : MOV EDX,dword ptr [EAX + -0x1a]
00641c26 : CMP EDX,dword ptr [ECX + -0x1a]
00641c29 : JZ 0x00641ca8
00641c2b : MOVZX ESI,DL
00641c2e : MOVZX EDX,byte ptr [ECX + -0x1a]
00641c32 : SUB ESI,EDX
00641c34 : JZ 0x00641c4b
00641c36 : XOR EDX,EDX
00641c38 : TEST ESI,ESI
00641c3a : SETG DL
00641c3d : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641c41 : MOV ESI,EDX
00641c43 : TEST ESI,ESI
00641c45 : JNZ 0x006413ad
00641c4b : MOVZX ESI,byte ptr [EAX + -0x19]
00641c4f : MOVZX EDX,byte ptr [ECX + -0x19]
00641c53 : SUB ESI,EDX
00641c55 : JZ 0x00641c6c
00641c57 : XOR EDX,EDX
00641c59 : TEST ESI,ESI
00641c5b : SETG DL
00641c5e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641c62 : MOV ESI,EDX
00641c64 : TEST ESI,ESI
00641c66 : JNZ 0x006413ad
00641c6c : MOVZX ESI,byte ptr [EAX + -0x18]
00641c70 : MOVZX EDX,byte ptr [ECX + -0x18]
00641c74 : SUB ESI,EDX
00641c76 : JZ 0x00641c8d
00641c78 : XOR EDX,EDX
00641c7a : TEST ESI,ESI
00641c7c : SETG DL
00641c7f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641c83 : MOV ESI,EDX
00641c85 : TEST ESI,ESI
00641c87 : JNZ 0x006413ad
00641c8d : MOVZX ESI,byte ptr [EAX + -0x17]
00641c91 : MOVZX EDX,byte ptr [ECX + -0x17]
00641c95 : SUB ESI,EDX
00641c97 : JZ 0x00641caa
00641c99 : XOR EDX,EDX
00641c9b : TEST ESI,ESI
00641c9d : SETG DL
00641ca0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641ca4 : MOV ESI,EDX
00641ca6 : JMP 0x00641caa
00641ca8 : XOR ESI,ESI
00641caa : TEST ESI,ESI
00641cac : JNZ 0x006413ad
00641cb2 : MOV EDX,dword ptr [EAX + -0x16]
00641cb5 : CMP EDX,dword ptr [ECX + -0x16]
00641cb8 : JZ 0x00641d37
00641cba : MOVZX ESI,DL
00641cbd : MOVZX EDX,byte ptr [ECX + -0x16]
00641cc1 : SUB ESI,EDX
00641cc3 : JZ 0x00641cda
00641cc5 : XOR EDX,EDX
00641cc7 : TEST ESI,ESI
00641cc9 : SETG DL
00641ccc : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641cd0 : MOV ESI,EDX
00641cd2 : TEST ESI,ESI
00641cd4 : JNZ 0x006413ad
00641cda : MOVZX ESI,byte ptr [EAX + -0x15]
00641cde : MOVZX EDX,byte ptr [ECX + -0x15]
00641ce2 : SUB ESI,EDX
00641ce4 : JZ 0x00641cfb
00641ce6 : XOR EDX,EDX
00641ce8 : TEST ESI,ESI
00641cea : SETG DL
00641ced : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641cf1 : MOV ESI,EDX
00641cf3 : TEST ESI,ESI
00641cf5 : JNZ 0x006413ad
00641cfb : MOVZX ESI,byte ptr [EAX + -0x14]
00641cff : MOVZX EDX,byte ptr [ECX + -0x14]
00641d03 : SUB ESI,EDX
00641d05 : JZ 0x00641d1c
00641d07 : XOR EDX,EDX
00641d09 : TEST ESI,ESI
00641d0b : SETG DL
00641d0e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641d12 : MOV ESI,EDX
00641d14 : TEST ESI,ESI
00641d16 : JNZ 0x006413ad
00641d1c : MOVZX ESI,byte ptr [EAX + -0x13]
00641d20 : MOVZX EDX,byte ptr [ECX + -0x13]
00641d24 : SUB ESI,EDX
00641d26 : JZ 0x00641d39
00641d28 : XOR EDX,EDX
00641d2a : TEST ESI,ESI
00641d2c : SETG DL
00641d2f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641d33 : MOV ESI,EDX
00641d35 : JMP 0x00641d39
00641d37 : XOR ESI,ESI
00641d39 : TEST ESI,ESI
00641d3b : JNZ 0x006413ad
00641d41 : MOV EDX,dword ptr [EAX + -0x12]
00641d44 : CMP EDX,dword ptr [ECX + -0x12]
00641d47 : JZ 0x00641dc6
00641d49 : MOVZX ESI,DL
00641d4c : MOVZX EDX,byte ptr [ECX + -0x12]
00641d50 : SUB ESI,EDX
00641d52 : JZ 0x00641d69
00641d54 : XOR EDX,EDX
00641d56 : TEST ESI,ESI
00641d58 : SETG DL
00641d5b : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641d5f : MOV ESI,EDX
00641d61 : TEST ESI,ESI
00641d63 : JNZ 0x006413ad
00641d69 : MOVZX ESI,byte ptr [EAX + -0x11]
00641d6d : MOVZX EDX,byte ptr [ECX + -0x11]
00641d71 : SUB ESI,EDX
00641d73 : JZ 0x00641d8a
00641d75 : XOR EDX,EDX
00641d77 : TEST ESI,ESI
00641d79 : SETG DL
00641d7c : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641d80 : MOV ESI,EDX
00641d82 : TEST ESI,ESI
00641d84 : JNZ 0x006413ad
00641d8a : MOVZX ESI,byte ptr [EAX + -0x10]
00641d8e : MOVZX EDX,byte ptr [ECX + -0x10]
00641d92 : SUB ESI,EDX
00641d94 : JZ 0x00641dab
00641d96 : XOR EDX,EDX
00641d98 : TEST ESI,ESI
00641d9a : SETG DL
00641d9d : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641da1 : MOV ESI,EDX
00641da3 : TEST ESI,ESI
00641da5 : JNZ 0x006413ad
00641dab : MOVZX ESI,byte ptr [EAX + -0xf]
00641daf : MOVZX EDX,byte ptr [ECX + -0xf]
00641db3 : SUB ESI,EDX
00641db5 : JZ 0x00641dc8
00641db7 : XOR EDX,EDX
00641db9 : TEST ESI,ESI
00641dbb : SETG DL
00641dbe : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641dc2 : MOV ESI,EDX
00641dc4 : JMP 0x00641dc8
00641dc6 : XOR ESI,ESI
00641dc8 : TEST ESI,ESI
00641dca : JNZ 0x006413ad
00641dd0 : MOV EDX,dword ptr [EAX + -0xe]
00641dd3 : CMP EDX,dword ptr [ECX + -0xe]
00641dd6 : JZ 0x00641e55
00641dd8 : MOVZX ESI,DL
00641ddb : MOVZX EDX,byte ptr [ECX + -0xe]
00641ddf : SUB ESI,EDX
00641de1 : JZ 0x00641df8
00641de3 : XOR EDX,EDX
00641de5 : TEST ESI,ESI
00641de7 : SETG DL
00641dea : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641dee : MOV ESI,EDX
00641df0 : TEST ESI,ESI
00641df2 : JNZ 0x006413ad
00641df8 : MOVZX ESI,byte ptr [EAX + -0xd]
00641dfc : MOVZX EDX,byte ptr [ECX + -0xd]
00641e00 : SUB ESI,EDX
00641e02 : JZ 0x00641e19
00641e04 : XOR EDX,EDX
00641e06 : TEST ESI,ESI
00641e08 : SETG DL
00641e0b : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641e0f : MOV ESI,EDX
00641e11 : TEST ESI,ESI
00641e13 : JNZ 0x006413ad
00641e19 : MOVZX ESI,byte ptr [EAX + -0xc]
00641e1d : MOVZX EDX,byte ptr [ECX + -0xc]
00641e21 : SUB ESI,EDX
00641e23 : JZ 0x00641e3a
00641e25 : XOR EDX,EDX
00641e27 : TEST ESI,ESI
00641e29 : SETG DL
00641e2c : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641e30 : MOV ESI,EDX
00641e32 : TEST ESI,ESI
00641e34 : JNZ 0x006413ad
00641e3a : MOVZX ESI,byte ptr [EAX + -0xb]
00641e3e : MOVZX EDX,byte ptr [ECX + -0xb]
00641e42 : SUB ESI,EDX
00641e44 : JZ 0x00641e57
00641e46 : XOR EDX,EDX
00641e48 : TEST ESI,ESI
00641e4a : SETG DL
00641e4d : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641e51 : MOV ESI,EDX
00641e53 : JMP 0x00641e57
00641e55 : XOR ESI,ESI
00641e57 : TEST ESI,ESI
00641e59 : JNZ 0x006413ad
00641e5f : MOV EDX,dword ptr [EAX + -0xa]
00641e62 : CMP EDX,dword ptr [ECX + -0xa]
00641e65 : JZ 0x00641ee5
00641e67 : MOVZX EDX,byte ptr [ECX + -0xa]
00641e6b : MOVZX ESI,byte ptr [EAX + -0xa]
00641e6f : SUB ESI,EDX
00641e71 : JZ 0x00641e88
00641e73 : XOR EDX,EDX
00641e75 : TEST ESI,ESI
00641e77 : SETG DL
00641e7a : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641e7e : MOV ESI,EDX
00641e80 : TEST ESI,ESI
00641e82 : JNZ 0x006413ad
00641e88 : MOVZX EDX,byte ptr [ECX + -0x9]
00641e8c : MOVZX ESI,byte ptr [EAX + -0x9]
00641e90 : SUB ESI,EDX
00641e92 : JZ 0x00641ea9
00641e94 : XOR EDX,EDX
00641e96 : TEST ESI,ESI
00641e98 : SETG DL
00641e9b : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641e9f : MOV ESI,EDX
00641ea1 : TEST ESI,ESI
00641ea3 : JNZ 0x006413ad
00641ea9 : MOVZX EDX,byte ptr [ECX + -0x8]
00641ead : MOVZX ESI,byte ptr [EAX + -0x8]
00641eb1 : SUB ESI,EDX
00641eb3 : JZ 0x00641eca
00641eb5 : XOR EDX,EDX
00641eb7 : TEST ESI,ESI
00641eb9 : SETG DL
00641ebc : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641ec0 : MOV ESI,EDX
00641ec2 : TEST ESI,ESI
00641ec4 : JNZ 0x006413ad
00641eca : MOVZX EDX,byte ptr [ECX + -0x7]
00641ece : MOVZX ESI,byte ptr [EAX + -0x7]
00641ed2 : SUB ESI,EDX
00641ed4 : JZ 0x00641ee7
00641ed6 : XOR EDX,EDX
00641ed8 : TEST ESI,ESI
00641eda : SETG DL
00641edd : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641ee1 : MOV ESI,EDX
00641ee3 : JMP 0x00641ee7
00641ee5 : XOR ESI,ESI
00641ee7 : TEST ESI,ESI
00641ee9 : JNZ 0x006413ad
00641eef : MOV EDX,dword ptr [EAX + -0x6]
00641ef2 : CMP EDX,dword ptr [ECX + -0x6]
00641ef5 : JZ 0x00641f74
00641ef7 : MOVZX ESI,DL
00641efa : MOVZX EDX,byte ptr [ECX + -0x6]
00641efe : SUB ESI,EDX
00641f00 : JZ 0x00641f17
00641f02 : XOR EDX,EDX
00641f04 : TEST ESI,ESI
00641f06 : SETG DL
00641f09 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641f0d : MOV ESI,EDX
00641f0f : TEST ESI,ESI
00641f11 : JNZ 0x006413ad
00641f17 : MOVZX ESI,byte ptr [EAX + -0x5]
00641f1b : MOVZX EDX,byte ptr [ECX + -0x5]
00641f1f : SUB ESI,EDX
00641f21 : JZ 0x00641f38
00641f23 : XOR EDX,EDX
00641f25 : TEST ESI,ESI
00641f27 : SETG DL
00641f2a : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641f2e : MOV ESI,EDX
00641f30 : TEST ESI,ESI
00641f32 : JNZ 0x006413ad
00641f38 : MOVZX ESI,byte ptr [EAX + -0x4]
00641f3c : MOVZX EDX,byte ptr [ECX + -0x4]
00641f40 : SUB ESI,EDX
00641f42 : JZ 0x00641f59
00641f44 : XOR EDX,EDX
00641f46 : TEST ESI,ESI
00641f48 : SETG DL
00641f4b : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641f4f : MOV ESI,EDX
00641f51 : TEST ESI,ESI
00641f53 : JNZ 0x006413ad
00641f59 : MOVZX ESI,byte ptr [EAX + -0x3]
00641f5d : MOVZX EDX,byte ptr [ECX + -0x3]
00641f61 : SUB ESI,EDX
00641f63 : JZ 0x00641f76
00641f65 : XOR EDX,EDX
00641f67 : TEST ESI,ESI
00641f69 : SETG DL
00641f6c : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641f70 : MOV ESI,EDX
00641f72 : JMP 0x00641f76
00641f74 : XOR ESI,ESI
00641f76 : TEST ESI,ESI
00641f78 : JNZ 0x006413ad
00641f7e : MOV DX,word ptr [EAX + -0x2]
00641f82 : CMP DX,word ptr [ECX + -0x2]
00641f86 : JZ 0x00641780
00641f8c : MOVZX EDX,byte ptr [ECX + -0x2]
00641f90 : MOVZX ESI,byte ptr [EAX + -0x2]
00641f94 : SUB ESI,EDX
00641f96 : JZ 0x00641b72
00641f9c : XOR EDX,EDX
00641f9e : TEST ESI,ESI
00641fa0 : SETG DL
00641fa3 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641fa7 : TEST EDX,EDX
00641fa9 : JNZ 0x006423c2
00641faf : JMP 0x00641b72
00641fb4 : MOV EDX,dword ptr [EAX + -0x1f]
00641fb7 : CMP EDX,dword ptr [ECX + -0x1f]
00641fba : JZ 0x0064203a
00641fbc : MOVZX EDX,byte ptr [ECX + -0x1f]
00641fc0 : MOVZX ESI,byte ptr [EAX + -0x1f]
00641fc4 : SUB ESI,EDX
00641fc6 : JZ 0x00641fdd
00641fc8 : XOR EDX,EDX
00641fca : TEST ESI,ESI
00641fcc : SETG DL
00641fcf : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641fd3 : MOV ESI,EDX
00641fd5 : TEST ESI,ESI
00641fd7 : JNZ 0x006413ad
00641fdd : MOVZX ESI,byte ptr [EAX + -0x1e]
00641fe1 : MOVZX EDX,byte ptr [ECX + -0x1e]
00641fe5 : SUB ESI,EDX
00641fe7 : JZ 0x00641ffe
00641fe9 : XOR EDX,EDX
00641feb : TEST ESI,ESI
00641fed : SETG DL
00641ff0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00641ff4 : MOV ESI,EDX
00641ff6 : TEST ESI,ESI
00641ff8 : JNZ 0x006413ad
00641ffe : MOVZX ESI,byte ptr [EAX + -0x1d]
00642002 : MOVZX EDX,byte ptr [ECX + -0x1d]
00642006 : SUB ESI,EDX
00642008 : JZ 0x0064201f
0064200a : XOR EDX,EDX
0064200c : TEST ESI,ESI
0064200e : SETG DL
00642011 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642015 : MOV ESI,EDX
00642017 : TEST ESI,ESI
00642019 : JNZ 0x006413ad
0064201f : MOVZX ESI,byte ptr [EAX + -0x1c]
00642023 : MOVZX EDX,byte ptr [ECX + -0x1c]
00642027 : SUB ESI,EDX
00642029 : JZ 0x0064203c
0064202b : XOR EDX,EDX
0064202d : TEST ESI,ESI
0064202f : SETG DL
00642032 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642036 : MOV ESI,EDX
00642038 : JMP 0x0064203c
0064203a : XOR ESI,ESI
0064203c : TEST ESI,ESI
0064203e : JNZ 0x006413ad
00642044 : MOV EDX,dword ptr [EAX + -0x1b]
00642047 : CMP EDX,dword ptr [ECX + -0x1b]
0064204a : JZ 0x006420c9
0064204c : MOVZX ESI,DL
0064204f : MOVZX EDX,byte ptr [ECX + -0x1b]
00642053 : SUB ESI,EDX
00642055 : JZ 0x0064206c
00642057 : XOR EDX,EDX
00642059 : TEST ESI,ESI
0064205b : SETG DL
0064205e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642062 : MOV ESI,EDX
00642064 : TEST ESI,ESI
00642066 : JNZ 0x006413ad
0064206c : MOVZX ESI,byte ptr [EAX + -0x1a]
00642070 : MOVZX EDX,byte ptr [ECX + -0x1a]
00642074 : SUB ESI,EDX
00642076 : JZ 0x0064208d
00642078 : XOR EDX,EDX
0064207a : TEST ESI,ESI
0064207c : SETG DL
0064207f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642083 : MOV ESI,EDX
00642085 : TEST ESI,ESI
00642087 : JNZ 0x006413ad
0064208d : MOVZX ESI,byte ptr [EAX + -0x19]
00642091 : MOVZX EDX,byte ptr [ECX + -0x19]
00642095 : SUB ESI,EDX
00642097 : JZ 0x006420ae
00642099 : XOR EDX,EDX
0064209b : TEST ESI,ESI
0064209d : SETG DL
006420a0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006420a4 : MOV ESI,EDX
006420a6 : TEST ESI,ESI
006420a8 : JNZ 0x006413ad
006420ae : MOVZX ESI,byte ptr [EAX + -0x18]
006420b2 : MOVZX EDX,byte ptr [ECX + -0x18]
006420b6 : SUB ESI,EDX
006420b8 : JZ 0x006420cb
006420ba : XOR EDX,EDX
006420bc : TEST ESI,ESI
006420be : SETG DL
006420c1 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006420c5 : MOV ESI,EDX
006420c7 : JMP 0x006420cb
006420c9 : XOR ESI,ESI
006420cb : TEST ESI,ESI
006420cd : JNZ 0x006413ad
006420d3 : MOV EDX,dword ptr [EAX + -0x17]
006420d6 : CMP EDX,dword ptr [ECX + -0x17]
006420d9 : JZ 0x00642158
006420db : MOVZX ESI,DL
006420de : MOVZX EDX,byte ptr [ECX + -0x17]
006420e2 : SUB ESI,EDX
006420e4 : JZ 0x006420fb
006420e6 : XOR EDX,EDX
006420e8 : TEST ESI,ESI
006420ea : SETG DL
006420ed : LEA EDX,[EDX + EDX*0x1 + -0x1]
006420f1 : MOV ESI,EDX
006420f3 : TEST ESI,ESI
006420f5 : JNZ 0x006413ad
006420fb : MOVZX ESI,byte ptr [EAX + -0x16]
006420ff : MOVZX EDX,byte ptr [ECX + -0x16]
00642103 : SUB ESI,EDX
00642105 : JZ 0x0064211c
00642107 : XOR EDX,EDX
00642109 : TEST ESI,ESI
0064210b : SETG DL
0064210e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642112 : MOV ESI,EDX
00642114 : TEST ESI,ESI
00642116 : JNZ 0x006413ad
0064211c : MOVZX ESI,byte ptr [EAX + -0x15]
00642120 : MOVZX EDX,byte ptr [ECX + -0x15]
00642124 : SUB ESI,EDX
00642126 : JZ 0x0064213d
00642128 : XOR EDX,EDX
0064212a : TEST ESI,ESI
0064212c : SETG DL
0064212f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642133 : MOV ESI,EDX
00642135 : TEST ESI,ESI
00642137 : JNZ 0x006413ad
0064213d : MOVZX ESI,byte ptr [EAX + -0x14]
00642141 : MOVZX EDX,byte ptr [ECX + -0x14]
00642145 : SUB ESI,EDX
00642147 : JZ 0x0064215a
00642149 : XOR EDX,EDX
0064214b : TEST ESI,ESI
0064214d : SETG DL
00642150 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642154 : MOV ESI,EDX
00642156 : JMP 0x0064215a
00642158 : XOR ESI,ESI
0064215a : TEST ESI,ESI
0064215c : JNZ 0x006413ad
00642162 : MOV EDX,dword ptr [EAX + -0x13]
00642165 : CMP EDX,dword ptr [ECX + -0x13]
00642168 : JZ 0x006421e7
0064216a : MOVZX ESI,DL
0064216d : MOVZX EDX,byte ptr [ECX + -0x13]
00642171 : SUB ESI,EDX
00642173 : JZ 0x0064218a
00642175 : XOR EDX,EDX
00642177 : TEST ESI,ESI
00642179 : SETG DL
0064217c : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642180 : MOV ESI,EDX
00642182 : TEST ESI,ESI
00642184 : JNZ 0x006413ad
0064218a : MOVZX ESI,byte ptr [EAX + -0x12]
0064218e : MOVZX EDX,byte ptr [ECX + -0x12]
00642192 : SUB ESI,EDX
00642194 : JZ 0x006421ab
00642196 : XOR EDX,EDX
00642198 : TEST ESI,ESI
0064219a : SETG DL
0064219d : LEA EDX,[EDX + EDX*0x1 + -0x1]
006421a1 : MOV ESI,EDX
006421a3 : TEST ESI,ESI
006421a5 : JNZ 0x006413ad
006421ab : MOVZX ESI,byte ptr [EAX + -0x11]
006421af : MOVZX EDX,byte ptr [ECX + -0x11]
006421b3 : SUB ESI,EDX
006421b5 : JZ 0x006421cc
006421b7 : XOR EDX,EDX
006421b9 : TEST ESI,ESI
006421bb : SETG DL
006421be : LEA EDX,[EDX + EDX*0x1 + -0x1]
006421c2 : MOV ESI,EDX
006421c4 : TEST ESI,ESI
006421c6 : JNZ 0x006413ad
006421cc : MOVZX ESI,byte ptr [EAX + -0x10]
006421d0 : MOVZX EDX,byte ptr [ECX + -0x10]
006421d4 : SUB ESI,EDX
006421d6 : JZ 0x006421e9
006421d8 : XOR EDX,EDX
006421da : TEST ESI,ESI
006421dc : SETG DL
006421df : LEA EDX,[EDX + EDX*0x1 + -0x1]
006421e3 : MOV ESI,EDX
006421e5 : JMP 0x006421e9
006421e7 : XOR ESI,ESI
006421e9 : TEST ESI,ESI
006421eb : JNZ 0x006413ad
006421f1 : MOV EDX,dword ptr [EAX + -0xf]
006421f4 : CMP EDX,dword ptr [ECX + -0xf]
006421f7 : JZ 0x00642277
006421f9 : MOVZX EDX,byte ptr [ECX + -0xf]
006421fd : MOVZX ESI,byte ptr [EAX + -0xf]
00642201 : SUB ESI,EDX
00642203 : JZ 0x0064221a
00642205 : XOR EDX,EDX
00642207 : TEST ESI,ESI
00642209 : SETG DL
0064220c : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642210 : MOV ESI,EDX
00642212 : TEST ESI,ESI
00642214 : JNZ 0x006413ad
0064221a : MOVZX ESI,byte ptr [EAX + -0xe]
0064221e : MOVZX EDX,byte ptr [ECX + -0xe]
00642222 : SUB ESI,EDX
00642224 : JZ 0x0064223b
00642226 : XOR EDX,EDX
00642228 : TEST ESI,ESI
0064222a : SETG DL
0064222d : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642231 : MOV ESI,EDX
00642233 : TEST ESI,ESI
00642235 : JNZ 0x006413ad
0064223b : MOVZX ESI,byte ptr [EAX + -0xd]
0064223f : MOVZX EDX,byte ptr [ECX + -0xd]
00642243 : SUB ESI,EDX
00642245 : JZ 0x0064225c
00642247 : XOR EDX,EDX
00642249 : TEST ESI,ESI
0064224b : SETG DL
0064224e : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642252 : MOV ESI,EDX
00642254 : TEST ESI,ESI
00642256 : JNZ 0x006413ad
0064225c : MOVZX ESI,byte ptr [EAX + -0xc]
00642260 : MOVZX EDX,byte ptr [ECX + -0xc]
00642264 : SUB ESI,EDX
00642266 : JZ 0x00642279
00642268 : XOR EDX,EDX
0064226a : TEST ESI,ESI
0064226c : SETG DL
0064226f : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642273 : MOV ESI,EDX
00642275 : JMP 0x00642279
00642277 : XOR ESI,ESI
00642279 : TEST ESI,ESI
0064227b : JNZ 0x006413ad
00642281 : MOV EDX,dword ptr [EAX + -0xb]
00642284 : CMP EDX,dword ptr [ECX + -0xb]
00642287 : JZ 0x00642306
00642289 : MOVZX ESI,DL
0064228c : MOVZX EDX,byte ptr [ECX + -0xb]
00642290 : SUB ESI,EDX
00642292 : JZ 0x006422a9
00642294 : XOR EDX,EDX
00642296 : TEST ESI,ESI
00642298 : SETG DL
0064229b : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064229f : MOV ESI,EDX
006422a1 : TEST ESI,ESI
006422a3 : JNZ 0x006413ad
006422a9 : MOVZX ESI,byte ptr [EAX + -0xa]
006422ad : MOVZX EDX,byte ptr [ECX + -0xa]
006422b1 : SUB ESI,EDX
006422b3 : JZ 0x006422ca
006422b5 : XOR EDX,EDX
006422b7 : TEST ESI,ESI
006422b9 : SETG DL
006422bc : LEA EDX,[EDX + EDX*0x1 + -0x1]
006422c0 : MOV ESI,EDX
006422c2 : TEST ESI,ESI
006422c4 : JNZ 0x006413ad
006422ca : MOVZX ESI,byte ptr [EAX + -0x9]
006422ce : MOVZX EDX,byte ptr [ECX + -0x9]
006422d2 : SUB ESI,EDX
006422d4 : JZ 0x006422eb
006422d6 : XOR EDX,EDX
006422d8 : TEST ESI,ESI
006422da : SETG DL
006422dd : LEA EDX,[EDX + EDX*0x1 + -0x1]
006422e1 : MOV ESI,EDX
006422e3 : TEST ESI,ESI
006422e5 : JNZ 0x006413ad
006422eb : MOVZX ESI,byte ptr [EAX + -0x8]
006422ef : MOVZX EDX,byte ptr [ECX + -0x8]
006422f3 : SUB ESI,EDX
006422f5 : JZ 0x00642308
006422f7 : XOR EDX,EDX
006422f9 : TEST ESI,ESI
006422fb : SETG DL
006422fe : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642302 : MOV ESI,EDX
00642304 : JMP 0x00642308
00642306 : XOR ESI,ESI
00642308 : TEST ESI,ESI
0064230a : JNZ 0x006413ad
00642310 : MOV EDX,dword ptr [EAX + -0x7]
00642313 : CMP EDX,dword ptr [ECX + -0x7]
00642316 : JZ 0x00642395
00642318 : MOVZX ESI,DL
0064231b : MOVZX EDX,byte ptr [ECX + -0x7]
0064231f : SUB ESI,EDX
00642321 : JZ 0x00642338
00642323 : XOR EDX,EDX
00642325 : TEST ESI,ESI
00642327 : SETG DL
0064232a : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064232e : MOV ESI,EDX
00642330 : TEST ESI,ESI
00642332 : JNZ 0x006413ad
00642338 : MOVZX ESI,byte ptr [EAX + -0x6]
0064233c : MOVZX EDX,byte ptr [ECX + -0x6]
00642340 : SUB ESI,EDX
00642342 : JZ 0x00642359
00642344 : XOR EDX,EDX
00642346 : TEST ESI,ESI
00642348 : SETG DL
0064234b : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064234f : MOV ESI,EDX
00642351 : TEST ESI,ESI
00642353 : JNZ 0x006413ad
00642359 : MOVZX ESI,byte ptr [EAX + -0x5]
0064235d : MOVZX EDX,byte ptr [ECX + -0x5]
00642361 : SUB ESI,EDX
00642363 : JZ 0x0064237a
00642365 : XOR EDX,EDX
00642367 : TEST ESI,ESI
00642369 : SETG DL
0064236c : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642370 : MOV ESI,EDX
00642372 : TEST ESI,ESI
00642374 : JNZ 0x006413ad
0064237a : MOVZX ESI,byte ptr [EAX + -0x4]
0064237e : MOVZX EDX,byte ptr [ECX + -0x4]
00642382 : SUB ESI,EDX
00642384 : JZ 0x00642397
00642386 : XOR EDX,EDX
00642388 : TEST ESI,ESI
0064238a : SETG DL
0064238d : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642391 : MOV ESI,EDX
00642393 : JMP 0x00642397
00642395 : XOR ESI,ESI
00642397 : TEST ESI,ESI
00642399 : JNZ 0x006413ad
0064239f : MOVZX ESI,byte ptr [EAX + -0x3]
006423a3 : MOVZX EDX,byte ptr [ECX + -0x3]
006423a7 : SUB ESI,EDX
006423a9 : JZ 0x00641f8c
006423af : XOR EDX,EDX
006423b1 : TEST ESI,ESI
006423b3 : SETG DL
006423b6 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006423ba : TEST EDX,EDX
006423bc : JZ 0x00641f8c
006423c2 : MOV EAX,EDX
006423c4 : JMP 0x00641782
006423c9 : MOV ECX,dword ptr [EBP + 0x8]
006423cc : MOV ESI,dword ptr [EBP + 0xc]
006423cf : MOVZX EAX,byte ptr [ECX]
006423d2 : MOVZX EDX,byte ptr [ESI]
006423d5 : SUB EAX,EDX
006423d7 : JZ 0x006423ee
006423d9 : XOR EDX,EDX
006423db : TEST EAX,EAX
006423dd : SETG DL
006423e0 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006423e4 : MOV EAX,EDX
006423e6 : TEST EAX,EAX
006423e8 : JNZ 0x006424db
006423ee : MOVZX EAX,byte ptr [ECX + 0x1]
006423f2 : MOVZX EDX,byte ptr [ESI + 0x1]
006423f6 : SUB EAX,EDX
006423f8 : JZ 0x0064240f
006423fa : XOR EDX,EDX
006423fc : TEST EAX,EAX
006423fe : SETG DL
00642401 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642405 : MOV EAX,EDX
00642407 : TEST EAX,EAX
00642409 : JNZ 0x006424db
0064240f : MOVZX EAX,byte ptr [ECX + 0x2]
00642413 : MOVZX EDX,byte ptr [ESI + 0x2]
00642417 : SUB EAX,EDX
00642419 : JZ 0x00642430
0064241b : XOR EDX,EDX
0064241d : TEST EAX,EAX
0064241f : SETG DL
00642422 : LEA EDX,[EDX + EDX*0x1 + -0x1]
00642426 : MOV EAX,EDX
00642428 : TEST EAX,EAX
0064242a : JNZ 0x006424db
00642430 : MOVZX EAX,byte ptr [ECX + 0x3]
00642434 : MOVZX ECX,byte ptr [ESI + 0x3]
00642438 : SUB EAX,ECX
0064243a : JZ 0x006424db
00642440 : XOR ECX,ECX
00642442 : TEST EAX,EAX
00642444 : SETG CL
00642447 : LEA ECX,[ECX + ECX*0x1 + -0x1]
0064244b : MOV EAX,ECX
0064244d : JMP 0x006424db
00642452 : MOV ECX,dword ptr [EBP + 0x8]
00642455 : MOV ESI,dword ptr [EBP + 0xc]
00642458 : MOVZX EAX,byte ptr [ECX]
0064245b : MOVZX EDX,byte ptr [ESI]
0064245e : SUB EAX,EDX
00642460 : JZ 0x00642473
00642462 : XOR EDX,EDX
00642464 : TEST EAX,EAX
00642466 : SETG DL
00642469 : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064246d : MOV EAX,EDX
0064246f : TEST EAX,EAX
00642471 : JNZ 0x006424db
00642473 : MOVZX EAX,byte ptr [ECX + 0x1]
00642477 : MOVZX EDX,byte ptr [ESI + 0x1]
0064247b : SUB EAX,EDX
0064247d : JZ 0x00642490
0064247f : XOR EDX,EDX
00642481 : TEST EAX,EAX
00642483 : SETG DL
00642486 : LEA EDX,[EDX + EDX*0x1 + -0x1]
0064248a : MOV EAX,EDX
0064248c : TEST EAX,EAX
0064248e : JNZ 0x006424db
00642490 : MOVZX EAX,byte ptr [ECX + 0x2]
00642494 : MOVZX ECX,byte ptr [ESI + 0x2]
00642498 : JMP 0x00642438
0064249a : MOV ECX,dword ptr [EBP + 0x8]
0064249d : MOV ESI,dword ptr [EBP + 0xc]
006424a0 : MOVZX EAX,byte ptr [ECX]
006424a3 : MOVZX EDX,byte ptr [ESI]
006424a6 : SUB EAX,EDX
006424a8 : JZ 0x006424bb
006424aa : XOR EDX,EDX
006424ac : TEST EAX,EAX
006424ae : SETG DL
006424b1 : LEA EDX,[EDX + EDX*0x1 + -0x1]
006424b5 : MOV EAX,EDX
006424b7 : TEST EAX,EAX
006424b9 : JNZ 0x006424db
006424bb : MOVZX EAX,byte ptr [ECX + 0x1]
006424bf : MOVZX ECX,byte ptr [ESI + 0x1]
006424c3 : JMP 0x00642438
006424c8 : MOV EAX,dword ptr [EBP + 0x8]
006424cb : MOV ECX,dword ptr [EBP + 0xc]
006424ce : MOVZX EAX,byte ptr [EAX]
006424d1 : MOVZX ECX,byte ptr [ECX]
006424d4 : JMP 0x00642438
006424d9 : XOR EAX,EAX
006424db : POP EDI
006424dc : POP ESI
006424dd : POP EBP
006424de : RET
