PROGRAM  : Maestia.exe
FUNCTION : FUN_00466430
ENTRY    : 00466430
BODY     : [[00466430, 0046684d]]

============================================================
DECOMPILED C CODE
============================================================

byte FUN_00466430(int param_1,short param_2)

{
  int iVar1;
  int *piVar2;
  bool bVar3;
  char cVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  int in_EAX;
  int iVar8;
  int iVar9;
  int iVar10;
  int *piVar11;
  int iVar12;
  int iVar13;
  int *piVar14;
  int iVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  int local_28;
  int local_24;
  int local_c;
  bool local_6;
  byte local_5;
  
  local_5 = 0;
  if ((*(int *)(param_1 + 4) == 0) || (*(int *)(param_1 + 0x10) == 0)) {
    return 1;
  }
  cVar4 = FUN_0046c730();
  if (cVar4 != '\0') {
    iVar13 = *(int *)(param_1 + 4);
    local_5 = 1;
    bVar3 = false;
    local_28 = 0;
    if (0 < *(int *)(iVar13 + 8)) {
      do {
        iVar13 = *(int *)(*(int *)(iVar13 + 4) + local_28 * 4);
        if (((*(char *)(iVar13 + 0x1f5) != '\0') && (iVar8 = FUN_0046c9c0(local_28), iVar8 != 0)) &&
           (iVar1 = *(int *)(iVar8 + 8), iVar1 != 0)) {
          if (!bVar3) {
            bVar5 = FUN_0046ab70();
            local_5 = local_5 & bVar5;
            bVar3 = true;
          }
          bVar5 = FUN_0046ab90();
          iVar9 = (**(code **)(*DAT_01720efc + 0x1a0))(DAT_01720efc,*(undefined4 *)(iVar13 + 0xf50))
          ;
          local_5 = local_5 & bVar5 & iVar9 == 0;
          *(int *)(in_EAX + 0x747c) = *(int *)(in_EAX + 0x747c) + 1;
          FUN_0046a440();
          if (0 < iVar1) {
            iVar10 = 0;
            iVar9 = iVar1;
            do {
              if (*(char *)(*(char *)(iVar10 + 0x1d + *(int *)(iVar8 + 4)) + 1 +
                           *(int *)(iVar13 + 0xe20)) != '\0') {
                *(int *)(in_EAX + 0x7470) = *(int *)(in_EAX + 0x7470) + 1;
              }
              iVar10 = iVar10 + 0x20;
              iVar9 = iVar9 + -1;
            } while (iVar9 != 0);
          }
          piVar11 = *(int **)(iVar13 + 0xe34);
          if (piVar11 != piVar11 + *(int *)(iVar13 + 0xe38)) {
            do {
              iVar9 = *piVar11;
              iVar15 = iVar9 * 0x1128 + *(int *)(iVar13 + 0xda8);
              iVar10 = FUN_0046a050(in_EAX,iVar15,0);
              if (0 < iVar10) {
                *(int *)(in_EAX + 0x7474) = *(int *)(in_EAX + 0x7474) + iVar10;
              }
              iVar10 = *(int *)(iVar15 + 0x58);
              cVar4 = (**(code **)(*(int *)PTR_DAT_00d6df20 + 4))();
              if (cVar4 != '\0') {
                iVar10 = *(int *)(&DAT_00d72c28 + iVar10 * 4);
              }
              if (iVar10 == 2) {
                uVar16 = 2;
              }
              else if (iVar10 == 1) {
                uVar16 = 3;
              }
              else {
                uVar16 = 1;
              }
              (**(code **)(*DAT_01720efc + 0xe4))(DAT_01720efc,0x16,uVar16);
              if (0 < iVar1) {
                local_c = 0;
                local_24 = iVar1;
                do {
                  piVar14 = (int *)(*(int *)(iVar8 + 4) + local_c);
                  if (-1 < *(char *)((int)piVar14 + 0x1d)) {
                    iVar10 = *piVar14;
                    if (param_2 == 1) {
                      if (*(char *)(iVar10 + 0x12d) == '\0') {
LAB_00466618:
                        iVar12 = *(int *)(iVar13 + 0xe00) * iVar9 +
                                 (int)*(char *)((int)piVar14 + 0x1d);
                        iVar15 = *(int *)(iVar13 + 0xe0c) + iVar12 * 0x14;
                        if (*(int *)(*(int *)(iVar13 + 0xe0c) + iVar12 * 0x14) != -1) {
                          local_6 = false;
                          if (*(int *)(in_EAX + 0x32b8) != 0) {
                            piVar2 = *(int **)(*(int *)(in_EAX + 0x32c0) + 0xc);
                            iVar12 = (**(code **)(*piVar2 + 0x4c))
                                               (piVar2,DAT_01720efc,*(int *)(in_EAX + 0x32b8),iVar10
                                               );
                            local_6 = -1 < iVar12;
                          }
                          if (*(int *)(in_EAX + 0x32bc) != 0) {
                            piVar2 = *(int **)(*(int *)(in_EAX + 0x32c0) + 0x10);
                            iVar12 = (**(code **)(*piVar2 + 0x4c))
                                               (piVar2,DAT_01720efc,*(int *)(in_EAX + 0x32bc),iVar10
                                               );
                            local_6 = -1 < iVar12;
                          }
                          bVar5 = FUN_0046c3b0((float)(int)*(char *)(iVar10 + 0x21) * 0.007874016,
                                               piVar14[4],piVar14[2]);
                          if (*(char *)(iVar10 + 300) == '\0') {
                            uVar16 = 0;
                            uVar17 = 0;
                          }
                          else {
                            uVar16 = *(undefined4 *)(iVar10 + 0x134);
                            uVar17 = *(undefined4 *)(iVar10 + 0x138);
                          }
                          bVar6 = FUN_0046c4d0(uVar16,uVar17);
                          if (*(char *)(iVar10 + 0x12d) == '\0') {
                            uVar16 = 0x3f800000;
                          }
                          else {
                            uVar16 = 0x3e99999a;
                          }
                          FUN_0046c5e0(uVar16);
                          if (*(int *)(iVar15 + 8) == 0) {
                            bVar7 = 0;
                          }
                          else {
                            bVar7 = FUN_0046c640(*(undefined4 *)(iVar15 + 4),
                                                 *(undefined4 *)(iVar15 + 0xc),
                                                 *(undefined4 *)(iVar15 + 0x10));
                          }
                          local_5 = local_5 & bVar5 & local_6 & bVar6 & bVar7;
                          *(int *)(in_EAX + 0x7478) = *(int *)(in_EAX + 0x7478) + 1;
                          *(int *)(in_EAX + 0x7480) =
                               *(int *)(in_EAX + 0x7480) + *(uint *)(iVar15 + 8) / 3;
                        }
                      }
                    }
                    else if ((param_2 != 2) || (*(char *)(iVar10 + 0x12d) != '\0'))
                    goto LAB_00466618;
                  }
                  local_c = local_c + 0x20;
                  local_24 = local_24 + -1;
                } while (local_24 != 0);
              }
              piVar11 = piVar11 + 1;
            } while (piVar11 != (int *)(*(int *)(iVar13 + 0xe34) + *(int *)(iVar13 + 0xe38) * 4));
          }
          iVar13 = (**(code **)(*DAT_01720efc + 400))(DAT_01720efc,0,0,0,0);
          iVar8 = (**(code **)(*DAT_01720efc + 0x1a0))(DAT_01720efc,0);
          local_5 = local_5 & iVar13 == 0 & iVar8 == 0;
        }
        iVar13 = *(int *)(param_1 + 4);
        local_28 = local_28 + 1;
      } while (local_28 < *(int *)(iVar13 + 8));
    }
    (**(code **)(*DAT_01720efc + 0x170))(DAT_01720efc,0);
    (**(code **)(*DAT_01720efc + 0x1ac))(DAT_01720efc,0);
  }
  return local_5;
}



============================================================
DISASSEMBLY
============================================================
00466430 : PUSH EBP
00466431 : MOV EBP,ESP
00466433 : SUB ESP,0x2c
00466436 : PUSH EBX
00466437 : MOV EBX,dword ptr [EBP + 0x8]
0046643a : CMP dword ptr [EBX + 0x4],0x0
0046643e : PUSH ESI
0046643f : PUSH EDI
00466440 : MOV EDI,EAX
00466442 : MOV byte ptr [EBP + -0x1],0x0
00466446 : JZ 0x00466843
0046644c : CMP dword ptr [EBX + 0x10],0x0
00466450 : JZ 0x00466843
00466456 : LEA EAX,[EDI + 0x188c]
0046645c : CALL 0x0046c730
00466461 : TEST AL,AL
00466463 : JZ 0x00466837
00466469 : MOV EAX,dword ptr [EBX + 0x4]
0046646c : XOR ESI,ESI
0046646e : CMP dword ptr [EAX + 0x8],ESI
00466471 : MOV byte ptr [EBP + -0x1],0x1
00466475 : MOV byte ptr [EBP + -0x3],0x0
00466479 : MOV dword ptr [EBP + -0x24],ESI
0046647c : JLE 0x0046680f
00466482 : MOV EAX,dword ptr [EAX + 0x4]
00466485 : MOV EBX,dword ptr [EAX + ESI*0x4]
00466488 : CMP byte ptr [EBX + 0x1f5],0x0
0046648f : MOV dword ptr [EBP + -0x1c],EBX
00466492 : JZ 0x004667f2
00466498 : MOV EAX,dword ptr [EBP + 0x8]
0046649b : PUSH ESI
0046649c : CALL 0x0046c9c0
004664a1 : MOV dword ptr [EBP + -0x14],EAX
004664a4 : TEST EAX,EAX
004664a6 : JZ 0x004667f2
004664ac : MOV EAX,dword ptr [EAX + 0x8]
004664af : MOV dword ptr [EBP + -0x10],EAX
004664b2 : TEST EAX,EAX
004664b4 : JZ 0x004667f2
004664ba : CMP byte ptr [EBP + -0x3],0x0
004664be : LEA ESI,[EBX + 0xf40]
004664c4 : JNZ 0x004664d4
004664c6 : MOV EDX,ESI
004664c8 : CALL 0x0046ab70
004664cd : AND byte ptr [EBP + -0x1],AL
004664d0 : MOV byte ptr [EBP + -0x3],0x1
004664d4 : MOV ECX,ESI
004664d6 : CALL 0x0046ab90
004664db : AND byte ptr [EBP + -0x1],AL
004664de : MOV EAX,[0x01720efc]
004664e3 : MOV EDX,dword ptr [ESI + 0x10]
004664e6 : MOV ECX,dword ptr [EAX]
004664e8 : PUSH EDX
004664e9 : PUSH EAX
004664ea : MOV EAX,dword ptr [ECX + 0x1a0]
004664f0 : CALL EAX
004664f2 : TEST EAX,EAX
004664f4 : SETZ CL
004664f7 : AND byte ptr [EBP + -0x1],CL
004664fa : INC dword ptr [EDI + 0x747c]
00466500 : MOV ESI,EBX
00466502 : CALL 0x0046a440
00466507 : MOV ECX,dword ptr [EBP + -0x10]
0046650a : TEST ECX,ECX
0046650c : JLE 0x00466536
0046650e : XOR EAX,EAX
00466510 : MOV EDX,dword ptr [EBP + -0x14]
00466513 : MOV EDX,dword ptr [EDX + 0x4]
00466516 : MOVSX EDX,byte ptr [EAX + EDX*0x1 + 0x1d]
0046651b : MOV ESI,dword ptr [EBX + 0xe20]
00466521 : CMP byte ptr [EDX + ESI*0x1 + 0x1],0x0
00466526 : JZ 0x0046652e
00466528 : INC dword ptr [EDI + 0x7470]
0046652e : ADD EAX,0x20
00466531 : SUB ECX,0x1
00466534 : JNZ 0x00466510
00466536 : MOV EAX,dword ptr [EBX + 0xe34]
0046653c : MOV ECX,dword ptr [EBX + 0xe38]
00466542 : LEA EDX,[EAX + ECX*0x4]
00466545 : MOV dword ptr [EBP + -0xc],EAX
00466548 : CMP EAX,EDX
0046654a : JZ 0x004667b1
00466550 : JMP 0x00466555
00466552 : MOV EAX,dword ptr [EBP + -0xc]
00466555 : MOV ESI,dword ptr [EAX]
00466557 : MOV dword ptr [EBP + -0x28],ESI
0046655a : IMUL ESI,ESI,0x1128
00466560 : ADD ESI,dword ptr [EBX + 0xda8]
00466566 : PUSH 0x0
00466568 : PUSH ESI
00466569 : PUSH EDI
0046656a : CALL 0x0046a050
0046656f : TEST EAX,EAX
00466571 : JLE 0x0046657d
00466573 : AND byte ptr [EBP + -0x1],0x1
00466577 : ADD dword ptr [EDI + 0x7474],EAX
0046657d : MOV ECX,dword ptr [0x00d6df20]
00466583 : MOV EAX,dword ptr [ECX]
00466585 : MOV EDX,dword ptr [EAX + 0x4]
00466588 : MOV ESI,dword ptr [ESI + 0x58]
0046658b : CALL EDX
0046658d : TEST AL,AL
0046658f : JZ 0x00466598
00466591 : MOV ESI,dword ptr [ESI*0x4 + 0xd72c28]
00466598 : CMP ESI,0x2
0046659b : JNZ 0x004665a0
0046659d : PUSH ESI
0046659e : JMP 0x004665ab
004665a0 : CMP ESI,0x1
004665a3 : JNZ 0x004665a9
004665a5 : PUSH 0x3
004665a7 : JMP 0x004665ab
004665a9 : PUSH 0x1
004665ab : MOV EAX,[0x01720efc]
004665b0 : MOV ECX,dword ptr [EAX]
004665b2 : MOV EDX,dword ptr [ECX + 0xe4]
004665b8 : PUSH 0x16
004665ba : PUSH EAX
004665bb : CALL EDX
004665bd : MOV EAX,dword ptr [EBP + -0x10]
004665c0 : TEST EAX,EAX
004665c2 : JLE 0x00466791
004665c8 : MOV dword ptr [EBP + -0x8],0x0
004665cf : MOV dword ptr [EBP + -0x20],EAX
004665d2 : MOV EAX,dword ptr [EBP + -0x14]
004665d5 : MOV ECX,dword ptr [EAX + 0x4]
004665d8 : ADD ECX,dword ptr [EBP + -0x8]
004665db : MOV DL,byte ptr [ECX + 0x1d]
004665de : CMP DL,0xff
004665e1 : MOV dword ptr [EBP + -0x18],ECX
004665e4 : JLE 0x00466783
004665ea : MOV AX,word ptr [EBP + 0xc]
004665ee : MOV ESI,dword ptr [ECX]
004665f0 : CMP AX,0x1
004665f4 : JNZ 0x00466605
004665f6 : CMP byte ptr [ESI + 0x12d],0x0
004665fd : JNZ 0x00466783
00466603 : JMP 0x00466618
00466605 : CMP AX,0x2
00466609 : JNZ 0x00466618
0046660b : CMP byte ptr [ESI + 0x12d],0x0
00466612 : JZ 0x00466783
00466618 : MOV EAX,dword ptr [EBX + 0xe00]
0046661e : IMUL EAX,dword ptr [EBP + -0x28]
00466622 : MOVSX EDX,DL
00466625 : ADD EAX,EDX
00466627 : MOV EDX,dword ptr [EBX + 0xe0c]
0046662d : LEA EAX,[EAX + EAX*0x4]
00466630 : CMP dword ptr [EDX + EAX*0x4],-0x1
00466634 : LEA EBX,[EDX + EAX*0x4]
00466637 : JZ 0x00466780
0046663d : MOV EDX,dword ptr [EDI + 0x32b8]
00466643 : MOV byte ptr [EBP + -0x2],0x0
00466647 : TEST EDX,EDX
00466649 : JZ 0x0046666e
0046664b : MOV EAX,dword ptr [EDI + 0x32c0]
00466651 : MOV EAX,dword ptr [EAX + 0xc]
00466654 : MOV ECX,dword ptr [EAX]
00466656 : PUSH ESI
00466657 : PUSH EDX
00466658 : MOV EDX,dword ptr [0x01720efc]
0046665e : PUSH EDX
0046665f : PUSH EAX
00466660 : MOV EAX,dword ptr [ECX + 0x4c]
00466663 : CALL EAX
00466665 : MOV ECX,dword ptr [EBP + -0x18]
00466668 : TEST EAX,EAX
0046666a : SETGE byte ptr [EBP + -0x2]
0046666e : MOV EDX,dword ptr [EDI + 0x32bc]
00466674 : TEST EDX,EDX
00466676 : JZ 0x0046669b
00466678 : MOV ECX,dword ptr [EDI + 0x32c0]
0046667e : MOV EAX,dword ptr [ECX + 0x10]
00466681 : MOV ECX,dword ptr [EAX]
00466683 : PUSH ESI
00466684 : PUSH EDX
00466685 : MOV EDX,dword ptr [0x01720efc]
0046668b : PUSH EDX
0046668c : PUSH EAX
0046668d : MOV EAX,dword ptr [ECX + 0x4c]
00466690 : CALL EAX
00466692 : MOV ECX,dword ptr [EBP + -0x18]
00466695 : TEST EAX,EAX
00466697 : SETGE byte ptr [EBP + -0x2]
0046669b : MOVSX EAX,byte ptr [ESI + 0x21]
0046669f : MOVSX EDX,byte ptr [ESI + 0x20]
004666a3 : MOV dword ptr [EBP + -0x18],EAX
004666a6 : SUB ESP,0xc
004666a9 : CVTSI2SS XMM0,EDX
004666ad : FILD dword ptr [EBP + -0x18]
004666b0 : MULSS XMM0,dword ptr [0x00cdf310]
004666b8 : LEA EAX,[EDI + 0x33cc]
004666be : FMUL float ptr [0x00cdf310]
004666c4 : FLD float ptr [ECX + 0x10]
004666c7 : FLD float ptr [ECX + 0x8]
004666ca : FSTP float ptr [ESP + 0x8]
004666ce : FSTP float ptr [ESP + 0x4]
004666d2 : FSTP float ptr [ESP]
004666d5 : CALL 0x0046c3b0
004666da : AND AL,byte ptr [EBP + -0x2]
004666dd : SUB ESP,0x8
004666e0 : AND byte ptr [EBP + -0x1],AL
004666e3 : CMP byte ptr [ESI + 0x12c],0x0
004666ea : LEA EAX,[EDI + 0x6778]
004666f0 : JZ 0x0046670c
004666f2 : FLD float ptr [ESI + 0x134]
004666f8 : MOVSS XMM0,dword ptr [ESI + 0x130]
00466700 : FLD float ptr [ESI + 0x138]
00466706 : FSTP float ptr [ESP + 0x4]
0046670a : JMP 0x00466715
0046670c : FLDZ
0046670e : XORPS XMM0,XMM0
00466711 : FST float ptr [ESP + 0x4]
00466715 : FSTP float ptr [ESP]
00466718 : CALL 0x0046c4d0
0046671d : AND byte ptr [EBP + -0x1],AL
00466720 : CMP byte ptr [ESI + 0x12d],0x0
00466727 : PUSH ECX
00466728 : LEA ESI,[EDI + 0x6890]
0046672e : JZ 0x00466738
00466730 : FLD float ptr [0x00cdf0e8]
00466736 : JMP 0x0046673a
00466738 : FLD1
0046673a : FSTP float ptr [ESP]
0046673d : CALL 0x0046c5e0
00466742 : MOV ECX,dword ptr [EBX + 0x8]
00466745 : AND byte ptr [EBP + -0x1],0x1
00466749 : MOV EAX,dword ptr [EBX + 0x10]
0046674c : MOV EDX,dword ptr [EBX + 0xc]
0046674f : MOV ESI,dword ptr [EBX + 0x4]
00466752 : TEST ECX,ECX
00466754 : JBE 0x00466765
00466756 : PUSH EAX
00466757 : PUSH EDX
00466758 : PUSH ESI
00466759 : MOV EAX,0x6
0046675e : CALL 0x0046c640
00466763 : JMP 0x00466767
00466765 : XOR AL,AL
00466767 : AND byte ptr [EBP + -0x1],AL
0046676a : INC dword ptr [EDI + 0x7478]
00466770 : MOV EAX,0xaaaaaaab
00466775 : MUL dword ptr [EBX + 0x8]
00466778 : SHR EDX,0x1
0046677a : ADD dword ptr [EDI + 0x7480],EDX
00466780 : MOV EBX,dword ptr [EBP + -0x1c]
00466783 : ADD dword ptr [EBP + -0x8],0x20
00466787 : SUB dword ptr [EBP + -0x20],0x1
0046678b : JNZ 0x004665d2
00466791 : MOV EAX,dword ptr [EBP + -0xc]
00466794 : MOV ECX,dword ptr [EBX + 0xe38]
0046679a : MOV EDX,dword ptr [EBX + 0xe34]
004667a0 : ADD EAX,0x4
004667a3 : LEA ECX,[EDX + ECX*0x4]
004667a6 : MOV dword ptr [EBP + -0xc],EAX
004667a9 : CMP EAX,ECX
004667ab : JNZ 0x00466552
004667b1 : MOV EAX,[0x01720efc]
004667b6 : MOV EDX,dword ptr [EAX]
004667b8 : PUSH 0x0
004667ba : PUSH 0x0
004667bc : PUSH 0x0
004667be : PUSH 0x0
004667c0 : PUSH EAX
004667c1 : MOV EAX,dword ptr [EDX + 0x190]
004667c7 : CALL EAX
004667c9 : MOV BL,byte ptr [EBP + -0x1]
004667cc : TEST EAX,EAX
004667ce : MOV EAX,[0x01720efc]
004667d3 : MOV EDX,dword ptr [EAX]
004667d5 : PUSH 0x0
004667d7 : SETZ CL
004667da : PUSH EAX
004667db : MOV EAX,dword ptr [EDX + 0x1a0]
004667e1 : AND BL,CL
004667e3 : CALL EAX
004667e5 : MOV ESI,dword ptr [EBP + -0x24]
004667e8 : TEST EAX,EAX
004667ea : SETZ CL
004667ed : AND BL,CL
004667ef : MOV byte ptr [EBP + -0x1],BL
004667f2 : MOV EDX,dword ptr [EBP + 0x8]
004667f5 : MOV EAX,dword ptr [EDX + 0x4]
004667f8 : INC ESI
004667f9 : CMP ESI,dword ptr [EAX + 0x8]
004667fc : MOV dword ptr [EBP + -0x24],ESI
004667ff : JL 0x00466482
00466805 : CMP byte ptr [EBP + -0x3],0x0
00466809 : JZ 0x0046680f
0046680b : AND byte ptr [EBP + -0x1],0x1
0046680f : MOV EAX,[0x01720efc]
00466814 : MOV ECX,dword ptr [EAX]
00466816 : MOV EDX,dword ptr [ECX + 0x170]
0046681c : PUSH 0x0
0046681e : PUSH EAX
0046681f : CALL EDX
00466821 : MOV EAX,[0x01720efc]
00466826 : MOV ECX,dword ptr [EAX]
00466828 : MOV EDX,dword ptr [ECX + 0x1ac]
0046682e : PUSH 0x0
00466830 : PUSH EAX
00466831 : CALL EDX
00466833 : AND byte ptr [EBP + -0x1],0x1
00466837 : MOV AL,byte ptr [EBP + -0x1]
0046683a : POP EDI
0046683b : POP ESI
0046683c : POP EBX
0046683d : MOV ESP,EBP
0046683f : POP EBP
00466840 : RET 0x8
00466843 : POP EDI
00466844 : POP ESI
00466845 : MOV AL,0x1
00466847 : POP EBX
00466848 : MOV ESP,EBP
0046684a : POP EBP
0046684b : RET 0x8
