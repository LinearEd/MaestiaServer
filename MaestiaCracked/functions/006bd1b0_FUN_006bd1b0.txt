PROGRAM  : Maestia.exe
FUNCTION : FUN_006bd1b0
ENTRY    : 006bd1b0
BODY     : [[006bd1b0, 006bd1fc] [006bd200, 006bd675]]

============================================================
DECOMPILED C CODE
============================================================

byte * FUN_006bd1b0(int param_1,int param_2)

{
  int *piVar1;
  byte bVar2;
  undefined1 uVar3;
  byte *pbVar4;
  undefined4 uVar5;
  int iVar6;
  int iVar7;
  byte *pbVar8;
  uint uVar9;
  int iVar10;
  byte *pbVar11;
  int iVar12;
  byte *pbVar13;
  byte *pbVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  byte *pbVar18;
  byte *local_1c;
  int local_18;
  int local_10;
  
  iVar7 = param_1 + 0x30 + param_2 * 0x1c;
  pbVar4 = *(byte **)(iVar7 + 0x14);
  pbVar11 = pbVar4 + *(int *)(iVar7 + 0xc) * 0x30;
  local_1c = (byte *)0x0;
  local_10 = 0;
  if (param_2 == 1) {
    pbVar13 = pbVar4;
    if (pbVar4 < pbVar11) {
      do {
        if ((pbVar13[0xc] & 4) == 0) {
          iVar7 = *(int *)(pbVar13 + 0x14);
          pbVar14 = *(byte **)(pbVar13 + 0x18);
          pbVar8 = pbVar14;
          pbVar18 = pbVar13;
          if (((iVar7 != 0) ||
              ((pbVar14 != (byte *)0x0 &&
               (iVar7 = *(int *)(pbVar14 + 0x14), pbVar8 = pbVar13, pbVar18 = pbVar14, iVar7 != 0)))
              ) && (pbVar18 != (byte *)0x0)) {
            uVar5 = *(undefined4 *)(iVar7 + 8);
            pbVar18[0xc] = pbVar18[0xc] | 4;
            *(undefined4 *)(pbVar18 + 8) = uVar5;
            if ((pbVar8 != (byte *)0x0) && (*(int *)(pbVar8 + 0x14) == 0)) {
              FUN_006bd170(1);
              pbVar8[0xc] = pbVar8[0xc] | 4;
            }
            if (local_1c == (byte *)0x0) {
              local_1c = pbVar13;
            }
          }
        }
        pbVar13 = pbVar13 + 0x30;
      } while (pbVar13 < pbVar11);
      goto LAB_006bd263;
    }
  }
  else {
LAB_006bd263:
    if (pbVar4 < pbVar11) {
      pbVar13 = pbVar4 + 0xc;
      do {
        bVar2 = *pbVar13;
        if ((bVar2 & 4) == 0) {
          iVar7 = *(int *)(pbVar13 + 0xc);
          if (iVar7 == 0) {
            local_10 = local_10 + 1;
          }
          else if (*(int *)(iVar7 + 0x14) == 0) {
            if (local_1c == (byte *)0x0) {
              iVar10 = *(int *)(pbVar13 + -8);
              iVar15 = *(int *)(iVar7 + 4);
              iVar6 = FUN_006bd000(bVar2,*(undefined1 *)(iVar7 + 0xc));
              if (iVar6 < 0x41) {
                iVar12 = 0x20;
                local_18 = 0x20;
              }
              else {
                iVar12 = 0x26;
                local_18 = 0x1a;
              }
              if (iVar6 < 0x60) {
                iVar10 = (iVar15 - iVar10 >> 1) + iVar10;
                uVar9 = iVar10 + 0x20U & 0xffffffc0;
                iVar10 = iVar10 - uVar9;
                iVar15 = iVar10 + iVar12;
                if (iVar15 < 0) {
                  iVar15 = -iVar15;
                }
                iVar10 = iVar10 - local_18;
                if (iVar10 < 0) {
                  iVar10 = -iVar10;
                }
                if (iVar15 < iVar10) {
                  local_18 = -iVar12;
                }
                iVar10 = (uVar9 + local_18) - iVar6 / 2;
                *(int *)(pbVar13 + -4) = iVar10;
                *(int *)(iVar7 + 8) = iVar10 + iVar6;
              }
              else {
                *(uint *)(pbVar13 + -4) = iVar10 + 0x20U & 0xffffffc0;
              }
              *pbVar13 = *pbVar13 | 4;
              local_1c = pbVar13 + -0xc;
              FUN_006bd170(param_2);
            }
            else {
              iVar10 = *(int *)(pbVar13 + -8) + (*(int *)(local_1c + 8) - *(int *)(local_1c + 4));
              iVar16 = *(int *)(iVar7 + 4) - *(int *)(pbVar13 + -8);
              uVar3 = *(undefined1 *)(iVar7 + 0xc);
              iVar6 = iVar16 >> 1;
              iVar12 = iVar6 + iVar10;
              iVar15 = FUN_006bd000(bVar2,uVar3);
              if ((*(byte *)(iVar7 + 0xc) & 4) == 0) {
                if (iVar15 < 0x60) {
                  uVar9 = iVar12 + 0x20U & 0xffffffc0;
                  if (iVar15 < 0x41) {
                    iVar10 = 0x20;
                    iVar6 = 0x20;
                  }
                  else {
                    iVar6 = 0x26;
                    iVar10 = 0x1a;
                  }
                  iVar16 = (iVar6 - uVar9) + iVar12;
                  if (iVar16 < 0) {
                    iVar16 = -iVar16;
                  }
                  iVar12 = (iVar12 - iVar10) - uVar9;
                  if (iVar12 < 0) {
                    iVar12 = -iVar12;
                  }
                  if (iVar16 < iVar12) {
                    iVar10 = -iVar6;
                  }
                  *(uint *)(pbVar13 + -4) = (uVar9 + iVar10) - iVar15 / 2;
                  *(uint *)(iVar7 + 8) = iVar15 / 2 + uVar9 + iVar10;
                }
                else {
                  iVar12 = FUN_006bd000(bVar2,uVar3);
                  uVar9 = iVar10 + 0x20U & 0xffffffc0;
                  iVar6 = (iVar12 >> 1) - (iVar6 + iVar10);
                  iVar15 = iVar6 + uVar9;
                  if (iVar15 < 0) {
                    iVar15 = -iVar15;
                  }
                  uVar17 = (iVar16 + 0x20 + iVar10 & 0xffffffc0U) - iVar12;
                  iVar6 = iVar6 + uVar17;
                  if (iVar6 < 0) {
                    iVar6 = -iVar6;
                  }
                  if (iVar6 <= iVar15) {
                    uVar9 = uVar17;
                  }
                  *(uint *)(pbVar13 + -4) = uVar9;
                  *(uint *)(iVar7 + 8) = uVar9 + iVar12;
                }
              }
              else {
                *(int *)(pbVar13 + -4) = *(int *)(iVar7 + 8) - iVar15;
              }
              *pbVar13 = *pbVar13 | 4;
              *(byte *)(iVar7 + 0xc) = *(byte *)(iVar7 + 0xc) | 4;
              if ((pbVar4 < pbVar13 + -0xc) && (*(int *)(pbVar13 + -4) < *(int *)(pbVar13 + -0x34)))
              {
                *(int *)(pbVar13 + -4) = *(int *)(pbVar13 + -0x34);
              }
            }
          }
          else {
            FUN_006bd170(param_2);
            *pbVar13 = *pbVar13 | 4;
          }
        }
        pbVar14 = pbVar13 + 0x24;
        pbVar13 = pbVar13 + 0x30;
      } while (pbVar14 < pbVar11);
    }
  }
  pbVar13 = (byte *)(((int)pbVar11 - (int)pbVar4) * 0x2aaaaaab);
  iVar7 = ((int)pbVar11 - (int)pbVar4) / 0x30;
  if (param_2 == 0) {
    if (iVar7 == 6) {
      pbVar14 = pbVar4 + 0x60;
      pbVar13 = pbVar4 + 0xc0;
      pbVar8 = pbVar4;
    }
    else {
      if (iVar7 != 0xc) goto LAB_006bd53f;
      pbVar14 = pbVar4 + 0xf0;
      pbVar13 = pbVar4 + 0x1b0;
      pbVar8 = pbVar4 + 0x30;
    }
    iVar10 = (*(int *)(pbVar14 + 4) * 2 - *(int *)(pbVar13 + 4)) - *(int *)(pbVar8 + 4);
    if (iVar10 < 0) {
      iVar10 = -iVar10;
    }
    if (iVar10 < 8) {
      iVar10 = *(int *)(pbVar8 + 8) + *(int *)(pbVar14 + 8) * -2 + *(int *)(pbVar13 + 8);
      *(int *)(pbVar13 + 8) = *(int *)(pbVar13 + 8) - iVar10;
      if (*(int *)(pbVar13 + 0x18) != 0) {
        piVar1 = (int *)(*(int *)(pbVar13 + 0x18) + 8);
        *piVar1 = *piVar1 - iVar10;
      }
      if (iVar7 == 0xc) {
        *(int *)(pbVar4 + 0x188) = *(int *)(pbVar4 + 0x188) - iVar10;
        *(int *)(pbVar4 + 0x218) = *(int *)(pbVar4 + 0x218) - iVar10;
      }
      pbVar13[0xc] = pbVar13[0xc] | 4;
      pbVar13 = *(byte **)(pbVar13 + 0x18);
      if (pbVar13 != (byte *)0x0) {
        pbVar13[0xc] = pbVar13[0xc] | 4;
      }
    }
  }
LAB_006bd53f:
  if (((local_10 != 0) || (local_1c == (byte *)0x0)) && (pbVar4 < pbVar11)) {
    pbVar14 = pbVar4 + 0x1c;
    do {
      if ((pbVar14[-0x10] & 4) == 0) {
        if (*(int *)pbVar14 == 0) {
LAB_006bd59c:
          if (local_1c == (byte *)0x0) {
            local_1c = pbVar14 + -0x1c;
            *(uint *)(pbVar14 + -0x14) = *(int *)(pbVar14 + -0x18) + 0x20U & 0xffffffc0;
          }
          else {
            for (pbVar13 = pbVar14 + -0x4c; (pbVar4 <= pbVar13 && ((pbVar13[0xc] & 4) == 0));
                pbVar13 = pbVar13 + -0x30) {
            }
            for (pbVar8 = pbVar14 + 0x14; (pbVar8 < pbVar11 && ((pbVar8[0xc] & 4) == 0));
                pbVar8 = pbVar8 + 0x30) {
            }
            if ((((pbVar13 < pbVar4) || (pbVar14 + -0x1c <= pbVar13)) || (pbVar11 <= pbVar8)) ||
               (pbVar8 <= pbVar14 + -0x1c)) {
              *(uint *)(pbVar14 + -0x14) =
                   ((*(int *)(pbVar14 + -0x18) - *(int *)(local_1c + 4)) + 0x10U & 0xffffffe0) +
                   *(int *)(local_1c + 8);
            }
            else {
              iVar7 = FUN_00685d60(*(int *)(pbVar14 + -0x18) - *(int *)(pbVar13 + 4),
                                   *(int *)(pbVar8 + 8) - *(int *)(pbVar13 + 8),
                                   *(int *)(pbVar8 + 4) - *(int *)(pbVar13 + 4));
              *(int *)(pbVar14 + -0x14) = iVar7 + *(int *)(pbVar13 + 8);
            }
          }
        }
        else {
          iVar7 = *(int *)(*(int *)pbVar14 + 4) - *(int *)(pbVar14 + -0x18);
          if (iVar7 < 0) {
            iVar7 = -iVar7;
          }
          if (0x4f < iVar7) goto LAB_006bd59c;
          FUN_006bd1a0();
        }
        pbVar14[-0x10] = pbVar14[-0x10] | 4;
        if ((pbVar4 < pbVar14 + -0x1c) && (*(int *)(pbVar14 + -0x14) < *(int *)(pbVar14 + -0x44))) {
          *(int *)(pbVar14 + -0x14) = *(int *)(pbVar14 + -0x44);
        }
        pbVar13 = pbVar14 + 0x14;
        if (((pbVar13 < pbVar11) && ((pbVar14[0x20] & 4) != 0)) &&
           (pbVar13 = *(byte **)(pbVar14 + 0x1c), (int)pbVar13 < *(int *)(pbVar14 + -0x14))) {
          *(byte **)(pbVar14 + -0x14) = pbVar13;
        }
      }
      pbVar8 = pbVar14 + 0x14;
      pbVar14 = pbVar14 + 0x30;
    } while (pbVar8 < pbVar11);
  }
  return pbVar13;
}



============================================================
DISASSEMBLY
============================================================
006bd1b0 : SUB ESP,0x1c
006bd1b3 : MOV ECX,dword ptr [ESP + 0x24]
006bd1b7 : MOV EDX,dword ptr [ESP + 0x20]
006bd1bb : LEA EAX,[ECX*0x8 + 0x0]
006bd1c2 : SUB EAX,ECX
006bd1c4 : LEA EAX,[EDX + EAX*0x4 + 0x30]
006bd1c8 : PUSH EBX
006bd1c9 : PUSH EBP
006bd1ca : MOV EBP,dword ptr [EAX + 0x14]
006bd1cd : MOV EAX,dword ptr [EAX + 0xc]
006bd1d0 : LEA EDX,[EAX + EAX*0x2]
006bd1d3 : SHL EDX,0x4
006bd1d6 : XOR EAX,EAX
006bd1d8 : ADD EDX,EBP
006bd1da : PUSH ESI
006bd1db : PUSH EDI
006bd1dc : MOV dword ptr [ESP + 0x20],EBP
006bd1e0 : MOV dword ptr [ESP + 0x18],EDX
006bd1e4 : MOV dword ptr [ESP + 0x10],EAX
006bd1e8 : MOV dword ptr [ESP + 0x1c],EAX
006bd1ec : CMP ECX,0x1
006bd1ef : JNZ 0x006bd263
006bd1f1 : MOV EBX,EBP
006bd1f3 : CMP EBP,EDX
006bd1f5 : JNC 0x006bd4b0
006bd1fb : JMP 0x006bd200
006bd200 : TEST byte ptr [EBX + 0xc],0x4
006bd204 : JNZ 0x006bd25c
006bd206 : MOV EAX,dword ptr [EBX + 0x14]
006bd209 : MOV ESI,dword ptr [EBX + 0x18]
006bd20c : TEST EAX,EAX
006bd20e : JZ 0x006bd214
006bd210 : MOV EDI,EBX
006bd212 : JMP 0x006bd223
006bd214 : TEST ESI,ESI
006bd216 : JZ 0x006bd25c
006bd218 : MOV EAX,dword ptr [ESI + 0x14]
006bd21b : TEST EAX,EAX
006bd21d : JZ 0x006bd25c
006bd21f : MOV EDI,ESI
006bd221 : MOV ESI,EBX
006bd223 : TEST EDI,EDI
006bd225 : JZ 0x006bd25c
006bd227 : MOV EAX,dword ptr [EAX + 0x8]
006bd22a : OR byte ptr [EDI + 0xc],0x4
006bd22e : MOV dword ptr [EDI + 0x8],EAX
006bd231 : TEST ESI,ESI
006bd233 : JZ 0x006bd251
006bd235 : CMP dword ptr [ESI + 0x14],0x0
006bd239 : JNZ 0x006bd251
006bd23b : MOV EDX,dword ptr [ESP + 0x30]
006bd23f : PUSH 0x1
006bd241 : CALL 0x006bd170
006bd246 : MOV EDX,dword ptr [ESP + 0x1c]
006bd24a : ADD ESP,0x4
006bd24d : OR byte ptr [ESI + 0xc],0x4
006bd251 : CMP dword ptr [ESP + 0x10],0x0
006bd256 : JNZ 0x006bd25c
006bd258 : MOV dword ptr [ESP + 0x10],EBX
006bd25c : ADD EBX,0x30
006bd25f : CMP EBX,EDX
006bd261 : JC 0x006bd200
006bd263 : CMP EBP,EDX
006bd265 : JNC 0x006bd4b0
006bd26b : LEA EBX,[EBP + 0xc]
006bd26e : MOV EDI,EDI
006bd270 : MOV CL,byte ptr [EBX]
006bd272 : TEST CL,0x4
006bd275 : JNZ 0x006bd49c
006bd27b : MOV EBP,dword ptr [EBX + 0xc]
006bd27e : MOV dword ptr [ESP + 0x14],EBP
006bd282 : TEST EBP,EBP
006bd284 : JNZ 0x006bd28f
006bd286 : INC dword ptr [ESP + 0x1c]
006bd28a : JMP 0x006bd49c
006bd28f : CMP dword ptr [EBP + 0x14],0x0
006bd293 : JZ 0x006bd2b3
006bd295 : MOV ECX,dword ptr [ESP + 0x34]
006bd299 : MOV EDX,dword ptr [ESP + 0x30]
006bd29d : LEA ESI,[EBX + -0xc]
006bd2a0 : PUSH ECX
006bd2a1 : MOV EDI,EBP
006bd2a3 : CALL 0x006bd170
006bd2a8 : ADD ESP,0x4
006bd2ab : OR byte ptr [EBX],0x4
006bd2ae : JMP 0x006bd49c
006bd2b3 : CMP dword ptr [ESP + 0x10],0x0
006bd2b8 : JNZ 0x006bd376
006bd2be : MOVZX EDX,byte ptr [EBP + 0xc]
006bd2c2 : MOV EDI,dword ptr [EBX + -0x8]
006bd2c5 : MOV ESI,dword ptr [EBP + 0x4]
006bd2c8 : MOVZX EAX,CL
006bd2cb : MOV ECX,dword ptr [ESP + 0x34]
006bd2cf : PUSH EDX
006bd2d0 : MOV EDX,dword ptr [ESP + 0x34]
006bd2d4 : SUB ESI,EDI
006bd2d6 : PUSH EAX
006bd2d7 : MOV EAX,ESI
006bd2d9 : CALL 0x006bd000
006bd2de : ADD ESP,0x8
006bd2e1 : CMP EAX,0x40
006bd2e4 : MOV dword ptr [ESP + 0x10],EAX
006bd2e8 : JG 0x006bd2f5
006bd2ea : MOV EDX,0x20
006bd2ef : MOV dword ptr [ESP + 0x14],EDX
006bd2f3 : JMP 0x006bd302
006bd2f5 : MOV EDX,0x26
006bd2fa : MOV dword ptr [ESP + 0x14],0x1a
006bd302 : CMP dword ptr [ESP + 0x10],0x60
006bd307 : JGE 0x006bd34b
006bd309 : SAR ESI,0x1
006bd30b : ADD ESI,EDI
006bd30d : LEA ECX,[ESI + 0x20]
006bd310 : AND ECX,0xffffffc0
006bd313 : MOV EAX,ESI
006bd315 : SUB EAX,ECX
006bd317 : LEA ESI,[EAX + EDX*0x1]
006bd31a : TEST ESI,ESI
006bd31c : JGE 0x006bd320
006bd31e : NEG ESI
006bd320 : MOV EDI,dword ptr [ESP + 0x14]
006bd324 : SUB EAX,EDI
006bd326 : JNS 0x006bd32a
006bd328 : NEG EAX
006bd32a : CMP ESI,EAX
006bd32c : JGE 0x006bd332
006bd32e : SUB ECX,EDX
006bd330 : JMP 0x006bd334
006bd332 : ADD ECX,EDI
006bd334 : MOV ESI,dword ptr [ESP + 0x10]
006bd338 : MOV EAX,ESI
006bd33a : CDQ
006bd33b : SUB EAX,EDX
006bd33d : SAR EAX,0x1
006bd33f : SUB ECX,EAX
006bd341 : MOV dword ptr [EBX + -0x4],ECX
006bd344 : ADD ECX,ESI
006bd346 : MOV dword ptr [EBP + 0x8],ECX
006bd349 : JMP 0x006bd354
006bd34b : ADD EDI,0x20
006bd34e : AND EDI,0xffffffc0
006bd351 : MOV dword ptr [EBX + -0x4],EDI
006bd354 : MOV ECX,dword ptr [ESP + 0x34]
006bd358 : MOV EDX,dword ptr [ESP + 0x30]
006bd35c : OR byte ptr [EBX],0x4
006bd35f : LEA EDI,[EBX + -0xc]
006bd362 : PUSH ECX
006bd363 : MOV ESI,EBP
006bd365 : MOV dword ptr [ESP + 0x14],EDI
006bd369 : CALL 0x006bd170
006bd36e : ADD ESP,0x4
006bd371 : JMP 0x006bd49c
006bd376 : MOV EDI,dword ptr [ESP + 0x10]
006bd37a : MOV EDX,dword ptr [ESP + 0x14]
006bd37e : MOV EBP,dword ptr [EDI + 0x8]
006bd381 : SUB EBP,dword ptr [EDI + 0x4]
006bd384 : MOV EAX,dword ptr [EBX + -0x8]
006bd387 : MOV ESI,dword ptr [EDX + 0x4]
006bd38a : LEA EDI,[EAX + EBP*0x1]
006bd38d : SUB ESI,EAX
006bd38f : MOVZX EAX,byte ptr [EDX + 0xc]
006bd393 : MOV EDX,dword ptr [ESP + 0x30]
006bd397 : MOVZX ECX,CL
006bd39a : PUSH EAX
006bd39b : MOV EBP,ESI
006bd39d : MOV dword ptr [ESP + 0x28],EAX
006bd3a1 : MOV dword ptr [ESP + 0x2c],ECX
006bd3a5 : PUSH ECX
006bd3a6 : MOV ECX,dword ptr [ESP + 0x3c]
006bd3aa : SAR EBP,0x1
006bd3ac : MOV EAX,ESI
006bd3ae : ADD EBP,EDI
006bd3b0 : CALL 0x006bd000
006bd3b5 : MOV EDX,dword ptr [ESP + 0x1c]
006bd3b9 : ADD ESP,0x8
006bd3bc : TEST byte ptr [EDX + 0xc],0x4
006bd3c0 : JZ 0x006bd3d1
006bd3c2 : MOV ECX,EDX
006bd3c4 : MOV EDX,dword ptr [ECX + 0x8]
006bd3c7 : SUB EDX,EAX
006bd3c9 : MOV dword ptr [EBX + -0x4],EDX
006bd3cc : JMP 0x006bd47d
006bd3d1 : CMP EAX,0x60
006bd3d4 : JGE 0x006bd425
006bd3d6 : LEA ECX,[EBP + 0x20]
006bd3d9 : AND ECX,0xffffffc0
006bd3dc : CMP EAX,0x40
006bd3df : JG 0x006bd3ea
006bd3e1 : MOV EDI,0x20
006bd3e6 : MOV ESI,EDI
006bd3e8 : JMP 0x006bd3f2
006bd3ea : MOV ESI,0x26
006bd3ef : LEA EDI,[ESI + -0xc]
006bd3f2 : MOV EDX,ESI
006bd3f4 : SUB EDX,ECX
006bd3f6 : ADD EDX,EBP
006bd3f8 : JNS 0x006bd3fc
006bd3fa : NEG EDX
006bd3fc : SUB EBP,EDI
006bd3fe : SUB EBP,ECX
006bd400 : JNS 0x006bd404
006bd402 : NEG EBP
006bd404 : CMP EDX,EBP
006bd406 : JGE 0x006bd40c
006bd408 : SUB ECX,ESI
006bd40a : JMP 0x006bd40e
006bd40c : ADD ECX,EDI
006bd40e : CDQ
006bd40f : SUB EAX,EDX
006bd411 : SAR EAX,0x1
006bd413 : MOV EDX,ECX
006bd415 : SUB EDX,EAX
006bd417 : ADD EAX,ECX
006bd419 : MOV ECX,dword ptr [ESP + 0x14]
006bd41d : MOV dword ptr [EBX + -0x4],EDX
006bd420 : MOV dword ptr [ECX + 0x8],EAX
006bd423 : JMP 0x006bd47d
006bd425 : MOV EDX,dword ptr [ESP + 0x24]
006bd429 : MOV EAX,dword ptr [ESP + 0x28]
006bd42d : MOV ECX,dword ptr [ESP + 0x34]
006bd431 : PUSH EDX
006bd432 : MOV EDX,dword ptr [ESP + 0x34]
006bd436 : MOV EBP,ESI
006bd438 : PUSH EAX
006bd439 : SAR EBP,0x1
006bd43b : MOV EAX,ESI
006bd43d : ADD EBP,EDI
006bd43f : CALL 0x006bd000
006bd444 : MOV ECX,EAX
006bd446 : SAR ECX,0x1
006bd448 : LEA EDX,[EDI + 0x20]
006bd44b : AND EDX,0xffffffc0
006bd44e : SUB ECX,EBP
006bd450 : LEA EBP,[ECX + EDX*0x1]
006bd453 : ADD ESP,0x8
006bd456 : TEST EBP,EBP
006bd458 : JGE 0x006bd45c
006bd45a : NEG EBP
006bd45c : LEA ESI,[ESI + EDI*0x1 + 0x20]
006bd460 : AND ESI,0xffffffc0
006bd463 : SUB ESI,EAX
006bd465 : ADD ECX,ESI
006bd467 : JNS 0x006bd46b
006bd469 : NEG ECX
006bd46b : CMP EBP,ECX
006bd46d : JL 0x006bd471
006bd46f : MOV EDX,ESI
006bd471 : MOV ECX,dword ptr [ESP + 0x14]
006bd475 : MOV dword ptr [EBX + -0x4],EDX
006bd478 : ADD EDX,EAX
006bd47a : MOV dword ptr [ECX + 0x8],EDX
006bd47d : OR byte ptr [EBX],0x4
006bd480 : MOV EAX,dword ptr [ESP + 0x14]
006bd484 : OR byte ptr [EAX + 0xc],0x4
006bd488 : LEA EDX,[EBX + -0xc]
006bd48b : CMP EDX,dword ptr [ESP + 0x20]
006bd48f : JBE 0x006bd49c
006bd491 : MOV EAX,dword ptr [EBX + -0x34]
006bd494 : CMP dword ptr [EBX + -0x4],EAX
006bd497 : JGE 0x006bd49c
006bd499 : MOV dword ptr [EBX + -0x4],EAX
006bd49c : ADD EBX,0x30
006bd49f : LEA EAX,[EBX + -0xc]
006bd4a2 : CMP EAX,dword ptr [ESP + 0x18]
006bd4a6 : JC 0x006bd270
006bd4ac : MOV EBP,dword ptr [ESP + 0x20]
006bd4b0 : MOV ECX,dword ptr [ESP + 0x18]
006bd4b4 : SUB ECX,EBP
006bd4b6 : MOV EAX,0x2aaaaaab
006bd4bb : IMUL ECX
006bd4bd : SAR EDX,0x3
006bd4c0 : MOV ESI,EDX
006bd4c2 : SHR ESI,0x1f
006bd4c5 : ADD ESI,EDX
006bd4c7 : CMP dword ptr [ESP + 0x34],0x0
006bd4cc : JNZ 0x006bd53f
006bd4ce : CMP ESI,0x6
006bd4d1 : JZ 0x006bd58c
006bd4d7 : CMP ESI,0xc
006bd4da : JNZ 0x006bd53f
006bd4dc : LEA EDI,[EBP + 0x30]
006bd4df : LEA EBX,[EBP + 0xf0]
006bd4e5 : LEA EAX,[EBP + 0x1b0]
006bd4eb : MOV ECX,dword ptr [EBX + 0x4]
006bd4ee : ADD ECX,ECX
006bd4f0 : SUB ECX,dword ptr [EAX + 0x4]
006bd4f3 : SUB ECX,dword ptr [EDI + 0x4]
006bd4f6 : JNS 0x006bd4fa
006bd4f8 : NEG ECX
006bd4fa : CMP ECX,0x8
006bd4fd : JGE 0x006bd53f
006bd4ff : MOV ECX,dword ptr [EBX + 0x8]
006bd502 : MOV EDX,dword ptr [EAX + 0x8]
006bd505 : ADD ECX,ECX
006bd507 : MOV EBX,ECX
006bd509 : MOV ECX,dword ptr [EDI + 0x8]
006bd50c : SUB ECX,EBX
006bd50e : ADD ECX,EDX
006bd510 : SUB EDX,ECX
006bd512 : MOV dword ptr [EAX + 0x8],EDX
006bd515 : MOV EDX,dword ptr [EAX + 0x18]
006bd518 : TEST EDX,EDX
006bd51a : JZ 0x006bd51f
006bd51c : SUB dword ptr [EDX + 0x8],ECX
006bd51f : CMP ESI,0xc
006bd522 : JNZ 0x006bd530
006bd524 : SUB dword ptr [EBP + 0x188],ECX
006bd52a : SUB dword ptr [EBP + 0x218],ECX
006bd530 : OR byte ptr [EAX + 0xc],0x4
006bd534 : MOV EAX,dword ptr [EAX + 0x18]
006bd537 : TEST EAX,EAX
006bd539 : JZ 0x006bd53f
006bd53b : OR byte ptr [EAX + 0xc],0x4
006bd53f : CMP dword ptr [ESP + 0x1c],0x0
006bd544 : JNZ 0x006bd551
006bd546 : CMP dword ptr [ESP + 0x10],0x0
006bd54b : JNZ 0x006bd66e
006bd551 : MOV EBX,dword ptr [ESP + 0x18]
006bd555 : CMP EBP,EBX
006bd557 : JNC 0x006bd66e
006bd55d : LEA ESI,[EBP + 0x1c]
006bd560 : TEST byte ptr [ESI + -0x10],0x4
006bd564 : JNZ 0x006bd660
006bd56a : MOV ECX,dword ptr [ESI]
006bd56c : TEST ECX,ECX
006bd56e : JZ 0x006bd59c
006bd570 : MOV EAX,dword ptr [ECX + 0x4]
006bd573 : SUB EAX,dword ptr [ESI + -0x18]
006bd576 : JNS 0x006bd57a
006bd578 : NEG EAX
006bd57a : CMP EAX,0x50
006bd57d : JGE 0x006bd59c
006bd57f : LEA EAX,[ESI + -0x1c]
006bd582 : CALL 0x006bd1a0
006bd587 : JMP 0x006bd632
006bd58c : MOV EDI,EBP
006bd58e : LEA EBX,[EBP + 0x60]
006bd591 : LEA EAX,[EBP + 0xc0]
006bd597 : JMP 0x006bd4eb
006bd59c : CMP dword ptr [ESP + 0x10],0x0
006bd5a1 : JNZ 0x006bd5b8
006bd5a3 : MOV EDX,dword ptr [ESI + -0x18]
006bd5a6 : ADD EDX,0x20
006bd5a9 : AND EDX,0xffffffc0
006bd5ac : LEA EAX,[ESI + -0x1c]
006bd5af : MOV dword ptr [ESI + -0x14],EDX
006bd5b2 : MOV dword ptr [ESP + 0x10],EAX
006bd5b6 : JMP 0x006bd632
006bd5b8 : LEA ECX,[ESI + -0x4c]
006bd5bb : LEA EDI,[ESI + -0x4c]
006bd5be : CMP ECX,EBP
006bd5c0 : JC 0x006bd5cf
006bd5c2 : TEST byte ptr [EDI + 0xc],0x4
006bd5c6 : JNZ 0x006bd5cf
006bd5c8 : SUB EDI,0x30
006bd5cb : CMP EDI,EBP
006bd5cd : JNC 0x006bd5c2
006bd5cf : LEA EAX,[ESI + 0x14]
006bd5d2 : CMP EAX,EBX
006bd5d4 : JNC 0x006bd5e3
006bd5d6 : TEST byte ptr [EAX + 0xc],0x4
006bd5da : JNZ 0x006bd5e3
006bd5dc : ADD EAX,0x30
006bd5df : CMP EAX,EBX
006bd5e1 : JC 0x006bd5d6
006bd5e3 : CMP EDI,EBP
006bd5e5 : JC 0x006bd61c
006bd5e7 : LEA ECX,[ESI + -0x1c]
006bd5ea : CMP EDI,ECX
006bd5ec : JNC 0x006bd61c
006bd5ee : CMP EAX,EBX
006bd5f0 : JNC 0x006bd61c
006bd5f2 : CMP EAX,ECX
006bd5f4 : JBE 0x006bd61c
006bd5f6 : MOV EDX,dword ptr [EAX + 0x4]
006bd5f9 : MOV ECX,dword ptr [EDI + 0x4]
006bd5fc : MOV EAX,dword ptr [EAX + 0x8]
006bd5ff : SUB EAX,dword ptr [EDI + 0x8]
006bd602 : SUB EDX,ECX
006bd604 : PUSH EDX
006bd605 : MOV EDX,dword ptr [ESI + -0x18]
006bd608 : PUSH EAX
006bd609 : SUB EDX,ECX
006bd60b : PUSH EDX
006bd60c : CALL 0x00685d60
006bd611 : ADD ESP,0xc
006bd614 : ADD EAX,dword ptr [EDI + 0x8]
006bd617 : MOV dword ptr [ESI + -0x14],EAX
006bd61a : JMP 0x006bd632
006bd61c : MOV EAX,dword ptr [ESP + 0x10]
006bd620 : MOV ECX,dword ptr [ESI + -0x18]
006bd623 : SUB ECX,dword ptr [EAX + 0x4]
006bd626 : ADD ECX,0x10
006bd629 : AND ECX,0xffffffe0
006bd62c : ADD ECX,dword ptr [EAX + 0x8]
006bd62f : MOV dword ptr [ESI + -0x14],ECX
006bd632 : OR byte ptr [ESI + -0x10],0x4
006bd636 : LEA EDX,[ESI + -0x1c]
006bd639 : CMP EDX,EBP
006bd63b : JBE 0x006bd648
006bd63d : MOV EAX,dword ptr [ESI + -0x44]
006bd640 : CMP dword ptr [ESI + -0x14],EAX
006bd643 : JGE 0x006bd648
006bd645 : MOV dword ptr [ESI + -0x14],EAX
006bd648 : LEA EAX,[ESI + 0x14]
006bd64b : CMP EAX,EBX
006bd64d : JNC 0x006bd660
006bd64f : TEST byte ptr [ESI + 0x20],0x4
006bd653 : JZ 0x006bd660
006bd655 : MOV EAX,dword ptr [ESI + 0x1c]
006bd658 : CMP dword ptr [ESI + -0x14],EAX
006bd65b : JLE 0x006bd660
006bd65d : MOV dword ptr [ESI + -0x14],EAX
006bd660 : ADD ESI,0x30
006bd663 : LEA ECX,[ESI + -0x1c]
006bd666 : CMP ECX,EBX
006bd668 : JC 0x006bd560
006bd66e : POP EDI
006bd66f : POP ESI
006bd670 : POP EBP
006bd671 : POP EBX
006bd672 : ADD ESP,0x1c
006bd675 : RET
