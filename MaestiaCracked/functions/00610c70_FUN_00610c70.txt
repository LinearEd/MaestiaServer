PROGRAM  : Maestia.exe
FUNCTION : FUN_00610c70
ENTRY    : 00610c70
BODY     : [[00610c70, 00610d18] [00610d20, 00610e6f]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00610c70(int param_1)

{
  int *piVar1;
  int iVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  bool bVar5;
  short sVar6;
  short sVar7;
  byte *pbVar8;
  int in_ECX;
  short sVar9;
  uint uVar10;
  int iVar11;
  size_t _Size;
  undefined4 local_1c;
  short local_18;
  uint local_14;
  short local_10;
  short sStack_e;
  uint local_4;
  
  if (param_1 == 1) {
    sVar6 = *(short *)(in_ECX + 0x58);
  }
  else {
    sVar6 = *(short *)(in_ECX + 0x5a);
  }
  if (param_1 == 1) {
    iVar11 = (int)*(short *)(in_ECX + 0x5c) - (int)*(short *)(in_ECX + 0x58);
  }
  else {
    iVar11 = (int)*(short *)(in_ECX + 0x5e) - (int)*(short *)(in_ECX + 0x5a);
  }
  _Size = iVar11 + 1;
  FUN_00610b20(_Size,0);
  *(size_t *)(in_ECX + 0x28) = _Size;
  _memset(*(void **)(in_ECX + 0x24),0,_Size);
  local_4 = 0;
  if (*(int *)(in_ECX + 4) != 0) {
    do {
      iVar11 = *(int *)(*(int *)(in_ECX + 0x10) + (local_4 >> 4) * 4);
      piVar1 = (int *)(iVar11 + (local_4 & 0xf) * 8);
      if (2 < *(uint *)(iVar11 + 4 + (local_4 & 0xf) * 8)) {
        **(undefined1 **)(in_ECX + 0x24) = 3;
        local_14 = 0;
        if (piVar1[1] != 0) {
          do {
            iVar11 = *piVar1;
            iVar2 = *(int *)(in_ECX + 0x20);
            local_1c = *(int *)(*(int *)(iVar2 + (iVar11 + local_14 >> 6) * 4) +
                               (iVar11 + local_14 & 0x3f) * 4);
            uVar10 = (local_14 + 1) % (uint)piVar1[1] + iVar11;
            uVar3 = *(undefined4 *)(*(int *)(iVar2 + (uVar10 >> 6) * 4) + (uVar10 & 0x3f) * 4);
            local_10 = (short)uVar3;
            uVar10 = (local_14 + 2) % (uint)piVar1[1] + iVar11;
            uVar4 = *(undefined4 *)(*(int *)(iVar2 + (uVar10 >> 6) * 4) + (uVar10 & 0x3f) * 4);
            local_18 = (short)uVar4;
            sVar7 = (short)((uint)uVar4 >> 0x10);
            if (param_1 == 1) {
              local_1c = local_1c << 0x10;
              sVar9 = -sVar7;
              sVar7 = local_18;
              sStack_e = local_10;
            }
            else {
              sStack_e = (short)((uint)uVar3 >> 0x10);
              sVar9 = (short)local_1c;
            }
            bVar5 = false;
            if (local_1c._2_2_ < sStack_e) {
LAB_00610dc7:
              if (sStack_e < sVar7) {
LAB_00610e07:
                if (local_1c._2_2_ == sStack_e) {
                  iVar11 = (int)sStack_e - (int)sVar6;
                  if (sVar9 < local_10) {
                    pbVar8 = (byte *)(*(int *)(in_ECX + 0x24) + iVar11);
                    *pbVar8 = *pbVar8 | (*(int *)(in_ECX + 0x60) == 1) + 1U;
                  }
                  if (local_10 < sVar9) goto LAB_00610e2e;
                }
              }
              else {
LAB_00610dcc:
                iVar11 = (int)sStack_e - (int)sVar6;
                if (sVar9 <= local_10) {
                  bVar5 = local_10 <= local_18;
                  if (bVar5) {
                    pbVar8 = (byte *)(*(int *)(in_ECX + 0x24) + iVar11);
                    *pbVar8 = *pbVar8 | (*(int *)(in_ECX + 0x60) == 1) + 1U;
                  }
                  if (local_10 <= sVar9) goto LAB_00610dfc;
LAB_00610e03:
                  if (bVar5) goto LAB_00610e3e;
                  goto LAB_00610e07;
                }
LAB_00610dfc:
                if (local_10 < local_18) goto LAB_00610e03;
LAB_00610e2e:
                pbVar8 = (byte *)(iVar11 + *(int *)(in_ECX + 0x24));
                *pbVar8 = *pbVar8 | (*(int *)(in_ECX + 0x60) != 1) + 1U;
              }
            }
            else {
              if (sStack_e <= sVar7) goto LAB_00610dcc;
              if (local_1c._2_2_ <= sStack_e) goto LAB_00610dc7;
            }
LAB_00610e3e:
            local_14 = local_14 + 1;
          } while (local_14 < (uint)piVar1[1]);
        }
      }
      local_4 = local_4 + 1;
    } while (local_4 < *(uint *)(in_ECX + 4));
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00610c70 : SUB ESP,0x1c
00610c73 : PUSH EBX
00610c74 : MOV EBX,ECX
00610c76 : MOV ECX,dword ptr [ESP + 0x24]
00610c7a : PUSH ESI
00610c7b : PUSH EDI
00610c7c : CMP ECX,0x1
00610c7f : JNZ 0x00610c87
00610c81 : MOVZX EAX,word ptr [EBX + 0x58]
00610c85 : JMP 0x00610c8b
00610c87 : MOVZX EAX,word ptr [EBX + 0x5a]
00610c8b : CWDE
00610c8c : MOV dword ptr [ESP + 0x1c],EAX
00610c90 : CMP ECX,0x1
00610c93 : JNZ 0x00610ca1
00610c95 : MOVSX ESI,word ptr [EBX + 0x5c]
00610c99 : MOVSX ECX,word ptr [EBX + 0x58]
00610c9d : SUB ESI,ECX
00610c9f : JMP 0x00610cab
00610ca1 : MOVSX ESI,word ptr [EBX + 0x5e]
00610ca5 : MOVSX EDX,word ptr [EBX + 0x5a]
00610ca9 : SUB ESI,EDX
00610cab : PUSH 0x0
00610cad : INC ESI
00610cae : LEA EDI,[EBX + 0x24]
00610cb1 : PUSH ESI
00610cb2 : MOV ECX,EDI
00610cb4 : CALL 0x00610b20
00610cb9 : MOV EAX,ESI
00610cbb : PUSH EAX
00610cbc : MOV dword ptr [EDI + 0x4],ESI
00610cbf : MOV ECX,dword ptr [EDI]
00610cc1 : PUSH 0x0
00610cc3 : PUSH ECX
00610cc4 : CALL 0x0063b700
00610cc9 : XOR EAX,EAX
00610ccb : ADD ESP,0xc
00610cce : MOV dword ptr [ESP + 0x24],EAX
00610cd2 : CMP dword ptr [EBX + 0x4],EAX
00610cd5 : JBE 0x00610e67
00610cdb : PUSH EBP
00610cdc : LEA ESP,[ESP]
00610ce0 : MOV ECX,dword ptr [EBX + 0x10]
00610ce3 : MOV EDX,EAX
00610ce5 : SHR EDX,0x4
00610ce8 : MOV EDX,dword ptr [ECX + EDX*0x4]
00610ceb : MOV ESI,EAX
00610ced : AND ESI,0xf
00610cf0 : CMP dword ptr [EDX + ESI*0x8 + 0x4],0x2
00610cf5 : LEA EDX,[EDX + ESI*0x8]
00610cf8 : MOV dword ptr [ESP + 0x24],EDX
00610cfc : JBE 0x00610e58
00610d02 : MOV ECX,dword ptr [EBX + 0x24]
00610d05 : XOR EBP,EBP
00610d07 : MOV byte ptr [ECX],0x3
00610d0a : MOV dword ptr [ESP + 0x18],EBP
00610d0e : CMP dword ptr [EDX + 0x4],EBP
00610d11 : JBE 0x00610e58
00610d17 : JMP 0x00610d28
00610d20 : MOV EDX,dword ptr [ESP + 0x24]
00610d24 : MOV EBP,dword ptr [ESP + 0x18]
00610d28 : MOV ECX,dword ptr [EDX]
00610d2a : MOV ESI,dword ptr [EBX + 0x20]
00610d2d : LEA EAX,[ECX + EBP*0x1]
00610d30 : MOV EDI,EAX
00610d32 : AND EAX,0x3f
00610d35 : SHR EDI,0x6
00610d38 : MOV EDI,dword ptr [ESI + EDI*0x4]
00610d3b : MOV EAX,dword ptr [EDI + EAX*0x4]
00610d3e : MOV EDI,dword ptr [EDX + 0x4]
00610d41 : MOV dword ptr [ESP + 0x10],EAX
00610d45 : XOR EDX,EDX
00610d47 : ADD EBP,0x2
00610d4a : LEA EAX,[EBP + -0x1]
00610d4d : DIV EDI
00610d4f : ADD EDX,ECX
00610d51 : MOV EAX,EDX
00610d53 : SHR EAX,0x6
00610d56 : MOV EAX,dword ptr [ESI + EAX*0x4]
00610d59 : AND EDX,0x3f
00610d5c : MOV EDX,dword ptr [EAX + EDX*0x4]
00610d5f : MOV dword ptr [ESP + 0x1c],EDX
00610d63 : XOR EDX,EDX
00610d65 : MOV EAX,EBP
00610d67 : DIV EDI
00610d69 : MOV BP,word ptr [ESP + 0x1c]
00610d6e : ADD EDX,ECX
00610d70 : MOV EAX,EDX
00610d72 : SHR EAX,0x6
00610d75 : MOV ECX,dword ptr [ESI + EAX*0x4]
00610d78 : AND EDX,0x3f
00610d7b : CMP dword ptr [ESP + 0x30],0x1
00610d80 : MOV EDX,dword ptr [ECX + EDX*0x4]
00610d83 : MOV dword ptr [ESP + 0x14],EDX
00610d87 : JNZ 0x00610da2
00610d89 : MOVZX EAX,word ptr [ESP + 0x10]
00610d8e : SHR EDX,0x10
00610d91 : MOV word ptr [ESP + 0x12],AX
00610d96 : MOV AX,word ptr [ESP + 0x14]
00610d9b : MOV SI,BP
00610d9e : NEG EDX
00610da0 : JMP 0x00610db1
00610da2 : MOV DX,word ptr [ESP + 0x10]
00610da7 : MOV SI,word ptr [ESP + 0x1e]
00610dac : MOV AX,word ptr [ESP + 0x16]
00610db1 : MOV DI,word ptr [ESP + 0x12]
00610db6 : XOR CL,CL
00610db8 : CMP DI,SI
00610dbb : JL 0x00610dc7
00610dbd : CMP AX,SI
00610dc0 : JGE 0x00610dcc
00610dc2 : CMP DI,SI
00610dc5 : JG 0x00610e3e
00610dc7 : CMP AX,SI
00610dca : JG 0x00610e07
00610dcc : MOVSX EAX,SI
00610dcf : SUB EAX,dword ptr [ESP + 0x20]
00610dd3 : CMP DX,BP
00610dd6 : JG 0x00610dfc
00610dd8 : CMP BP,word ptr [ESP + 0x14]
00610ddd : JG 0x00610df7
00610ddf : MOV ECX,dword ptr [EBX + 0x24]
00610de2 : CMP dword ptr [EBX + 0x60],0x1
00610de6 : LEA EDI,[ECX + EAX*0x1]
00610de9 : SETZ CL
00610dec : INC CL
00610dee : OR byte ptr [EDI],CL
00610df0 : MOV DI,word ptr [ESP + 0x12]
00610df5 : MOV CL,0x1
00610df7 : CMP DX,BP
00610dfa : JL 0x00610e03
00610dfc : CMP BP,word ptr [ESP + 0x14]
00610e01 : JGE 0x00610e2e
00610e03 : TEST CL,CL
00610e05 : JNZ 0x00610e3e
00610e07 : CMP DI,SI
00610e0a : JNZ 0x00610e3e
00610e0c : MOVSX EAX,SI
00610e0f : SUB EAX,dword ptr [ESP + 0x20]
00610e13 : CMP DX,BP
00610e16 : JGE 0x00610e2c
00610e18 : CMP dword ptr [EBX + 0x60],0x1
00610e1c : MOV ECX,dword ptr [EBX + 0x24]
00610e1f : LEA ESI,[ECX + EAX*0x1]
00610e22 : SETZ CL
00610e25 : INC CL
00610e27 : OR byte ptr [ESI],CL
00610e29 : CMP DX,BP
00610e2c : JLE 0x00610e3e
00610e2e : MOV EDX,dword ptr [EBX + 0x24]
00610e31 : ADD EAX,EDX
00610e33 : CMP dword ptr [EBX + 0x60],0x1
00610e37 : SETNZ CL
00610e3a : INC CL
00610e3c : OR byte ptr [EAX],CL
00610e3e : MOV EAX,dword ptr [ESP + 0x18]
00610e42 : MOV EDX,dword ptr [ESP + 0x24]
00610e46 : INC EAX
00610e47 : MOV dword ptr [ESP + 0x18],EAX
00610e4b : CMP EAX,dword ptr [EDX + 0x4]
00610e4e : JC 0x00610d20
00610e54 : MOV EAX,dword ptr [ESP + 0x28]
00610e58 : INC EAX
00610e59 : MOV dword ptr [ESP + 0x28],EAX
00610e5d : CMP EAX,dword ptr [EBX + 0x4]
00610e60 : JC 0x00610ce0
00610e66 : POP EBP
00610e67 : POP EDI
00610e68 : POP ESI
00610e69 : POP EBX
00610e6a : ADD ESP,0x1c
00610e6d : RET 0x4
