PROGRAM  : Maestia.exe
FUNCTION : _Getloctxt<char,class_std::istreambuf_iterator<char,struct_std::char_traits<char>_>_>
ENTRY    : 006231aa
BODY     : [[006231aa, 006232f9]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Function: __EH_prolog3_GS replaced with injection: EH_prolog3 */
/* Library Function - Single Match
    int __cdecl std::_Getloctxt<char,class std::istreambuf_iterator<char,struct
   std::char_traits<char> > >(class std::istreambuf_iterator<char,struct std::char_traits<char> >
   &,class std::istreambuf_iterator<char,struct std::char_traits<char> > &,unsigned int,char const
   *)
   
   Library: Visual Studio 2008 Release */

int __cdecl
std::_Getloctxt<char,class_std::istreambuf_iterator<char,struct_std::char_traits<char>_>_>
          (istreambuf_iterator<char,struct_std::char_traits<char>_> *param_1,
          istreambuf_iterator<char,struct_std::char_traits<char>_> *param_2,uint param_3,
          char *param_4)

{
  bool bVar1;
  char cVar2;
  bool bVar3;
  undefined1 *puVar4;
  char *pcVar5;
  uint uVar6;
  int iVar7;
  uint local_3c;
  uint local_38;
  
  cVar2 = *param_4;
  pcVar5 = param_4;
  while (cVar2 != '\0') {
    if (cVar2 == *param_4) {
      param_3 = param_3 + 1;
    }
    pcVar5 = pcVar5 + 1;
    cVar2 = *pcVar5;
  }
  FUN_004d1280(param_3,0);
  local_3c = 1;
  while( true ) {
    iVar7 = 0;
    bVar3 = false;
    local_38 = 0;
    if (param_3 == 0) break;
    do {
      cVar2 = param_4[iVar7];
      if (cVar2 != '\0') {
        do {
          if (cVar2 == *param_4) break;
          iVar7 = iVar7 + 1;
          cVar2 = param_4[iVar7];
        } while (cVar2 != '\0');
      }
      pcVar5 = (char *)FUN_004d3b30(local_38);
      if (*pcVar5 == '\0') {
        iVar7 = iVar7 + local_3c;
        if ((param_4[iVar7] == *param_4) || (param_4[iVar7] == '\0')) {
          uVar6 = 0x7f;
          if (local_3c < 0x7f) {
            uVar6 = local_3c;
          }
          puVar4 = (undefined1 *)FUN_004d3b30(local_38);
          *puVar4 = (char)uVar6;
        }
        else {
          bVar1 = istreambuf_iterator<char,struct_std::char_traits<char>_>::equal(param_1,param_2);
          if ((bVar1) ||
             (cVar2 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_1),
             param_4[iVar7] != cVar2)) {
            uVar6 = 0x7f;
            if (local_3c < 0x7f) {
              uVar6 = local_3c;
            }
            puVar4 = (undefined1 *)FUN_004d3b30(local_38);
            *puVar4 = (char)uVar6;
          }
          else {
            bVar3 = true;
          }
        }
      }
      else {
        pcVar5 = (char *)FUN_004d3b30(local_38);
        iVar7 = iVar7 + *pcVar5;
      }
      local_38 = local_38 + 1;
    } while (local_38 < param_3);
    if ((!bVar3) ||
       (bVar3 = istreambuf_iterator<char,struct_std::char_traits<char>_>::equal(param_1,param_2),
       bVar3)) break;
    local_3c = local_3c + 1;
    istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_1);
  }
  FUN_00405260(1,0);
  iVar7 = FUN_00640ed0();
  return iVar7;
}



============================================================
DISASSEMBLY
============================================================
006231aa : PUSH 0x38
006231ac : MOV EAX,0xb0b7f6
006231b1 : CALL 0x00640e86
006231b6 : MOV EAX,dword ptr [EBP + 0x8]
006231b9 : MOV EDI,dword ptr [EBP + 0x14]
006231bc : MOV dword ptr [EBP + -0x3c],EAX
006231bf : MOV EAX,dword ptr [EBP + 0xc]
006231c2 : MOV dword ptr [EBP + -0x44],EAX
006231c5 : MOV AL,byte ptr [EDI]
006231c7 : TEST AL,AL
006231c9 : JZ 0x006231dd
006231cb : MOV CL,AL
006231cd : MOV EDX,EDI
006231cf : CMP CL,AL
006231d1 : JNZ 0x006231d6
006231d3 : INC dword ptr [EBP + 0x10]
006231d6 : INC EDX
006231d7 : MOV CL,byte ptr [EDX]
006231d9 : TEST CL,CL
006231db : JNZ 0x006231cf
006231dd : PUSH 0x0
006231df : PUSH dword ptr [EBP + 0x10]
006231e2 : LEA ECX,[EBP + -0x2c]
006231e5 : CALL 0x004d1280
006231ea : AND dword ptr [EBP + -0x4],0x0
006231ee : MOV dword ptr [EBP + -0x40],0xfffffffe
006231f5 : MOV dword ptr [EBP + -0x38],0x1
006231fc : XOR ESI,ESI
006231fe : MOV byte ptr [EBP + -0x2d],0x0
00623202 : MOV dword ptr [EBP + -0x34],ESI
00623205 : CMP dword ptr [EBP + 0x10],ESI
00623208 : JBE 0x006232e5
0062320e : MOV AL,byte ptr [ESI + EDI*0x1]
00623211 : TEST AL,AL
00623213 : JZ 0x00623223
00623215 : MOV CL,byte ptr [EDI]
00623217 : CMP AL,CL
00623219 : JZ 0x00623223
0062321b : INC ESI
0062321c : MOV AL,byte ptr [ESI + EDI*0x1]
0062321f : TEST AL,AL
00623221 : JNZ 0x00623217
00623223 : PUSH dword ptr [EBP + -0x34]
00623226 : LEA ECX,[EBP + -0x2c]
00623229 : CALL 0x004d3b30
0062322e : CMP byte ptr [EAX],0x0
00623231 : JZ 0x00623245
00623233 : PUSH dword ptr [EBP + -0x34]
00623236 : LEA ECX,[EBP + -0x2c]
00623239 : CALL 0x004d3b30
0062323e : MOVSX EAX,byte ptr [EAX]
00623241 : ADD ESI,EAX
00623243 : JMP 0x006232ad
00623245 : ADD ESI,dword ptr [EBP + -0x38]
00623248 : MOV AL,byte ptr [ESI + EDI*0x1]
0062324b : CMP AL,byte ptr [EDI]
0062324d : JZ 0x0062328f
0062324f : TEST AL,AL
00623251 : JZ 0x0062328f
00623253 : PUSH dword ptr [EBP + -0x44]
00623256 : MOV ECX,dword ptr [EBP + -0x3c]
00623259 : CALL 0x00623123
0062325e : TEST AL,AL
00623260 : JNZ 0x00623275
00623262 : MOV ECX,dword ptr [EBP + -0x3c]
00623265 : CALL 0x0062317a
0062326a : CMP byte ptr [ESI + EDI*0x1],AL
0062326d : JNZ 0x00623275
0062326f : MOV byte ptr [EBP + -0x2d],0x1
00623273 : JMP 0x006232ad
00623275 : PUSH 0x7f
00623277 : POP EBX
00623278 : CMP dword ptr [EBP + -0x38],EBX
0062327b : JNC 0x00623280
0062327d : MOV EBX,dword ptr [EBP + -0x38]
00623280 : PUSH dword ptr [EBP + -0x34]
00623283 : LEA ECX,[EBP + -0x2c]
00623286 : CALL 0x004d3b30
0062328b : MOV byte ptr [EAX],BL
0062328d : JMP 0x006232ad
0062328f : PUSH 0x7f
00623291 : POP EBX
00623292 : CMP dword ptr [EBP + -0x38],EBX
00623295 : JNC 0x0062329a
00623297 : MOV EBX,dword ptr [EBP + -0x38]
0062329a : PUSH dword ptr [EBP + -0x34]
0062329d : LEA ECX,[EBP + -0x2c]
006232a0 : CALL 0x004d3b30
006232a5 : MOV byte ptr [EAX],BL
006232a7 : MOV EAX,dword ptr [EBP + -0x34]
006232aa : MOV dword ptr [EBP + -0x40],EAX
006232ad : INC dword ptr [EBP + -0x34]
006232b0 : MOV EAX,dword ptr [EBP + -0x34]
006232b3 : CMP EAX,dword ptr [EBP + 0x10]
006232b6 : JC 0x0062320e
006232bc : CMP byte ptr [EBP + -0x2d],0x0
006232c0 : JZ 0x006232e5
006232c2 : PUSH dword ptr [EBP + -0x44]
006232c5 : MOV ECX,dword ptr [EBP + -0x3c]
006232c8 : CALL 0x00623123
006232cd : TEST AL,AL
006232cf : JNZ 0x006232e5
006232d1 : MOV ECX,dword ptr [EBP + -0x3c]
006232d4 : INC dword ptr [EBP + -0x38]
006232d7 : CALL 0x006230d9
006232dc : OR dword ptr [EBP + -0x40],0xffffffff
006232e0 : JMP 0x006231fc
006232e5 : PUSH 0x0
006232e7 : PUSH 0x1
006232e9 : LEA ECX,[EBP + -0x2c]
006232ec : CALL 0x00405260
006232f1 : MOV EAX,dword ptr [EBP + -0x40]
006232f4 : CALL 0x00640ed0
006232f9 : RET
