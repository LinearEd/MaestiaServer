PROGRAM  : Maestia.exe
FUNCTION : FUN_0086db30
ENTRY    : 0086db30
BODY     : [[0086db30, 0086dc88]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0086db30(void)

{
  int iVar1;
  short sVar2;
  DWORD DVar3;
  int *piVar4;
  int *unaff_ESI;
  bool bVar5;
  
  *(undefined1 *)((int)unaff_ESI + 0x425) = 1;
  if (unaff_ESI[0x29] == 0) {
    iVar1 = *(int *)(unaff_ESI[0x4e] + 4);
    piVar4 = unaff_ESI + 0x456;
    sVar2 = FUN_0043d970();
    if (sVar2 == 1000) {
      bVar5 = *(int **)((int)unaff_ESI + iVar1 + 0x13c) == piVar4;
    }
    else if (sVar2 == 2000) {
      bVar5 = *(int **)((int)unaff_ESI + iVar1 + 0x140) == piVar4;
    }
    else {
      bVar5 = *(int **)((int)unaff_ESI + iVar1 + 0x144) == piVar4;
    }
    if (!bVar5) {
      (**(code **)(*(int *)(*(int *)(unaff_ESI[0x4e] + 4) + 0x138 + (int)unaff_ESI) + 0x10))
                (piVar4,1,1,0);
    }
  }
  DVar3 = timeGetTime();
  unaff_ESI[0x14f] = DVar3;
  (**(code **)(*unaff_ESI + 0x284))();
  if (*(char *)(DAT_00da93ec + 0x3a8) == '\0') {
    piVar4 = (int *)FUN_00a1a840(unaff_ESI[0x155]);
    if ((piVar4 == (int *)0x0) || (sVar2 = (**(code **)(*piVar4 + 0x1e4))(), sVar2 != 0)) {
      bVar5 = false;
    }
    else {
      bVar5 = true;
    }
    if ((*(int *)(*DAT_00da9894 + 0x140) != 0) &&
       (iVar1 = *(int *)(*(int *)(*DAT_00da9894 + 0x140) + 0x38), iVar1 != 0)) {
      if (bVar5) {
        *(int *)(iVar1 + 0x918) = *(int *)(iVar1 + 0x918) + 1;
        (**(code **)(*(int *)(iVar1 + 0x38) + 4))(0xe,*(undefined4 *)(iVar1 + 0x918));
        return;
      }
      *(int *)(iVar1 + 0x90c) = *(int *)(iVar1 + 0x90c) + 1;
      (**(code **)(*(int *)(iVar1 + 0x38) + 4))(0xb,*(undefined4 *)(iVar1 + 0x90c));
    }
  }
  else if ((*(int *)(*DAT_00da9894 + 0x140) != 0) &&
          (iVar1 = *(int *)(*(int *)(*DAT_00da9894 + 0x140) + 0x38), iVar1 != 0)) {
    *(int *)(iVar1 + 0x920) = *(int *)(iVar1 + 0x920) + 1;
    (**(code **)(*(int *)(iVar1 + 0x38) + 4))(0x10,*(undefined4 *)(iVar1 + 0x920));
    return;
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
0086db30 : CMP dword ptr [ESI + 0xa4],0x0
0086db37 : MOV byte ptr [ESI + 0x425],0x1
0086db3e : JNZ 0x0086dbae
0086db40 : MOV EAX,dword ptr [ESI + 0x138]
0086db46 : MOV EAX,dword ptr [EAX + 0x4]
0086db49 : PUSH EBX
0086db4a : PUSH EDI
0086db4b : LEA EDI,[ESI + 0x1158]
0086db51 : LEA EBX,[EAX + ESI*0x1 + 0x138]
0086db58 : MOV AX,word ptr [EDI + 0x2a]
0086db5c : CALL 0x0043d970
0086db61 : MOV ECX,0x3e8
0086db66 : CMP AX,CX
0086db69 : JNZ 0x0086db70
0086db6b : CMP dword ptr [EBX + 0x4],EDI
0086db6e : JMP 0x0086db82
0086db70 : MOV EDX,0x7d0
0086db75 : CMP AX,DX
0086db78 : JNZ 0x0086db7f
0086db7a : CMP dword ptr [EBX + 0x8],EDI
0086db7d : JMP 0x0086db82
0086db7f : CMP dword ptr [EBX + 0xc],EDI
0086db82 : SETZ AL
0086db85 : TEST AL,AL
0086db87 : JNZ 0x0086dbac
0086db89 : MOV EAX,dword ptr [ESI + 0x138]
0086db8f : MOV EAX,dword ptr [EAX + 0x4]
0086db92 : MOV EDX,dword ptr [EAX + ESI*0x1 + 0x138]
0086db99 : PUSH 0x0
0086db9b : LEA ECX,[EAX + ESI*0x1 + 0x138]
0086dba2 : MOV EAX,dword ptr [EDX + 0x10]
0086dba5 : PUSH 0x1
0086dba7 : PUSH 0x1
0086dba9 : PUSH EDI
0086dbaa : CALL EAX
0086dbac : POP EDI
0086dbad : POP EBX
0086dbae : CALL dword ptr [0x00b85598]
0086dbb4 : MOV EDX,dword ptr [ESI]
0086dbb6 : MOV dword ptr [ESI + 0x53c],EAX
0086dbbc : MOV EAX,dword ptr [EDX + 0x284]
0086dbc2 : MOV ECX,ESI
0086dbc4 : CALL EAX
0086dbc6 : MOV ECX,dword ptr [0x00da93ec]
0086dbcc : CMP byte ptr [ECX + 0x3a8],0x0
0086dbd3 : JZ 0x0086dc11
0086dbd5 : MOV ECX,dword ptr [0x00da9894]
0086dbdb : MOV EDX,dword ptr [ECX]
0086dbdd : MOV EAX,dword ptr [EDX + 0x140]
0086dbe3 : TEST EAX,EAX
0086dbe5 : JZ 0x0086dc88
0086dbeb : MOV ECX,dword ptr [EAX + 0x38]
0086dbee : TEST ECX,ECX
0086dbf0 : JZ 0x0086dc88
0086dbf6 : INC dword ptr [ECX + 0x920]
0086dbfc : MOV EAX,dword ptr [ECX + 0x920]
0086dc02 : MOV EDX,dword ptr [ECX + 0x38]
0086dc05 : ADD ECX,0x38
0086dc08 : PUSH EAX
0086dc09 : MOV EAX,dword ptr [EDX + 0x4]
0086dc0c : PUSH 0x10
0086dc0e : CALL EAX
0086dc10 : RET
0086dc11 : MOV EDX,dword ptr [ESI + 0x554]
0086dc17 : PUSH EDX
0086dc18 : CALL 0x00a1a840
0086dc1d : TEST EAX,EAX
0086dc1f : JZ 0x0086dc39
0086dc21 : MOV EDX,dword ptr [EAX]
0086dc23 : MOV ECX,EAX
0086dc25 : MOV EAX,dword ptr [EDX + 0x1e4]
0086dc2b : CALL EAX
0086dc2d : TEST AX,AX
0086dc30 : JNZ 0x0086dc39
0086dc32 : MOV EDX,0x1
0086dc37 : JMP 0x0086dc3b
0086dc39 : XOR EDX,EDX
0086dc3b : MOV ECX,dword ptr [0x00da9894]
0086dc41 : MOV EAX,dword ptr [ECX]
0086dc43 : MOV EAX,dword ptr [EAX + 0x140]
0086dc49 : TEST EAX,EAX
0086dc4b : JZ 0x0086dc88
0086dc4d : MOV ECX,dword ptr [EAX + 0x38]
0086dc50 : TEST ECX,ECX
0086dc52 : JZ 0x0086dc88
0086dc54 : ADD ECX,0x38
0086dc57 : TEST EDX,EDX
0086dc59 : JZ 0x0086dc72
0086dc5b : INC dword ptr [ECX + 0x8e0]
0086dc61 : MOV EAX,dword ptr [ECX + 0x8e0]
0086dc67 : MOV EDX,dword ptr [ECX]
0086dc69 : PUSH EAX
0086dc6a : MOV EAX,dword ptr [EDX + 0x4]
0086dc6d : PUSH 0xe
0086dc6f : CALL EAX
0086dc71 : RET
0086dc72 : INC dword ptr [ECX + 0x8d4]
0086dc78 : MOV EAX,dword ptr [ECX + 0x8d4]
0086dc7e : MOV EDX,dword ptr [ECX]
0086dc80 : PUSH EAX
0086dc81 : MOV EAX,dword ptr [EDX + 0x4]
0086dc84 : PUSH 0xb
0086dc86 : CALL EAX
0086dc88 : RET
