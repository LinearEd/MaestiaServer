PROGRAM  : Maestia.exe
FUNCTION : FUN_00608120
ENTRY    : 00608120
BODY     : [[00608120, 006081cb] [006081d0, 00608c59] [00608c60, 00608d8b]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00608120(float param_1,int param_2)

{
  float *pfVar1;
  undefined4 *puVar2;
  byte *pbVar3;
  uint *puVar4;
  float fVar5;
  float fVar6;
  int iVar7;
  int iVar8;
  char cVar9;
  float fVar10;
  undefined4 uVar11;
  uint uVar12;
  uint uVar13;
  float *in_ECX;
  uint uVar14;
  float fVar15;
  float fVar16;
  int iVar17;
  undefined4 *puVar18;
  float10 fVar19;
  float local_70;
  uint local_6c;
  uint *local_68;
  float local_64;
  uint *local_60;
  undefined4 local_5c;
  int local_58;
  uint local_54;
  float local_50;
  float local_4c;
  uint *local_48;
  undefined4 local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  float local_34;
  float *local_30;
  uint local_2c;
  uint local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  int local_14;
  undefined4 local_c;
  int local_8;
  
  in_ECX[0x17] = 0.0;
  FUN_00607cc0();
  if (0.0 <= param_1) {
    return;
  }
  local_54 = 0x90ffffff;
  if (param_2 == 0) {
    param_1 = param_1 + param_1;
    local_54 = (uint)in_ECX[0x1f] | 0x90000000;
  }
  local_4c = ABS(param_1);
  local_70 = 0.0;
  local_50 = local_4c * 10.0;
  if (in_ECX[8] != 0.0) {
    do {
      local_68 = (uint *)(*(int *)((int)in_ECX[0xb] + ((uint)local_70 >> 8) * 4) +
                         ((uint)local_70 & 0xff) * 0x3c);
      local_6c = 0;
      local_48 = local_68;
      do {
        if (((((*(byte *)((int)local_48 + local_6c + 0x34) & 1) == 0) &&
             ((*(uint *)(*(int *)((int)in_ECX[3] + (*local_68 >> 8) * 4) + 8 +
                        (*local_68 & 0xff) * 0xc) & 0x20000000) == 0)) &&
            (cVar9 = FUN_00607d60(local_6c + (int)local_70 * 4), in_ECX[0xf] != 0.0)) &&
           ((cVar9 == '\0' ||
            (uVar14 = *(int *)(*(int *)((int)in_ECX[0x12] + ((int)in_ECX[0xf] - 1U >> 6) * 4) +
                              ((int)in_ECX[0xf] - 1U & 0x3f) * 4) >> 2,
            *(int *)(*(int *)((int)in_ECX[0xb] + ((uint)(**(int **)in_ECX[0x12] >> 2) >> 8) * 4) +
                     0x38 + (**(int **)in_ECX[0x12] >> 2 & 0xffU) * 0x3c) !=
            *(int *)(*(int *)((int)in_ECX[0xb] + (uVar14 >> 8) * 4) + 0x38 + (uVar14 & 0xff) * 0x3c)
            )))) {
          pfVar1 = in_ECX + 0x13;
          *pfVar1 = 0.0;
          local_30 = (float *)(*(int *)((int)in_ECX[3] + (*local_68 >> 8) * 4) +
                              (*local_68 & 0xff) * 0xc);
          if (cVar9 == '\0') {
            FUN_006063f0(-param_1,local_50,0,(int)in_ECX[0xf] - 1,&local_5c,&local_58);
            fVar16 = *in_ECX;
            local_18 = local_5c;
            fVar15 = (float)((uint)fVar16 >> 8);
            local_14 = local_58;
            if ((uint)in_ECX[1] <= (uint)fVar15) {
              FUN_00606d10(fVar15);
            }
            puVar18 = (undefined4 *)
                      (*(int *)((int)in_ECX[3] + (int)fVar15 * 4) + ((uint)*in_ECX & 0xff) * 0xc);
            *puVar18 = local_18;
            puVar18[1] = local_14;
            puVar18[2] = local_54;
            *in_ECX = (float)((int)*in_ECX + 1);
            fVar15 = (float)((uint)*pfVar1 >> 6);
            if ((uint)in_ECX[0x14] <= (uint)fVar15) {
              FUN_00606e60(fVar15);
            }
            *(float *)(*(int *)((int)in_ECX[0x16] + (int)fVar15 * 4) + ((uint)*pfVar1 & 0x3f) * 4) =
                 fVar16;
            *pfVar1 = (float)((int)*pfVar1 + 1);
            uVar14 = **(uint **)in_ECX[0x12];
            *(float *)(*(int *)((int)in_ECX[0xb] + (uVar14 >> 10) * 4) + 0x28 +
                      ((uVar14 >> 2 & 0xff) * 0xf + (&DAT_00b9575c)[uVar14 & 3]) * 4) = fVar16;
            uVar14 = *(uint *)(*(int *)((int)in_ECX[0x12] + ((int)in_ECX[0xf] - 1U >> 6) * 4) +
                              ((int)in_ECX[0xf] - 1U & 0x3f) * 4);
            *(float *)(*(int *)((int)in_ECX[0xb] + (uVar14 >> 10) * 4) + 0x28 +
                      ((uVar14 >> 2 & 0xff) * 0xf + (uVar14 & 3)) * 4) = fVar16;
          }
          if (param_2 == 1) {
            local_64 = 0.0;
            if (in_ECX[0xf] != 0.0) {
              do {
                uVar14 = *(int *)(*(int *)((int)in_ECX[0x12] + ((uint)local_64 >> 6) * 4) +
                                 ((uint)local_64 & 0x3f) * 4) >> 2;
                fVar16 = (float)((int)local_64 + 1);
                if ((uint)fVar16 < (uint)in_ECX[0xf]) {
                  local_4c = *(float *)(*(int *)((int)in_ECX[0xb] + (uVar14 >> 8) * 4) +
                                        (uVar14 & 0xff) * 0x3c + 0x38);
                  do {
                    uVar14 = *(int *)(*(int *)((int)in_ECX[0x12] + ((uint)fVar16 >> 6) * 4) +
                                     ((uint)fVar16 & 0x3f) * 4) >> 2;
                    if (local_4c !=
                        *(float *)(*(int *)((int)in_ECX[0xb] + (uVar14 >> 8) * 4) + 0x38 +
                                  (uVar14 & 0xff) * 0x3c)) break;
                    fVar16 = (float)((int)fVar16 + 1);
                  } while ((uint)fVar16 < (uint)in_ECX[0xf]);
                }
                FUN_006063f0(param_1,local_50,local_64,(int)fVar16 + -1,&local_5c,&local_58);
                local_4c = *in_ECX;
                local_c = local_5c;
                fVar15 = (float)((uint)local_4c >> 8);
                local_8 = local_58;
                if ((uint)in_ECX[1] <= (uint)fVar15) {
                  if ((uint)in_ECX[2] <= (uint)fVar15) {
                    if (in_ECX[3] == 0.0) {
                      local_44 = 0x88;
                      fVar10 = (float)FUN_00515d60(in_ECX,0x100,&local_44);
                    }
                    else {
                      fVar10 = (float)FUN_00515c80(in_ECX[3],(int)in_ECX[2] * 4 + 0x100);
                    }
                    in_ECX[2] = (float)((int)in_ECX[2] + 0x40);
                    in_ECX[3] = fVar10;
                  }
                  local_40 = 0x88;
                  uVar11 = FUN_00515d60(in_ECX,0xc00,&local_40);
                  *(undefined4 *)((int)in_ECX[3] + (int)fVar15 * 4) = uVar11;
                  in_ECX[1] = (float)((int)in_ECX[1] + 1);
                }
                puVar18 = (undefined4 *)
                          (*(int *)((int)in_ECX[3] + (int)fVar15 * 4) + ((uint)*in_ECX & 0xff) * 0xc
                          );
                *puVar18 = local_c;
                puVar18[1] = local_8;
                puVar18[2] = local_54;
                *in_ECX = (float)((int)*in_ECX + 1);
                pfVar1 = in_ECX + 0x13;
                fVar15 = (float)((uint)in_ECX[0x13] >> 6);
                if ((uint)in_ECX[0x14] <= (uint)fVar15) {
                  if ((uint)in_ECX[0x15] <= (uint)fVar15) {
                    if (in_ECX[0x16] == 0.0) {
                      local_3c = 0x88;
                      fVar10 = (float)FUN_00515d60(pfVar1,0x40,&local_3c);
                    }
                    else {
                      fVar10 = (float)FUN_00515c80(in_ECX[0x16],(int)in_ECX[0x15] * 4 + 0x40);
                    }
                    in_ECX[0x15] = (float)((int)in_ECX[0x15] + 0x10);
                    in_ECX[0x16] = fVar10;
                  }
                  local_38 = 0x88;
                  uVar11 = FUN_00515d60(pfVar1,0x100,&local_38);
                  *(undefined4 *)((int)in_ECX[0x16] + (int)fVar15 * 4) = uVar11;
                  in_ECX[0x14] = (float)((int)in_ECX[0x14] + 1);
                }
                *(float *)(*(int *)((int)in_ECX[0x16] + (int)fVar15 * 4) +
                          ((uint)*pfVar1 & 0x3f) * 4) = local_4c;
                *pfVar1 = (float)((int)*pfVar1 + 1);
                local_34 = (float)(*(int *)((int)in_ECX[3] + ((int)*in_ECX - 1U >> 8) * 4) +
                                  ((int)*in_ECX - 1U & 0xff) * 0xc);
                if ((uint)local_64 < (uint)fVar16) {
                  do {
                    uVar14 = *(uint *)(*(int *)((int)in_ECX[0x12] + ((uint)local_64 >> 6) * 4) +
                                      ((uint)local_64 & 0x3f) * 4);
                    uVar12 = uVar14 & 0xfffffffc | (&DAT_00b9575c)[uVar14 & 3];
                    iVar17 = *(int *)((int)in_ECX[0xb] + (uVar12 >> 10) * 4) +
                             (uVar12 >> 2 & 0xff) * 0x3c;
                    uVar14 = (&DAT_00b9575c)[uVar14 & 3] & 3;
                    FUN_006069b0(*(int *)((int)in_ECX[3] + (*local_68 >> 8) * 4) +
                                 (*local_68 & 0xff) * 0xc,iVar17,uVar14,local_34,-param_1);
                    *(float *)(iVar17 + 0xc + uVar14 * 4) = local_4c;
                    pbVar3 = (byte *)(uVar14 + 0x34 + iVar17);
                    *pbVar3 = *pbVar3 | 1;
                    local_64 = (float)((int)local_64 + 2);
                  } while ((uint)local_64 < (uint)fVar16);
                }
                local_64 = fVar16;
              } while ((uint)fVar16 < (uint)in_ECX[0xf]);
            }
            fVar16 = in_ECX[0x13];
            while (2 < (uint)fVar16) {
              fVar16 = in_ECX[0x13];
              fVar15 = 0.0;
              local_4c = 0.0;
              fVar10 = 0.0;
              if (fVar16 != 0.0) {
                do {
                  uVar14 = *(uint *)(*(int *)((int)in_ECX[0x16] + ((uint)fVar10 >> 6) * 4) +
                                    ((uint)fVar10 & 0x3f) * 4);
                  pfVar1 = (float *)(*(int *)((int)in_ECX[3] + (uVar14 >> 8) * 4) +
                                    (uVar14 & 0xff) * 0xc);
                  fVar5 = *local_30 - *pfVar1;
                  fVar6 = local_30[1] - pfVar1[1];
                  local_34 = fVar6 * fVar6 + fVar5 * fVar5;
                  fVar19 = (float10)FUN_0063bdc0();
                  local_34 = (float)fVar19;
                  if (local_4c < local_34) {
                    fVar15 = fVar10;
                    local_4c = local_34;
                  }
                  fVar10 = (float)((int)fVar10 + 1);
                } while ((uint)fVar10 < (uint)fVar16);
              }
              uVar14 = ((int)fVar15 + 1U) % (uint)fVar16;
              uVar12 = (uint)((int)fVar16 + -1 + (int)fVar15) % (uint)fVar16;
              fVar16 = in_ECX[0x16];
              fVar10 = (float)((uint)in_ECX[0x17] >> 8);
              local_24 = *(undefined4 *)
                          (*(int *)((int)fVar16 + (uVar12 >> 6) * 4) + (uVar12 & 0x3f) * 4);
              local_20 = *(undefined4 *)
                          (*(int *)((int)fVar16 + ((uint)fVar15 >> 6) * 4) +
                          ((uint)fVar15 & 0x3f) * 4);
              pfVar1 = in_ECX + 0x17;
              local_1c = *(undefined4 *)
                          (*(int *)((int)fVar16 + (uVar14 >> 6) * 4) + (uVar14 & 0x3f) * 4);
              if ((uint)in_ECX[0x18] <= (uint)fVar10) {
                if ((uint)in_ECX[0x19] <= (uint)fVar10) {
                  if (in_ECX[0x1a] == 0.0) {
                    local_2c = 0x88;
                    fVar16 = (float)FUN_00515d60(pfVar1,0x100,&local_2c);
                  }
                  else {
                    fVar16 = (float)FUN_00515c80(in_ECX[0x1a],(int)in_ECX[0x19] * 4 + 0x100);
                  }
                  in_ECX[0x19] = (float)((int)in_ECX[0x19] + 0x40);
                  in_ECX[0x1a] = fVar16;
                }
                local_28 = 0x88;
                uVar11 = FUN_00515d60(pfVar1,0xc00,&local_28);
                *(undefined4 *)((int)in_ECX[0x1a] + (int)fVar10 * 4) = uVar11;
                in_ECX[0x18] = (float)((int)in_ECX[0x18] + 1);
              }
              puVar18 = (undefined4 *)
                        (*(int *)((int)in_ECX[0x1a] + (int)fVar10 * 4) +
                        ((uint)*pfVar1 & 0xff) * 0xc);
              *puVar18 = local_24;
              puVar18[1] = local_20;
              puVar18[2] = local_1c;
              *pfVar1 = (float)((int)*pfVar1 + 1);
              FUN_00606c50(fVar15);
              fVar16 = in_ECX[0x13];
            }
          }
          puVar4 = (uint *)(*(int *)((int)in_ECX[3] + (*local_68 >> 8) * 4) + 8 +
                           (*local_68 & 0xff) * 0xc);
          *puVar4 = *puVar4 | 0x20000000;
        }
        local_68 = local_68 + 1;
        local_6c = local_6c + 1;
      } while (local_6c < 3);
      local_70 = (float)((int)local_70 + 1);
    } while ((uint)local_70 < (uint)in_ECX[8]);
  }
  local_70 = 0.0;
  if (in_ECX[8] != 0.0) {
    do {
      uVar12 = (uint)local_70 & 0xff;
      iVar17 = *(int *)((int)in_ECX[0xb] + ((uint)local_70 >> 8) * 4);
      local_28 = *(uint *)(iVar17 + 0xc + uVar12 * 0x3c);
      uVar14 = *(uint *)(iVar17 + 0x10 + uVar12 * 0x3c);
      iVar17 = iVar17 + uVar12 * 0x3c;
      local_58 = iVar17;
      if (((local_28 != uVar14) && (local_2c = *(uint *)(iVar17 + 0x14), uVar14 != local_2c)) &&
         (local_2c != local_28)) {
        pfVar1 = in_ECX + 0x17;
        local_4c = (float)((uint)in_ECX[0x17] >> 8);
        if ((uint)in_ECX[0x18] <= (uint)local_4c) {
          FUN_00606d10(local_4c);
        }
        puVar4 = (uint *)(*(int *)((int)in_ECX[0x1a] + (int)local_4c * 4) +
                         ((uint)*pfVar1 & 0xff) * 0xc);
        *puVar4 = local_28;
        puVar4[1] = uVar14;
        puVar4[2] = local_2c;
        *pfVar1 = (float)((int)*pfVar1 + 1);
      }
      local_60 = (uint *)(iVar17 + 0x1c);
      local_6c = 0;
      do {
        *(uint *)(*(int *)((int)in_ECX[3] + (local_60[-4] >> 8) * 4) + 8 +
                 (local_60[-4] & 0xff) * 0xc) = *(uint *)(iVar17 + 0x38) | 0x10000000;
        if ((*(byte *)(iVar17 + 0x34 + local_6c) & 2) == 0) {
          local_28 = *local_60;
          if ((int)local_28 < 0) {
            local_54 = *(uint *)(iVar17 + 0x28 + (&DAT_00b9575c)[local_6c] * 4);
            uVar14 = local_60[3];
            if ((-1 < (int)local_54) && (-1 < (int)uVar14)) {
              uVar13 = (int)local_70 * 4 | local_6c;
              uVar12 = *(uint *)(*(int *)((int)in_ECX[0xb] + (uVar13 >> 10) * 4) + 0xc +
                                ((uVar13 >> 2 & 0xff) * 0xf + (&DAT_00b9575c)[local_6c & 3]) * 4);
              local_c = *(undefined4 *)
                         (*(int *)((int)in_ECX[0xb] + (uVar13 >> 10) * 4) + 0xc +
                         ((uVar13 >> 2 & 0xff) * 0xf + (local_6c & 3)) * 4);
              pfVar1 = in_ECX + 0x17;
              fVar16 = (float)((uint)in_ECX[0x17] >> 8);
              if ((uint)in_ECX[0x18] <= (uint)fVar16) {
                FUN_00606d10(fVar16);
              }
              puVar18 = (undefined4 *)
                        (*(int *)((int)in_ECX[0x1a] + (int)fVar16 * 4) +
                        ((uint)*pfVar1 & 0xff) * 0xc);
              *puVar18 = local_c;
              puVar18[1] = uVar12;
              puVar18[2] = uVar14;
              *pfVar1 = (float)((int)*pfVar1 + 1);
              fVar16 = (float)((uint)*pfVar1 >> 8);
              if ((uint)in_ECX[0x18] <= (uint)fVar16) {
                FUN_00606d10(fVar16);
              }
              puVar4 = (uint *)(*(int *)((int)in_ECX[0x1a] + (int)fVar16 * 4) +
                               ((uint)*pfVar1 & 0xff) * 0xc);
              *puVar4 = uVar14;
              puVar4[1] = uVar12;
              puVar4[2] = local_54;
              *pfVar1 = (float)((int)*pfVar1 + 1);
              iVar17 = local_58;
            }
          }
          else {
            local_2c = *(int *)((int)in_ECX[0xb] + ((uint)((int)local_28 >> 2) >> 8) * 4) +
                       ((int)local_28 >> 2 & 0xffU) * 0x3c;
            if (*(int *)(local_2c + 0x38) != *(int *)(iVar17 + 0x38)) {
              uVar14 = (int)local_70 * 4 | local_6c;
              fVar16 = in_ECX[0xb];
              local_50 = *(float *)(*(int *)((int)fVar16 + (uVar14 >> 10) * 4) + 0xc +
                                   ((uVar14 >> 2 & 0xff) * 0xf + (&DAT_00b9575c)[local_6c & 3]) * 4)
              ;
              fVar15 = (float)(local_28 & 3);
              local_54 = *(uint *)(*(int *)((int)fVar16 + (local_28 >> 10) * 4) + 0xc +
                                  ((local_28 >> 2 & 0xff) * 0xf + (int)fVar15) * 4);
              uVar11 = *(undefined4 *)
                        (*(int *)((int)fVar16 + (local_28 >> 10) * 4) + 0xc +
                        ((local_28 >> 2 & 0xff) * 0xf + (&DAT_00b9575c)[(int)fVar15]) * 4);
              local_18 = *(undefined4 *)
                          (*(int *)((int)fVar16 + (uVar14 >> 10) * 4) + 0xc +
                          ((uVar14 >> 2 & 0xff) * 0xf + (local_6c & 3)) * 4);
              pfVar1 = in_ECX + 0x17;
              fVar16 = (float)((uint)in_ECX[0x17] >> 8);
              local_4c = fVar15;
              if ((uint)in_ECX[0x18] <= (uint)fVar16) {
                FUN_00606d10(fVar16);
              }
              puVar18 = (undefined4 *)
                        (*(int *)((int)in_ECX[0x1a] + (int)fVar16 * 4) +
                        ((uint)*pfVar1 & 0xff) * 0xc);
              *puVar18 = local_18;
              puVar18[1] = local_50;
              puVar18[2] = uVar11;
              *pfVar1 = (float)((int)*pfVar1 + 1);
              fVar16 = (float)((uint)*pfVar1 >> 8);
              if ((uint)in_ECX[0x18] <= (uint)fVar16) {
                FUN_00606d10(fVar16);
              }
              puVar18 = (undefined4 *)
                        (*(int *)((int)in_ECX[0x1a] + (int)fVar16 * 4) +
                        ((uint)*pfVar1 & 0xff) * 0xc);
              *puVar18 = uVar11;
              puVar18[1] = local_50;
              puVar18[2] = local_54;
              *pfVar1 = (float)((int)*pfVar1 + 1);
              pbVar3 = (byte *)(local_2c + 0x34 + (int)fVar15);
              *pbVar3 = *pbVar3 | 2;
              iVar17 = local_58;
            }
          }
          pbVar3 = (byte *)(iVar17 + 0x34 + local_6c);
          *pbVar3 = *pbVar3 | 2;
        }
        local_60 = local_60 + 1;
        local_6c = local_6c + 1;
      } while (local_6c < 3);
      local_70 = (float)((int)local_70 + 1);
    } while ((uint)local_70 < (uint)in_ECX[8]);
  }
  if (param_2 == 1) {
    fVar16 = *in_ECX;
    pfVar1 = in_ECX + 0x1b;
    if ((uint)in_ECX[0x1d] < (uint)fVar16) {
      FUN_00515cf0(*pfVar1);
      in_ECX[0x1d] = fVar16;
      if (fVar16 == 0.0) {
        fVar15 = 0.0;
      }
      else {
        local_28 = 2;
        fVar15 = (float)FUN_00515d60(pfVar1,(int)fVar16 * 4,&local_28);
      }
      *pfVar1 = fVar15;
    }
    in_ECX[0x1c] = fVar16;
    fVar15 = 0.0;
    fVar16 = 0.0;
    if (*in_ECX != 0.0) {
      do {
        *(float *)((int)in_ECX[0x1b] + (int)fVar15 * 4) = fVar16;
        iVar17 = *(int *)((int)in_ECX[3] + ((uint)fVar15 >> 8) * 4);
        puVar18 = (undefined4 *)(iVar17 + ((uint)fVar15 & 0xff) * 0xc);
        if ((*(uint *)(iVar17 + 8 + ((uint)fVar15 & 0xff) * 0xc) & 0x10000000) != 0) {
          puVar2 = (undefined4 *)
                   (*(int *)((int)in_ECX[3] + ((uint)fVar16 >> 8) * 4) + ((uint)fVar16 & 0xff) * 0xc
                   );
          *puVar2 = *puVar18;
          puVar2[1] = puVar18[1];
          puVar2[2] = puVar18[2];
          fVar16 = (float)((int)fVar16 + 1);
        }
        fVar15 = (float)((int)fVar15 + 1);
      } while ((uint)fVar15 < (uint)*in_ECX);
    }
    in_ECX[0x1e] = fVar16;
    if ((uint)fVar16 < (uint)*in_ECX) {
      *in_ECX = fVar16;
    }
    fVar16 = 0.0;
    if (in_ECX[0x17] != 0.0) {
      do {
        iVar7 = ((uint)fVar16 >> 8) * 4;
        iVar17 = *(int *)((int)in_ECX[0x1a] + iVar7);
        iVar8 = ((uint)fVar16 & 0xff) * 0xc;
        fVar15 = in_ECX[0x1b];
        local_24 = *(undefined4 *)((int)fVar15 + *(int *)(iVar17 + iVar8) * 4);
        local_1c = *(undefined4 *)((int)fVar15 + *(int *)(iVar17 + iVar8 + 8) * 4);
        local_20 = *(undefined4 *)((int)fVar15 + *(int *)(iVar17 + 4 + iVar8) * 4);
        local_c = FUN_00608020(local_24,local_20,local_1c);
        local_8 = FUN_00608020(local_20,local_1c,local_24);
        uVar11 = FUN_00608020(local_1c,local_24,local_20);
        puVar18 = (undefined4 *)(*(int *)((int)in_ECX[0x1a] + iVar7) + iVar8);
        *puVar18 = local_c;
        puVar18[1] = local_8;
        fVar16 = (float)((int)fVar16 + 1);
        puVar18[2] = uVar11;
      } while ((uint)fVar16 < (uint)in_ECX[0x17]);
    }
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00608120 : SUB ESP,0x74
00608123 : PUSH EBX
00608124 : PUSH ESI
00608125 : MOV ESI,ECX
00608127 : XOR EBX,EBX
00608129 : MOV dword ptr [ESI + 0x5c],EBX
0060812c : CALL 0x00607cc0
00608131 : FLDZ
00608133 : FLD float ptr [ESP + 0x80]
0060813a : FCOM
0060813c : FNSTSW AX
0060813e : FSTP ST1
00608140 : TEST AH,0x1
00608143 : JZ 0x00608d82
00608149 : MOV dword ptr [ESP + 0x28],0x90ffffff
00608151 : CMP dword ptr [ESP + 0x84],EBX
00608158 : JNZ 0x00608176
0060815a : MOV EAX,dword ptr [ESI + 0x7c]
0060815d : FADD ST0,ST0
0060815f : OR EAX,0x90000000
00608164 : MOV dword ptr [ESP + 0x28],EAX
00608168 : FSTP float ptr [ESP + 0x80]
0060816f : FLD float ptr [ESP + 0x80]
00608176 : FABS
00608178 : PUSH EBP
00608179 : FSTP float ptr [ESP + 0x34]
0060817d : PUSH EDI
0060817e : FLD float ptr [ESP + 0x38]
00608182 : MOV dword ptr [ESP + 0x14],EBX
00608186 : FMUL double ptr [0x00cdf530]
0060818c : FSTP float ptr [ESP + 0x34]
00608190 : CMP dword ptr [ESI + 0x20],EBX
00608193 : JBE 0x00608886
00608199 : LEA ESP,[ESP]
006081a0 : MOV EDX,dword ptr [ESI + 0x2c]
006081a3 : MOV EAX,EBX
006081a5 : AND EAX,0xff
006081aa : MOV EDI,EAX
006081ac : MOV ECX,EBX
006081ae : SHL EDI,0x4
006081b1 : SHR ECX,0x8
006081b4 : SUB EDI,EAX
006081b6 : MOV EAX,dword ptr [EDX + ECX*0x4]
006081b9 : LEA EAX,[EAX + EDI*0x4]
006081bc : XOR EDI,EDI
006081be : MOV dword ptr [ESP + 0x3c],EAX
006081c2 : MOV dword ptr [ESP + 0x18],EDI
006081c6 : MOV dword ptr [ESP + 0x1c],EAX
006081ca : JMP 0x006081d4
006081d0 : MOV EAX,dword ptr [ESP + 0x3c]
006081d4 : TEST byte ptr [EAX + EDI*0x1 + 0x34],0x1
006081d9 : JNZ 0x00608865
006081df : MOV ECX,dword ptr [ESP + 0x1c]
006081e3 : MOV EAX,dword ptr [ECX]
006081e5 : MOV ECX,dword ptr [ESI + 0xc]
006081e8 : MOV EDX,EAX
006081ea : SHR EDX,0x8
006081ed : MOV ECX,dword ptr [ECX + EDX*0x4]
006081f0 : AND EAX,0xff
006081f5 : LEA EAX,[EAX + EAX*0x2]
006081f8 : TEST dword ptr [ECX + EAX*0x4 + 0x8],0x20000000
00608200 : JNZ 0x00608865
00608206 : LEA EDX,[EDI + EBX*0x4]
00608209 : PUSH EDX
0060820a : MOV ECX,ESI
0060820c : CALL 0x00607d60
00608211 : CMP dword ptr [ESI + 0x3c],0x0
00608215 : MOV byte ptr [ESP + 0x13],AL
00608219 : JZ 0x00608865
0060821f : TEST AL,AL
00608221 : JZ 0x00608284
00608223 : MOV EAX,dword ptr [ESI + 0x48]
00608226 : MOV ECX,dword ptr [EAX]
00608228 : MOV EDX,dword ptr [ESI + 0x3c]
0060822b : MOV EDI,dword ptr [ESI + 0x48]
0060822e : MOV ECX,dword ptr [ECX]
00608230 : DEC EDX
00608231 : MOV EAX,EDX
00608233 : SHR EAX,0x6
00608236 : MOV EAX,dword ptr [EDI + EAX*0x4]
00608239 : MOV EDI,dword ptr [ESI + 0x2c]
0060823c : AND EDX,0x3f
0060823f : MOV EDX,dword ptr [EAX + EDX*0x4]
00608242 : SAR EDX,0x2
00608245 : MOV EAX,EDX
00608247 : AND EDX,0xff
0060824d : SHR EAX,0x8
00608250 : MOV EBX,EDX
00608252 : SAR ECX,0x2
00608255 : SHL EBX,0x4
00608258 : SUB EBX,EDX
0060825a : MOV EDX,dword ptr [EDI + EAX*0x4]
0060825d : MOV EAX,ECX
0060825f : AND ECX,0xff
00608265 : MOV EBP,ECX
00608267 : SHR EAX,0x8
0060826a : SHL EBP,0x4
0060826d : SUB EBP,ECX
0060826f : MOV ECX,dword ptr [EDI + EAX*0x4]
00608272 : MOV EAX,dword ptr [ECX + EBP*0x4 + 0x38]
00608276 : CMP EAX,dword ptr [EDX + EBX*0x4 + 0x38]
0060827a : JZ 0x0060885d
00608280 : MOV AL,byte ptr [ESP + 0x13]
00608284 : MOV ECX,dword ptr [ESP + 0x1c]
00608288 : MOV EBX,dword ptr [ESI + 0xc]
0060828b : LEA EDI,[ESI + 0x4c]
0060828e : MOV dword ptr [EDI],0x0
00608294 : MOV ECX,dword ptr [ECX]
00608296 : MOV EDX,ECX
00608298 : AND ECX,0xff
0060829e : SHR EDX,0x8
006082a1 : MOV EDX,dword ptr [EBX + EDX*0x4]
006082a4 : LEA ECX,[ECX + ECX*0x2]
006082a7 : LEA ECX,[EDX + ECX*0x4]
006082aa : MOV dword ptr [ESP + 0x54],ECX
006082ae : TEST AL,AL
006082b0 : JNZ 0x006083c1
006082b6 : FLD float ptr [ESP + 0x34]
006082ba : LEA EDX,[ESP + 0x2c]
006082be : PUSH EDX
006082bf : LEA EAX,[ESP + 0x2c]
006082c3 : PUSH EAX
006082c4 : MOV EAX,dword ptr [ESI + 0x3c]
006082c7 : DEC EAX
006082c8 : PUSH EAX
006082c9 : PUSH 0x0
006082cb : SUB ESP,0x8
006082ce : FSTP float ptr [ESP + 0x4]
006082d2 : MOV ECX,ESI
006082d4 : FLD float ptr [ESP + 0xa0]
006082db : FCHS
006082dd : FSTP float ptr [ESP]
006082e0 : CALL 0x006063f0
006082e5 : MOV EBP,dword ptr [ESI]
006082e7 : FLD float ptr [ESP + 0x28]
006082eb : MOV EBX,EBP
006082ed : FSTP float ptr [ESP + 0x6c]
006082f1 : FLD float ptr [ESP + 0x2c]
006082f5 : SHR EBX,0x8
006082f8 : FSTP float ptr [ESP + 0x70]
006082fc : CMP EBX,dword ptr [ESI + 0x4]
006082ff : JC 0x00608309
00608301 : PUSH EBX
00608302 : MOV ECX,ESI
00608304 : CALL 0x00606d10
00608309 : MOV EAX,dword ptr [ESI]
0060830b : MOV ECX,dword ptr [ESI + 0xc]
0060830e : AND EAX,0xff
00608313 : LEA EDX,[EAX + EAX*0x2]
00608316 : MOV EAX,dword ptr [ECX + EBX*0x4]
00608319 : MOV ECX,dword ptr [ESP + 0x6c]
0060831d : LEA EAX,[EAX + EDX*0x4]
00608320 : MOV EDX,dword ptr [ESP + 0x70]
00608324 : MOV dword ptr [EAX],ECX
00608326 : MOV ECX,dword ptr [ESP + 0x30]
0060832a : MOV dword ptr [EAX + 0x4],EDX
0060832d : MOV dword ptr [EAX + 0x8],ECX
00608330 : INC dword ptr [ESI]
00608332 : MOV EBX,dword ptr [EDI]
00608334 : SHR EBX,0x6
00608337 : CMP EBX,dword ptr [EDI + 0x4]
0060833a : JC 0x00608344
0060833c : PUSH EBX
0060833d : MOV ECX,EDI
0060833f : CALL 0x00606e60
00608344 : MOV EDX,dword ptr [EDI + 0xc]
00608347 : MOV EAX,dword ptr [EDI]
00608349 : MOV ECX,dword ptr [EDX + EBX*0x4]
0060834c : AND EAX,0x3f
0060834f : MOV dword ptr [ECX + EAX*0x4],EBP
00608352 : INC dword ptr [EDI]
00608354 : MOV EDX,dword ptr [ESI + 0x48]
00608357 : MOV EAX,dword ptr [EDX]
00608359 : MOV ECX,dword ptr [EAX]
0060835b : MOV EAX,ECX
0060835d : SHR EAX,0x2
00608360 : MOV EDX,EAX
00608362 : AND EDX,0xff
00608368 : MOV EDI,EDX
0060836a : SHL EDI,0x4
0060836d : SUB EDI,EDX
0060836f : AND ECX,0x3
00608372 : ADD EDI,dword ptr [ECX*0x4 + 0xb9575c]
00608379 : MOV ECX,dword ptr [ESI + 0x2c]
0060837c : SHR EAX,0x8
0060837f : MOV EDX,dword ptr [ECX + EAX*0x4]
00608382 : MOV dword ptr [EDX + EDI*0x4 + 0x28],EBP
00608386 : MOV EAX,dword ptr [ESI + 0x3c]
00608389 : MOV EDX,dword ptr [ESI + 0x48]
0060838c : DEC EAX
0060838d : MOV ECX,EAX
0060838f : SHR ECX,0x6
00608392 : MOV ECX,dword ptr [EDX + ECX*0x4]
00608395 : AND EAX,0x3f
00608398 : MOV EAX,dword ptr [ECX + EAX*0x4]
0060839b : MOV ECX,EAX
0060839d : SHR ECX,0x2
006083a0 : MOV EDX,ECX
006083a2 : AND EDX,0xff
006083a8 : MOV EDI,EDX
006083aa : SHL EDI,0x4
006083ad : SUB EDI,EDX
006083af : MOV EDX,dword ptr [ESI + 0x2c]
006083b2 : AND EAX,0x3
006083b5 : ADD EDI,EAX
006083b7 : SHR ECX,0x8
006083ba : MOV EAX,dword ptr [EDX + ECX*0x4]
006083bd : MOV dword ptr [EAX + EDI*0x4 + 0x28],EBP
006083c1 : CMP dword ptr [ESP + 0x8c],0x1
006083c9 : JNZ 0x00608838
006083cf : XOR EDI,EDI
006083d1 : MOV dword ptr [ESP + 0x20],EDI
006083d5 : CMP dword ptr [ESI + 0x3c],EDI
006083d8 : JBE 0x00608696
006083de : JMP 0x006083e4
006083e0 : MOV EDI,dword ptr [ESP + 0x20]
006083e4 : MOV ECX,dword ptr [ESI + 0x48]
006083e7 : MOV EDX,EDI
006083e9 : SHR EDX,0x6
006083ec : MOV EDX,dword ptr [ECX + EDX*0x4]
006083ef : MOV EAX,EDI
006083f1 : AND EAX,0x3f
006083f4 : MOV EAX,dword ptr [EDX + EAX*0x4]
006083f7 : MOV EDX,dword ptr [ESI + 0x2c]
006083fa : SAR EAX,0x2
006083fd : MOV EBX,EAX
006083ff : AND EAX,0xff
00608404 : MOV EBP,EAX
00608406 : SHL EBP,0x4
00608409 : SUB EBP,EAX
0060840b : SHR EBX,0x8
0060840e : MOV EAX,dword ptr [EDX + EBX*0x4]
00608411 : LEA EAX,[EAX + EBP*0x4]
00608414 : LEA EBP,[EDI + 0x1]
00608417 : MOV dword ptr [ESP + 0x24],EBP
0060841b : CMP EBP,dword ptr [ESI + 0x3c]
0060841e : JNC 0x00608466
00608420 : MOV EAX,dword ptr [EAX + 0x38]
00608423 : MOV dword ptr [ESP + 0x38],EAX
00608427 : MOV EAX,EBP
00608429 : SHR EAX,0x6
0060842c : MOV EAX,dword ptr [ECX + EAX*0x4]
0060842f : MOV EDI,EBP
00608431 : AND EDI,0x3f
00608434 : MOV EAX,dword ptr [EAX + EDI*0x4]
00608437 : SAR EAX,0x2
0060843a : MOV EDI,EAX
0060843c : AND EAX,0xff
00608441 : MOV EBX,EAX
00608443 : SHR EDI,0x8
00608446 : SHL EBX,0x4
00608449 : SUB EBX,EAX
0060844b : MOV EAX,dword ptr [EDX + EDI*0x4]
0060844e : MOV EDI,dword ptr [ESP + 0x38]
00608452 : CMP EDI,dword ptr [EAX + EBX*0x4 + 0x38]
00608456 : JNZ 0x0060845e
00608458 : INC EBP
00608459 : CMP EBP,dword ptr [ESI + 0x3c]
0060845c : JC 0x00608427
0060845e : MOV EDI,dword ptr [ESP + 0x20]
00608462 : MOV dword ptr [ESP + 0x24],EBP
00608466 : FLD float ptr [ESP + 0x34]
0060846a : LEA ECX,[ESP + 0x2c]
0060846e : PUSH ECX
0060846f : LEA EDX,[ESP + 0x2c]
00608473 : PUSH EDX
00608474 : LEA EAX,[EBP + -0x1]
00608477 : PUSH EAX
00608478 : PUSH EDI
00608479 : SUB ESP,0x8
0060847c : FSTP float ptr [ESP + 0x4]
00608480 : MOV ECX,ESI
00608482 : FLD float ptr [ESP + 0xa0]
00608489 : FSTP float ptr [ESP]
0060848c : CALL 0x006063f0
00608491 : MOV EDI,dword ptr [ESI]
00608493 : FLD float ptr [ESP + 0x28]
00608497 : FSTP float ptr [ESP + 0x78]
0060849b : MOV dword ptr [ESP + 0x38],EDI
0060849f : FLD float ptr [ESP + 0x2c]
006084a3 : SHR EDI,0x8
006084a6 : FSTP float ptr [ESP + 0x7c]
006084aa : CMP EDI,dword ptr [ESI + 0x4]
006084ad : JC 0x0060850d
006084af : MOV ECX,dword ptr [ESI + 0x8]
006084b2 : CMP EDI,ECX
006084b4 : JC 0x006084ec
006084b6 : MOV EAX,dword ptr [ESI + 0xc]
006084b9 : TEST EAX,EAX
006084bb : JZ 0x006084cd
006084bd : LEA ECX,[ECX*0x4 + 0x100]
006084c4 : PUSH ECX
006084c5 : PUSH EAX
006084c6 : CALL 0x00515c80
006084cb : JMP 0x006084e5
006084cd : LEA ECX,[ESP + 0x40]
006084d1 : PUSH ECX
006084d2 : PUSH 0x100
006084d7 : PUSH ESI
006084d8 : MOV dword ptr [ESP + 0x4c],0x88
006084e0 : CALL 0x00515d60
006084e5 : ADD dword ptr [ESI + 0x8],0x40
006084e9 : MOV dword ptr [ESI + 0xc],EAX
006084ec : LEA EDX,[ESP + 0x44]
006084f0 : PUSH EDX
006084f1 : PUSH 0xc00
006084f6 : PUSH ESI
006084f7 : MOV dword ptr [ESP + 0x50],0x88
006084ff : CALL 0x00515d60
00608504 : MOV ECX,dword ptr [ESI + 0xc]
00608507 : MOV dword ptr [ECX + EDI*0x4],EAX
0060850a : INC dword ptr [ESI + 0x4]
0060850d : MOV EAX,dword ptr [ESI]
0060850f : MOV EDX,dword ptr [ESI + 0xc]
00608512 : MOV ECX,dword ptr [EDX + EDI*0x4]
00608515 : MOV EDX,dword ptr [ESP + 0x78]
00608519 : AND EAX,0xff
0060851e : LEA EAX,[EAX + EAX*0x2]
00608521 : LEA EAX,[ECX + EAX*0x4]
00608524 : MOV ECX,dword ptr [ESP + 0x7c]
00608528 : MOV dword ptr [EAX],EDX
0060852a : MOV EDX,dword ptr [ESP + 0x30]
0060852e : MOV dword ptr [EAX + 0x4],ECX
00608531 : MOV dword ptr [EAX + 0x8],EDX
00608534 : INC dword ptr [ESI]
00608536 : MOV EBX,dword ptr [ESI + 0x4c]
00608539 : LEA EDI,[ESI + 0x4c]
0060853c : SHR EBX,0x6
0060853f : CMP EBX,dword ptr [EDI + 0x4]
00608542 : JC 0x0060859f
00608544 : MOV ECX,dword ptr [EDI + 0x8]
00608547 : CMP EBX,ECX
00608549 : JC 0x0060857e
0060854b : MOV EAX,dword ptr [EDI + 0xc]
0060854e : TEST EAX,EAX
00608550 : JZ 0x00608562
00608552 : LEA ECX,[ECX*0x4 + 0x40]
00608559 : PUSH ECX
0060855a : PUSH EAX
0060855b : CALL 0x00515c80
00608560 : JMP 0x00608577
00608562 : LEA EAX,[ESP + 0x48]
00608566 : PUSH EAX
00608567 : PUSH 0x40
00608569 : PUSH EDI
0060856a : MOV dword ptr [ESP + 0x54],0x88
00608572 : CALL 0x00515d60
00608577 : ADD dword ptr [EDI + 0x8],0x10
0060857b : MOV dword ptr [EDI + 0xc],EAX
0060857e : LEA ECX,[ESP + 0x4c]
00608582 : PUSH ECX
00608583 : PUSH 0x100
00608588 : PUSH EDI
00608589 : MOV dword ptr [ESP + 0x58],0x88
00608591 : CALL 0x00515d60
00608596 : MOV EDX,dword ptr [EDI + 0xc]
00608599 : MOV dword ptr [EDX + EBX*0x4],EAX
0060859c : INC dword ptr [EDI + 0x4]
0060859f : MOV EAX,dword ptr [EDI + 0xc]
006085a2 : MOV EDX,dword ptr [EAX + EBX*0x4]
006085a5 : MOV ECX,dword ptr [EDI]
006085a7 : MOV EAX,dword ptr [ESP + 0x38]
006085ab : MOV EBX,dword ptr [ESP + 0x20]
006085af : AND ECX,0x3f
006085b2 : MOV dword ptr [EDX + ECX*0x4],EAX
006085b5 : INC dword ptr [EDI]
006085b7 : MOV EAX,dword ptr [ESI]
006085b9 : MOV EDX,dword ptr [ESI + 0xc]
006085bc : DEC EAX
006085bd : MOV ECX,EAX
006085bf : SHR ECX,0x8
006085c2 : MOV ECX,dword ptr [EDX + ECX*0x4]
006085c5 : AND EAX,0xff
006085ca : LEA EAX,[EAX + EAX*0x2]
006085cd : LEA EDX,[ECX + EAX*0x4]
006085d0 : MOV dword ptr [ESP + 0x50],EDX
006085d4 : CMP EBX,EBP
006085d6 : JNC 0x00608685
006085dc : FLD float ptr [ESP + 0x88]
006085e3 : FCHS
006085e5 : FSTP float ptr [ESP + 0x20]
006085e9 : LEA ESP,[ESP]
006085f0 : MOV ECX,dword ptr [ESI + 0x48]
006085f3 : FLD float ptr [ESP + 0x20]
006085f7 : MOV EDI,dword ptr [ESI + 0x2c]
006085fa : MOV EAX,EBX
006085fc : SHR EAX,0x6
006085ff : MOV EAX,dword ptr [ECX + EAX*0x4]
00608602 : MOV EDX,EBX
00608604 : AND EDX,0x3f
00608607 : MOV EAX,dword ptr [EAX + EDX*0x4]
0060860a : MOV ECX,EAX
0060860c : AND ECX,0x3
0060860f : AND EAX,0xfffffffc
00608612 : OR EAX,dword ptr [ECX*0x4 + 0xb9575c]
00608619 : MOV ECX,EAX
0060861b : SHR ECX,0x2
0060861e : MOV EDX,ECX
00608620 : AND ECX,0xff
00608626 : MOV EBP,ECX
00608628 : SHR EDX,0x8
0060862b : SHL EBP,0x4
0060862e : SUB EBP,ECX
00608630 : MOV ECX,dword ptr [EDI + EDX*0x4]
00608633 : MOV EDX,dword ptr [ESP + 0x1c]
00608637 : LEA EBP,[ECX + EBP*0x4]
0060863a : MOV ECX,dword ptr [EDX]
0060863c : PUSH ECX
0060863d : MOV EDI,EAX
0060863f : FSTP float ptr [ESP]
00608642 : MOV EAX,dword ptr [ESP + 0x54]
00608646 : PUSH EAX
00608647 : MOV EAX,dword ptr [ESI + 0xc]
0060864a : MOV EDX,ECX
0060864c : AND ECX,0xff
00608652 : SHR EDX,0x8
00608655 : MOV EDX,dword ptr [EAX + EDX*0x4]
00608658 : AND EDI,0x3
0060865b : PUSH EDI
0060865c : LEA ECX,[ECX + ECX*0x2]
0060865f : LEA EAX,[EDX + ECX*0x4]
00608662 : PUSH EBP
00608663 : PUSH EAX
00608664 : MOV ECX,ESI
00608666 : CALL 0x006069b0
0060866b : MOV ECX,dword ptr [ESP + 0x38]
0060866f : MOV dword ptr [EBP + EDI*0x4 + 0xc],ECX
00608673 : OR byte ptr [EDI + EBP*0x1 + 0x34],0x1
00608678 : ADD EBX,0x2
0060867b : CMP EBX,dword ptr [ESP + 0x24]
0060867f : JC 0x006085f0
00608685 : MOV EAX,dword ptr [ESP + 0x24]
00608689 : MOV dword ptr [ESP + 0x20],EAX
0060868d : CMP EAX,dword ptr [ESI + 0x3c]
00608690 : JC 0x006083e0
00608696 : CMP dword ptr [ESI + 0x4c],0x2
0060869a : LEA EDI,[ESI + 0x4c]
0060869d : JBE 0x00608838
006086a3 : MOV EBX,dword ptr [EDI]
006086a5 : FLDZ
006086a7 : XOR EBP,EBP
006086a9 : FSTP float ptr [ESP + 0x38]
006086ad : XOR EDI,EDI
006086af : TEST EBX,EBX
006086b1 : JBE 0x00608743
006086b7 : MOV EAX,dword ptr [ESI + 0x58]
006086ba : MOV EDX,EDI
006086bc : SHR EDX,0x6
006086bf : MOV EDX,dword ptr [EAX + EDX*0x4]
006086c2 : MOV ECX,EDI
006086c4 : AND ECX,0x3f
006086c7 : MOV EAX,dword ptr [EDX + ECX*0x4]
006086ca : MOV ECX,EAX
006086cc : AND EAX,0xff
006086d1 : LEA EDX,[EAX + EAX*0x2]
006086d4 : MOV EAX,dword ptr [ESI + 0xc]
006086d7 : SHR ECX,0x8
006086da : MOV EAX,dword ptr [EAX + ECX*0x4]
006086dd : MOV ECX,dword ptr [ESP + 0x54]
006086e1 : FLD float ptr [ECX]
006086e3 : LEA EAX,[EAX + EDX*0x4]
006086e6 : FSUB float ptr [EAX]
006086e8 : FSTP float ptr [ESP + 0x50]
006086ec : FLD float ptr [ECX + 0x4]
006086ef : FSUB float ptr [EAX + 0x4]
006086f2 : FSTP float ptr [ESP + 0x24]
006086f6 : FLD float ptr [ESP + 0x50]
006086fa : FLD float ptr [ESP + 0x24]
006086fe : FMUL ST0
00608700 : FLD ST1
00608702 : FMULP ST2
00608704 : FADDP
00608706 : FSTP float ptr [ESP + 0x50]
0060870a : FLD float ptr [ESP + 0x50]
0060870e : CALL 0x0063bdc0
00608713 : FSTP float ptr [ESP + 0x50]
00608717 : FLD float ptr [ESP + 0x50]
0060871b : FSTP float ptr [ESP + 0x50]
0060871f : FLD float ptr [ESP + 0x50]
00608723 : FLD float ptr [ESP + 0x38]
00608727 : FCOMP
00608729 : FNSTSW AX
0060872b : TEST AH,0x5
0060872e : JP 0x00608738
00608730 : FSTP float ptr [ESP + 0x38]
00608734 : MOV EBP,EDI
00608736 : JMP 0x0060873a
00608738 : FSTP ST0
0060873a : INC EDI
0060873b : CMP EDI,EBX
0060873d : JC 0x006086b7
00608743 : XOR EDX,EDX
00608745 : LEA EAX,[EBP + 0x1]
00608748 : DIV EBX
0060874a : LEA EAX,[EBX + EBP*0x1 + -0x1]
0060874e : MOV ECX,EDX
00608750 : XOR EDX,EDX
00608752 : DIV EBX
00608754 : MOV EAX,dword ptr [ESI + 0x58]
00608757 : MOV EBX,dword ptr [ESI + 0x5c]
0060875a : SHR EBX,0x8
0060875d : MOV EDI,EDX
0060875f : AND EDX,0x3f
00608762 : SHR EDI,0x6
00608765 : MOV EDI,dword ptr [EAX + EDI*0x4]
00608768 : MOV EDX,dword ptr [EDI + EDX*0x4]
0060876b : MOV dword ptr [ESP + 0x60],EDX
0060876f : MOV EDX,EBP
00608771 : SHR EDX,0x6
00608774 : MOV EDX,dword ptr [EAX + EDX*0x4]
00608777 : MOV EDI,EBP
00608779 : AND EDI,0x3f
0060877c : MOV EDX,dword ptr [EDX + EDI*0x4]
0060877f : MOV dword ptr [ESP + 0x64],EDX
00608783 : MOV EDX,ECX
00608785 : LEA EDI,[ESI + 0x5c]
00608788 : SHR EDX,0x6
0060878b : MOV EAX,dword ptr [EAX + EDX*0x4]
0060878e : AND ECX,0x3f
00608791 : MOV ECX,dword ptr [EAX + ECX*0x4]
00608794 : MOV dword ptr [ESP + 0x68],ECX
00608798 : CMP EBX,dword ptr [EDI + 0x4]
0060879b : JC 0x006087fb
0060879d : MOV ECX,dword ptr [EDI + 0x8]
006087a0 : CMP EBX,ECX
006087a2 : JC 0x006087da
006087a4 : MOV EAX,dword ptr [EDI + 0xc]
006087a7 : TEST EAX,EAX
006087a9 : JZ 0x006087bb
006087ab : LEA ECX,[ECX*0x4 + 0x100]
006087b2 : PUSH ECX
006087b3 : PUSH EAX
006087b4 : CALL 0x00515c80
006087b9 : JMP 0x006087d3
006087bb : LEA EDX,[ESP + 0x58]
006087bf : PUSH EDX
006087c0 : PUSH 0x100
006087c5 : PUSH EDI
006087c6 : MOV dword ptr [ESP + 0x64],0x88
006087ce : CALL 0x00515d60
006087d3 : ADD dword ptr [EDI + 0x8],0x40
006087d7 : MOV dword ptr [EDI + 0xc],EAX
006087da : LEA EAX,[ESP + 0x5c]
006087de : PUSH EAX
006087df : PUSH 0xc00
006087e4 : PUSH EDI
006087e5 : MOV dword ptr [ESP + 0x68],0x88
006087ed : CALL 0x00515d60
006087f2 : MOV ECX,dword ptr [EDI + 0xc]
006087f5 : MOV dword ptr [ECX + EBX*0x4],EAX
006087f8 : INC dword ptr [EDI + 0x4]
006087fb : MOV EAX,dword ptr [EDI]
006087fd : MOV EDX,dword ptr [EDI + 0xc]
00608800 : MOV ECX,dword ptr [EDX + EBX*0x4]
00608803 : MOV EDX,dword ptr [ESP + 0x60]
00608807 : AND EAX,0xff
0060880c : LEA EAX,[EAX + EAX*0x2]
0060880f : LEA EAX,[ECX + EAX*0x4]
00608812 : MOV ECX,dword ptr [ESP + 0x64]
00608816 : MOV dword ptr [EAX],EDX
00608818 : MOV EDX,dword ptr [ESP + 0x68]
0060881c : MOV dword ptr [EAX + 0x4],ECX
0060881f : MOV dword ptr [EAX + 0x8],EDX
00608822 : INC dword ptr [EDI]
00608824 : LEA EDI,[ESI + 0x4c]
00608827 : PUSH EBP
00608828 : MOV ECX,EDI
0060882a : CALL 0x00606c50
0060882f : CMP dword ptr [EDI],0x2
00608832 : JA 0x006086a3
00608838 : MOV EAX,dword ptr [ESP + 0x1c]
0060883c : MOV EAX,dword ptr [EAX]
0060883e : MOV EDX,dword ptr [ESI + 0xc]
00608841 : MOV ECX,EAX
00608843 : AND EAX,0xff
00608848 : SHR ECX,0x8
0060884b : MOV ECX,dword ptr [EDX + ECX*0x4]
0060884e : LEA EAX,[EAX + EAX*0x2]
00608851 : OR dword ptr [ECX + EAX*0x4 + 0x8],0x20000000
00608859 : LEA EAX,[ECX + EAX*0x4 + 0x8]
0060885d : MOV EDI,dword ptr [ESP + 0x18]
00608861 : MOV EBX,dword ptr [ESP + 0x14]
00608865 : ADD dword ptr [ESP + 0x1c],0x4
0060886a : INC EDI
0060886b : MOV dword ptr [ESP + 0x18],EDI
0060886f : CMP EDI,0x3
00608872 : JC 0x006081d0
00608878 : INC EBX
00608879 : MOV dword ptr [ESP + 0x14],EBX
0060887d : CMP EBX,dword ptr [ESI + 0x20]
00608880 : JC 0x006081a0
00608886 : XOR EAX,EAX
00608888 : MOV dword ptr [ESP + 0x14],EAX
0060888c : CMP dword ptr [ESI + 0x20],EAX
0060888f : JBE 0x00608c05
00608895 : MOV ECX,dword ptr [ESI + 0x2c]
00608898 : MOV EDX,EAX
0060889a : AND EAX,0xff
0060889f : MOV EDI,EAX
006088a1 : SHL EDI,0x4
006088a4 : SHR EDX,0x8
006088a7 : MOV EDX,dword ptr [ECX + EDX*0x4]
006088aa : SUB EDI,EAX
006088ac : MOV EAX,dword ptr [EDX + EDI*0x4 + 0xc]
006088b0 : MOV EBP,dword ptr [EDX + EDI*0x4 + 0x10]
006088b4 : LEA EDI,[EDX + EDI*0x4]
006088b7 : MOV dword ptr [ESP + 0x2c],EDI
006088bb : MOV dword ptr [ESP + 0x5c],EAX
006088bf : CMP EAX,EBP
006088c1 : JZ 0x00608917
006088c3 : MOV ECX,dword ptr [EDI + 0x14]
006088c6 : MOV dword ptr [ESP + 0x58],ECX
006088ca : CMP EBP,ECX
006088cc : JZ 0x00608917
006088ce : CMP ECX,EAX
006088d0 : JZ 0x00608917
006088d2 : MOV ECX,dword ptr [ESI + 0x5c]
006088d5 : LEA EBX,[ESI + 0x5c]
006088d8 : SHR ECX,0x8
006088db : MOV dword ptr [ESP + 0x38],ECX
006088df : CMP ECX,dword ptr [EBX + 0x4]
006088e2 : JC 0x006088f2
006088e4 : MOV EAX,ECX
006088e6 : PUSH EAX
006088e7 : MOV ECX,EBX
006088e9 : CALL 0x00606d10
006088ee : MOV ECX,dword ptr [ESP + 0x38]
006088f2 : MOV EAX,dword ptr [EBX]
006088f4 : MOV EDX,dword ptr [EBX + 0xc]
006088f7 : MOV ECX,dword ptr [EDX + ECX*0x4]
006088fa : MOV EDX,dword ptr [ESP + 0x5c]
006088fe : AND EAX,0xff
00608903 : LEA EAX,[EAX + EAX*0x2]
00608906 : LEA EAX,[ECX + EAX*0x4]
00608909 : MOV ECX,dword ptr [ESP + 0x58]
0060890d : MOV dword ptr [EAX],EDX
0060890f : MOV dword ptr [EAX + 0x4],EBP
00608912 : MOV dword ptr [EAX + 0x8],ECX
00608915 : INC dword ptr [EBX]
00608917 : XOR ECX,ECX
00608919 : LEA EDX,[EDI + 0x1c]
0060891c : MOV dword ptr [ESP + 0x18],ECX
00608920 : MOV dword ptr [ESP + 0x24],EDX
00608924 : MOV EAX,dword ptr [ESP + 0x24]
00608928 : MOV EAX,dword ptr [EAX + -0x10]
0060892b : MOV EDX,dword ptr [EDI + 0x38]
0060892e : MOV EBP,dword ptr [ESI + 0xc]
00608931 : MOV EBX,EAX
00608933 : SHR EBX,0x8
00608936 : MOV EBX,dword ptr [EBP + EBX*0x4]
0060893a : AND EAX,0xff
0060893f : OR EDX,0x10000000
00608945 : LEA EAX,[EAX + EAX*0x2]
00608948 : MOV dword ptr [EBX + EAX*0x4 + 0x8],EDX
0060894c : TEST byte ptr [EDI + ECX*0x1 + 0x34],0x2
00608951 : JNZ 0x00608be0
00608957 : MOV EDX,dword ptr [ESP + 0x24]
0060895b : MOV EAX,dword ptr [EDX]
0060895d : MOV dword ptr [ESP + 0x5c],EAX
00608961 : TEST EAX,EAX
00608963 : JGE 0x00608a64
00608969 : MOV EAX,dword ptr [ECX*0x4 + 0xb9575c]
00608970 : MOV EAX,dword ptr [EDI + EAX*0x4 + 0x28]
00608974 : MOV EDX,dword ptr [EDX + 0xc]
00608977 : MOV dword ptr [ESP + 0x30],EAX
0060897b : MOV dword ptr [ESP + 0x20],EDX
0060897f : TEST EAX,EAX
00608981 : JL 0x00608bdb
00608987 : TEST EDX,EDX
00608989 : JL 0x00608bdb
0060898f : MOV EAX,dword ptr [ESP + 0x14]
00608993 : ADD EAX,EAX
00608995 : ADD EAX,EAX
00608997 : OR EAX,ECX
00608999 : MOV EDX,EAX
0060899b : SHR EDX,0x2
0060899e : MOV EDI,EDX
006089a0 : AND EDI,0xff
006089a6 : MOV EBP,EDI
006089a8 : SHL EBP,0x4
006089ab : MOV EBX,EAX
006089ad : AND EBX,0x3
006089b0 : SUB EBP,EDI
006089b2 : ADD EBP,dword ptr [EBX*0x4 + 0xb9575c]
006089b9 : MOV EDI,dword ptr [ESI + 0x2c]
006089bc : SHR EDX,0x8
006089bf : MOV EDX,dword ptr [EDI + EDX*0x4]
006089c2 : MOV EBP,dword ptr [EDX + EBP*0x4 + 0xc]
006089c6 : MOV ECX,EAX
006089c8 : SHR ECX,0x2
006089cb : MOV EDX,ECX
006089cd : AND EDX,0xff
006089d3 : MOV EBX,EDX
006089d5 : SHL EBX,0x4
006089d8 : SUB EBX,EDX
006089da : AND EAX,0x3
006089dd : ADD EBX,EAX
006089df : SHR ECX,0x8
006089e2 : MOV EAX,dword ptr [EDI + ECX*0x4]
006089e5 : MOV ECX,dword ptr [EAX + EBX*0x4 + 0xc]
006089e9 : MOV EBX,dword ptr [ESI + 0x5c]
006089ec : LEA EDI,[ESI + 0x5c]
006089ef : SHR EBX,0x8
006089f2 : MOV dword ptr [ESP + 0x78],ECX
006089f6 : CMP EBX,dword ptr [EDI + 0x4]
006089f9 : JC 0x00608a03
006089fb : PUSH EBX
006089fc : MOV ECX,EDI
006089fe : CALL 0x00606d10
00608a03 : MOV EAX,dword ptr [EDI]
00608a05 : MOV EDX,dword ptr [EDI + 0xc]
00608a08 : MOV ECX,dword ptr [EDX + EBX*0x4]
00608a0b : MOV EDX,dword ptr [ESP + 0x78]
00608a0f : AND EAX,0xff
00608a14 : LEA EAX,[EAX + EAX*0x2]
00608a17 : LEA EAX,[ECX + EAX*0x4]
00608a1a : MOV ECX,dword ptr [ESP + 0x20]
00608a1e : MOV dword ptr [EAX],EDX
00608a20 : MOV dword ptr [EAX + 0x4],EBP
00608a23 : MOV dword ptr [EAX + 0x8],ECX
00608a26 : INC dword ptr [EDI]
00608a28 : MOV EBX,dword ptr [EDI]
00608a2a : SHR EBX,0x8
00608a2d : CMP EBX,dword ptr [EDI + 0x4]
00608a30 : JC 0x00608a3a
00608a32 : PUSH EBX
00608a33 : MOV ECX,EDI
00608a35 : CALL 0x00606d10
00608a3a : MOV EAX,dword ptr [EDI]
00608a3c : MOV EDX,dword ptr [EDI + 0xc]
00608a3f : MOV ECX,dword ptr [EDX + EBX*0x4]
00608a42 : MOV EDX,dword ptr [ESP + 0x20]
00608a46 : AND EAX,0xff
00608a4b : LEA EAX,[EAX + EAX*0x2]
00608a4e : LEA EAX,[ECX + EAX*0x4]
00608a51 : MOV ECX,dword ptr [ESP + 0x30]
00608a55 : MOV dword ptr [EAX],EDX
00608a57 : MOV dword ptr [EAX + 0x4],EBP
00608a5a : MOV dword ptr [EAX + 0x8],ECX
00608a5d : INC dword ptr [EDI]
00608a5f : JMP 0x00608bd3
00608a64 : MOV EDX,dword ptr [ESI + 0x2c]
00608a67 : SAR EAX,0x2
00608a6a : MOV EBX,EAX
00608a6c : AND EAX,0xff
00608a71 : MOV EBP,EAX
00608a73 : SHR EBX,0x8
00608a76 : MOV EDX,dword ptr [EDX + EBX*0x4]
00608a79 : SHL EBP,0x4
00608a7c : SUB EBP,EAX
00608a7e : LEA EAX,[EDX + EBP*0x4]
00608a81 : MOV dword ptr [ESP + 0x58],EAX
00608a85 : MOV EAX,dword ptr [EAX + 0x38]
00608a88 : CMP EAX,dword ptr [EDI + 0x38]
00608a8b : JZ 0x00608bdb
00608a91 : MOV EAX,dword ptr [ESP + 0x14]
00608a95 : ADD EAX,EAX
00608a97 : ADD EAX,EAX
00608a99 : OR EAX,ECX
00608a9b : MOV ECX,EAX
00608a9d : SHR ECX,0x2
00608aa0 : MOV EDI,ECX
00608aa2 : AND EDI,0xff
00608aa8 : SHR ECX,0x8
00608aab : MOV EBP,EDI
00608aad : SHL EBP,0x4
00608ab0 : SUB EBP,EDI
00608ab2 : MOV EDI,dword ptr [ESI + 0x2c]
00608ab5 : MOV ECX,dword ptr [EDI + ECX*0x4]
00608ab8 : MOV EBX,EAX
00608aba : AND EBX,0x3
00608abd : ADD EBP,dword ptr [EBX*0x4 + 0xb9575c]
00608ac4 : MOV EBX,dword ptr [ESP + 0x5c]
00608ac8 : MOV ECX,dword ptr [ECX + EBP*0x4 + 0xc]
00608acc : MOV dword ptr [ESP + 0x34],ECX
00608ad0 : MOV ECX,EBX
00608ad2 : AND EBX,0x3
00608ad5 : MOV dword ptr [ESP + 0x38],EBX
00608ad9 : SHR ECX,0x2
00608adc : MOV EBX,ECX
00608ade : AND EBX,0xff
00608ae4 : MOV EBP,EBX
00608ae6 : SHL EBP,0x4
00608ae9 : SUB EBP,EBX
00608aeb : ADD EBP,dword ptr [ESP + 0x38]
00608aef : MOV EBX,ECX
00608af1 : SHR EBX,0x8
00608af4 : MOV EBX,dword ptr [EDI + EBX*0x4]
00608af7 : MOV EBX,dword ptr [EBX + EBP*0x4 + 0xc]
00608afb : MOV dword ptr [ESP + 0x30],EBX
00608aff : MOV EBX,ECX
00608b01 : AND EBX,0xff
00608b07 : MOV EBP,EBX
00608b09 : SHL EBP,0x4
00608b0c : SUB EBP,EBX
00608b0e : SHR ECX,0x8
00608b11 : MOV ECX,dword ptr [EDI + ECX*0x4]
00608b14 : MOV EBX,EBP
00608b16 : MOV EBP,dword ptr [ESP + 0x38]
00608b1a : ADD EBX,dword ptr [EBP*0x4 + 0xb9575c]
00608b21 : MOV EDX,EAX
00608b23 : MOV ECX,dword ptr [ECX + EBX*0x4 + 0xc]
00608b27 : SHR EDX,0x2
00608b2a : MOV dword ptr [ESP + 0x20],ECX
00608b2e : MOV ECX,EDX
00608b30 : AND ECX,0xff
00608b36 : MOV EBX,ECX
00608b38 : SHL EBX,0x4
00608b3b : SUB EBX,ECX
00608b3d : AND EAX,0x3
00608b40 : ADD EBX,EAX
00608b42 : SHR EDX,0x8
00608b45 : MOV EDX,dword ptr [EDI + EDX*0x4]
00608b48 : MOV EAX,dword ptr [EDX + EBX*0x4 + 0xc]
00608b4c : MOV EBX,dword ptr [ESI + 0x5c]
00608b4f : LEA EDI,[ESI + 0x5c]
00608b52 : SHR EBX,0x8
00608b55 : MOV dword ptr [ESP + 0x6c],EAX
00608b59 : CMP EBX,dword ptr [EDI + 0x4]
00608b5c : JC 0x00608b66
00608b5e : PUSH EBX
00608b5f : MOV ECX,EDI
00608b61 : CALL 0x00606d10
00608b66 : MOV EAX,dword ptr [EDI]
00608b68 : MOV ECX,dword ptr [EDI + 0xc]
00608b6b : AND EAX,0xff
00608b70 : LEA EDX,[EAX + EAX*0x2]
00608b73 : MOV EAX,dword ptr [ECX + EBX*0x4]
00608b76 : MOV ECX,dword ptr [ESP + 0x6c]
00608b7a : LEA EAX,[EAX + EDX*0x4]
00608b7d : MOV EDX,dword ptr [ESP + 0x34]
00608b81 : MOV dword ptr [EAX],ECX
00608b83 : MOV ECX,dword ptr [ESP + 0x20]
00608b87 : MOV dword ptr [EAX + 0x4],EDX
00608b8a : MOV dword ptr [EAX + 0x8],ECX
00608b8d : INC dword ptr [EDI]
00608b8f : MOV EBX,dword ptr [EDI]
00608b91 : SHR EBX,0x8
00608b94 : CMP EBX,dword ptr [EDI + 0x4]
00608b97 : JC 0x00608ba1
00608b99 : PUSH EBX
00608b9a : MOV ECX,EDI
00608b9c : CALL 0x00606d10
00608ba1 : MOV EAX,dword ptr [EDI]
00608ba3 : MOV EDX,dword ptr [EDI + 0xc]
00608ba6 : MOV ECX,dword ptr [EDX + EBX*0x4]
00608ba9 : MOV EDX,dword ptr [ESP + 0x20]
00608bad : AND EAX,0xff
00608bb2 : LEA EAX,[EAX + EAX*0x2]
00608bb5 : LEA EAX,[ECX + EAX*0x4]
00608bb8 : MOV ECX,dword ptr [ESP + 0x34]
00608bbc : MOV dword ptr [EAX],EDX
00608bbe : MOV EDX,dword ptr [ESP + 0x30]
00608bc2 : MOV dword ptr [EAX + 0x4],ECX
00608bc5 : MOV dword ptr [EAX + 0x8],EDX
00608bc8 : MOV EAX,dword ptr [ESP + 0x58]
00608bcc : INC dword ptr [EDI]
00608bce : OR byte ptr [EAX + EBP*0x1 + 0x34],0x2
00608bd3 : MOV ECX,dword ptr [ESP + 0x18]
00608bd7 : MOV EDI,dword ptr [ESP + 0x2c]
00608bdb : OR byte ptr [EDI + ECX*0x1 + 0x34],0x2
00608be0 : ADD dword ptr [ESP + 0x24],0x4
00608be5 : INC ECX
00608be6 : MOV dword ptr [ESP + 0x18],ECX
00608bea : CMP ECX,0x3
00608bed : JC 0x00608924
00608bf3 : MOV EAX,dword ptr [ESP + 0x14]
00608bf7 : INC EAX
00608bf8 : MOV dword ptr [ESP + 0x14],EAX
00608bfc : CMP EAX,dword ptr [ESI + 0x20]
00608bff : JC 0x00608895
00608c05 : CMP dword ptr [ESP + 0x8c],0x1
00608c0d : JNZ 0x00608d78
00608c13 : MOV EBX,dword ptr [ESI]
00608c15 : CMP EBX,dword ptr [ESI + 0x74]
00608c18 : LEA EDI,[ESI + 0x6c]
00608c1b : JBE 0x00608c4d
00608c1d : MOV EAX,dword ptr [EDI]
00608c1f : PUSH EAX
00608c20 : CALL 0x00515cf0
00608c25 : MOV dword ptr [EDI + 0x8],EBX
00608c28 : TEST EBX,EBX
00608c2a : JZ 0x00608c49
00608c2c : LEA ECX,[ESP + 0x5c]
00608c30 : PUSH ECX
00608c31 : LEA EAX,[EBX*0x4 + 0x0]
00608c38 : PUSH EAX
00608c39 : PUSH EDI
00608c3a : MOV dword ptr [ESP + 0x68],0x2
00608c42 : CALL 0x00515d60
00608c47 : JMP 0x00608c4b
00608c49 : XOR EAX,EAX
00608c4b : MOV dword ptr [EDI],EAX
00608c4d : MOV dword ptr [EDI + 0x4],EBX
00608c50 : XOR EDI,EDI
00608c52 : XOR EDX,EDX
00608c54 : CMP dword ptr [ESI],EDI
00608c56 : JBE 0x00608cb4
00608c58 : JMP 0x00608c60
00608c60 : MOV EAX,dword ptr [ESI + 0x6c]
00608c63 : MOV dword ptr [EAX + EDI*0x4],EDX
00608c66 : MOV EBX,dword ptr [ESI + 0xc]
00608c69 : MOV ECX,EDI
00608c6b : MOV EAX,EDI
00608c6d : AND EAX,0xff
00608c72 : SHR ECX,0x8
00608c75 : MOV ECX,dword ptr [EBX + ECX*0x4]
00608c78 : LEA EAX,[EAX + EAX*0x2]
00608c7b : TEST dword ptr [ECX + EAX*0x4 + 0x8],0x10000000
00608c83 : LEA EAX,[ECX + EAX*0x4]
00608c86 : JZ 0x00608caf
00608c88 : MOV EBP,EDX
00608c8a : MOV ECX,EDX
00608c8c : AND ECX,0xff
00608c92 : SHR EBP,0x8
00608c95 : MOV EBX,dword ptr [EBX + EBP*0x4]
00608c98 : LEA ECX,[ECX + ECX*0x2]
00608c9b : LEA ECX,[EBX + ECX*0x4]
00608c9e : MOV EBX,dword ptr [EAX]
00608ca0 : MOV dword ptr [ECX],EBX
00608ca2 : MOV EBX,dword ptr [EAX + 0x4]
00608ca5 : MOV dword ptr [ECX + 0x4],EBX
00608ca8 : MOV EAX,dword ptr [EAX + 0x8]
00608cab : MOV dword ptr [ECX + 0x8],EAX
00608cae : INC EDX
00608caf : INC EDI
00608cb0 : CMP EDI,dword ptr [ESI]
00608cb2 : JC 0x00608c60
00608cb4 : MOV dword ptr [ESI + 0x78],EDX
00608cb7 : CMP EDX,dword ptr [ESI]
00608cb9 : JNC 0x00608cbd
00608cbb : MOV dword ptr [ESI],EDX
00608cbd : XOR EBP,EBP
00608cbf : CMP dword ptr [ESI + 0x5c],EBP
00608cc2 : JBE 0x00608d78
00608cc8 : MOV ECX,dword ptr [ESI + 0x68]
00608ccb : MOV EDI,EBP
00608ccd : MOV EAX,EBP
00608ccf : AND EAX,0xff
00608cd4 : LEA EBX,[EAX + EAX*0x2]
00608cd7 : SHR EDI,0x8
00608cda : ADD EDI,EDI
00608cdc : ADD EDI,EDI
00608cde : MOV EAX,dword ptr [ECX + EDI*0x1]
00608ce1 : ADD EBX,EBX
00608ce3 : ADD EBX,EBX
00608ce5 : MOV ECX,dword ptr [EAX + EBX*0x1 + 0x4]
00608ce9 : MOV EDX,dword ptr [EAX + EBX*0x1]
00608cec : ADD EAX,EBX
00608cee : MOV EAX,dword ptr [EAX + 0x8]
00608cf1 : MOV dword ptr [ESP + 0x64],ECX
00608cf5 : MOV ECX,dword ptr [ESI + 0x6c]
00608cf8 : MOV EDX,dword ptr [ECX + EDX*0x4]
00608cfb : MOV EAX,dword ptr [ECX + EAX*0x4]
00608cfe : MOV dword ptr [ESP + 0x60],EDX
00608d02 : MOV EDX,dword ptr [ESP + 0x64]
00608d06 : MOV EDX,dword ptr [ECX + EDX*0x4]
00608d09 : PUSH EAX
00608d0a : MOV dword ptr [ESP + 0x6c],EAX
00608d0e : MOV EAX,dword ptr [ESP + 0x64]
00608d12 : PUSH EDX
00608d13 : PUSH EAX
00608d14 : MOV ECX,ESI
00608d16 : MOV dword ptr [ESP + 0x70],EDX
00608d1a : CALL 0x00608020
00608d1f : MOV ECX,dword ptr [ESP + 0x60]
00608d23 : MOV EDX,dword ptr [ESP + 0x68]
00608d27 : PUSH ECX
00608d28 : MOV dword ptr [ESP + 0x7c],EAX
00608d2c : MOV EAX,dword ptr [ESP + 0x68]
00608d30 : PUSH EDX
00608d31 : PUSH EAX
00608d32 : MOV ECX,ESI
00608d34 : CALL 0x00608020
00608d39 : MOV ECX,dword ptr [ESP + 0x64]
00608d3d : MOV EDX,dword ptr [ESP + 0x60]
00608d41 : PUSH ECX
00608d42 : MOV dword ptr [ESP + 0x80],EAX
00608d49 : MOV EAX,dword ptr [ESP + 0x6c]
00608d4d : PUSH EDX
00608d4e : PUSH EAX
00608d4f : MOV ECX,ESI
00608d51 : CALL 0x00608020
00608d56 : MOV ECX,dword ptr [ESI + 0x68]
00608d59 : MOV EDI,dword ptr [ECX + EDI*0x1]
00608d5c : MOV EDX,dword ptr [ESP + 0x78]
00608d60 : MOV ECX,dword ptr [ESP + 0x7c]
00608d64 : ADD EDI,EBX
00608d66 : MOV dword ptr [EDI],EDX
00608d68 : MOV dword ptr [EDI + 0x4],ECX
00608d6b : INC EBP
00608d6c : MOV dword ptr [EDI + 0x8],EAX
00608d6f : CMP EBP,dword ptr [ESI + 0x5c]
00608d72 : JC 0x00608cc8
00608d78 : POP EDI
00608d79 : POP EBP
00608d7a : POP ESI
00608d7b : POP EBX
00608d7c : ADD ESP,0x74
00608d7f : RET 0x8
00608d82 : POP ESI
00608d83 : FSTP ST0
00608d85 : POP EBX
00608d86 : ADD ESP,0x74
00608d89 : RET 0x8
