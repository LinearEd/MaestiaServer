PROGRAM  : Maestia.exe
FUNCTION : FUN_00a50390
ENTRY    : 00a50390
BODY     : [[00a50390, 00a50691]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00a50390(void)

{
  char cVar1;
  uint uVar2;
  undefined4 uVar3;
  int iVar4;
  char *pcVar5;
  uint8_t *packet;
  int in_ECX;
  byte bVar6;
  char *pcVar7;
  uint8_t *puVar8;
  undefined1 local_cc [4];
  undefined2 local_c8;
  undefined4 local_b8;
  uint local_b4;
  char *local_b0;
  undefined1 local_ac [4];
  int local_a8;
  int local_a4;
  uint8_t *local_9c;
  int local_98;
  char local_94 [128];
  uint local_14;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_00b42c87;
  local_10 = ExceptionList;
  uVar2 = DAT_00d66fa0 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_9c = (uint8_t *)(uint)*(ushort *)(in_ECX + 0x15c);
  local_14 = uVar2;
  FUN_00413b60(&local_9c);
  if ((local_98 != *(int *)(in_ECX + 0x128)) &&
     (local_98 = *(int *)(local_98 + 0x10), local_98 != 0)) {
    FUN_00406460(&DAT_00cc6e3c);
    local_8 = 0;
    FUN_0070cd60(local_ac);
    local_8._0_1_ = 2;
    if (7 < local_b4) {
                    /* WARNING: Subroutine does not return */
      FUN_006f04e0();
    }
    local_c8 = 0;
    local_b4 = 7;
    local_b8 = 0;
    if (1 < (uint)((local_a4 - local_a8) / 0x1c)) {
      if (*(undefined4 **)(in_ECX + 0x40) != (undefined4 *)0x0) {
        (**(code **)**(undefined4 **)(in_ECX + 0x40))("CloseCharPassword",uVar2);
      }
      FUN_00a49030();
      *(undefined1 *)(in_ECX + 500) = 0;
      cVar1 = FUN_00404010();
      if (cVar1 == '\0') {
        local_94[0] = '\0';
        _memset(local_94 + 1,0,0x7f);
        if (*(uint *)(local_a8 + 0x34) < 8) {
          local_a8 = local_a8 + 0x20;
        }
        else {
          local_a8 = *(int *)(local_a8 + 0x20);
        }
        pcVar5 = (char *)FUN_0070cf00(local_a8);
        pcVar7 = local_94;
        do {
          cVar1 = *pcVar5;
          *pcVar7 = cVar1;
          pcVar5 = pcVar5 + 1;
          pcVar7 = pcVar7 + 1;
        } while (cVar1 != '\0');
        local_b0 = local_94;
        do {
          cVar1 = *local_b0;
          local_b0 = local_b0 + 1;
        } while (cVar1 != '\0');
        local_b0 = local_b0 + (1 - (int)(local_94 + 1));
        FUN_006f00e0(local_94,&local_b0,0x80);
        iVar4 = *(int *)ThreadLocalStoragePointer;
        bVar6 = (byte)((ulonglong)(*(byte *)(iVar4 + 0x18) + 1) % 3);
        *(byte *)(iVar4 + 0x18) = bVar6;
        local_9c = (uint8_t *)((uint)bVar6 * 0x2000 + 0x122cb8 + iVar4);
        local_8 = CONCAT31(local_8._1_3_,5);
        if (local_9c == (uint8_t *)0x0) {
          packet = (uint8_t *)0x0;
        }
        else {
          *(undefined4 *)(local_9c + 4) = *(undefined4 *)(local_98 + 4);
          local_9c[0] = '\0';
          local_9c[1] = '\0';
          local_9c[2] = '3';
          local_9c[3] = '*';
          pcVar7 = local_94;
          puVar8 = local_9c + 8;
          for (iVar4 = 0x20; packet = local_9c, iVar4 != 0; iVar4 = iVar4 + -1) {
            *(undefined4 *)puVar8 = *(undefined4 *)pcVar7;
            pcVar7 = pcVar7 + 4;
            puVar8 = puVar8 + 4;
          }
        }
        local_8 = CONCAT31(local_8._1_3_,2);
        if ((*(int *)(DAT_017247d4 + 4) != 0) && (*(char *)(DAT_017247d4 + 8) != '\0')) {
          FUN_00a0dd40(*(int *)(DAT_017247d4 + 4),0x88,packet);
        }
      }
      else {
        FUN_00406460(L"IDS_LOBBY_CHAR_PASSWORD_DIFFERENT");
        local_8._0_1_ = 3;
        uVar3 = FUN_0081d120(local_cc);
        local_8._0_1_ = 4;
        iVar4 = FUN_008ede80(uVar3,0);
        local_8._0_1_ = 3;
        FUN_00406560();
        local_8 = CONCAT31(local_8._1_3_,2);
        FUN_00406560();
        if (iVar4 != 0) {
          if (*(code **)(iVar4 + 0x60) != (code *)0x0) {
            (**(code **)(iVar4 + 0x60))(1,iVar4);
          }
          *(undefined1 **)(iVar4 + 0x60) = &LAB_00a49980;
          FUN_00a49030();
        }
      }
    }
    local_8 = 0xffffffff;
    FUN_004042c0();
  }
  ExceptionList = local_10;
  __security_check_cookie(local_14 ^ (uint)&stack0xfffffffc);
  return;
}



============================================================
DISASSEMBLY
============================================================
00a50390 : PUSH EBP
00a50391 : MOV EBP,ESP
00a50393 : PUSH -0x1
00a50395 : PUSH 0xb42c87
00a5039a : MOV EAX,FS:[0x0]
00a503a0 : PUSH EAX
00a503a1 : SUB ESP,0xd8
00a503a7 : MOV EAX,[0x00d66fa0]
00a503ac : XOR EAX,EBP
00a503ae : MOV dword ptr [EBP + -0x10],EAX
00a503b1 : PUSH ESI
00a503b2 : PUSH EDI
00a503b3 : PUSH EAX
00a503b4 : LEA EAX,[EBP + -0xc]
00a503b7 : MOV FS:[0x0],EAX
00a503bd : MOV ESI,ECX
00a503bf : MOVZX EAX,word ptr [ESI + 0x15c]
00a503c6 : LEA ECX,[EBP + 0xffffff68]
00a503cc : MOV dword ptr [EBP + 0xffffff68],EAX
00a503d2 : PUSH ECX
00a503d3 : LEA ECX,[ESI + 0x124]
00a503d9 : LEA EAX,[EBP + 0xffffff6c]
00a503df : MOV EDI,EDX
00a503e1 : CALL 0x00413b60
00a503e6 : MOV EAX,dword ptr [ESI + 0x128]
00a503ec : MOV ECX,dword ptr [EBP + 0xffffff6c]
00a503f2 : CMP ECX,EAX
00a503f4 : JZ 0x00a50677
00a503fa : MOV ECX,dword ptr [ECX + 0x10]
00a503fd : MOV dword ptr [EBP + 0xffffff6c],ECX
00a50403 : TEST ECX,ECX
00a50405 : JZ 0x00a50677
00a5040b : PUSH 0xcc6e3c
00a50410 : LEA ECX,[EBP + 0xffffff38]
00a50416 : CALL 0x00406460
00a5041b : MOV dword ptr [EBP + -0x4],0x0
00a50422 : PUSH 0x0
00a50424 : LEA EDX,[EBP + 0xffffff38]
00a5042a : PUSH EDX
00a5042b : LEA EAX,[EBP + 0xffffff58]
00a50431 : PUSH EDI
00a50432 : PUSH EAX
00a50433 : CALL 0x0070cd60
00a50438 : ADD ESP,0x10
00a5043b : MOV byte ptr [EBP + -0x4],0x2
00a5043f : MOV EDI,0x8
00a50444 : CMP dword ptr [EBP + 0xffffff50],EDI
00a5044a : JC 0x00a50457
00a5044c : MOV ECX,dword ptr [EBP + 0xffffff3c]
00a50452 : CALL 0x006f04e0
00a50457 : XOR ECX,ECX
00a50459 : MOV word ptr [EBP + 0xffffff3c],CX
00a50460 : MOV ECX,dword ptr [EBP + 0xffffff60]
00a50466 : SUB ECX,dword ptr [EBP + 0xffffff5c]
00a5046c : MOV EAX,0x92492493
00a50471 : IMUL ECX
00a50473 : ADD EDX,ECX
00a50475 : SAR EDX,0x4
00a50478 : MOV EAX,EDX
00a5047a : SHR EAX,0x1f
00a5047d : ADD EAX,EDX
00a5047f : MOV dword ptr [EBP + 0xffffff50],0x7
00a50489 : MOV dword ptr [EBP + 0xffffff4c],0x0
00a50493 : CMP EAX,0x2
00a50496 : JC 0x00a50665
00a5049c : MOV ECX,dword ptr [ESI + 0x40]
00a5049f : TEST ECX,ECX
00a504a1 : JZ 0x00a504ae
00a504a3 : MOV EDX,dword ptr [ECX]
00a504a5 : MOV EAX,dword ptr [EDX]
00a504a7 : PUSH 0xcc6da0
00a504ac : CALL EAX
00a504ae : MOV DL,0x1
00a504b0 : MOV EAX,ESI
00a504b2 : CALL 0x00a49030
00a504b7 : MOV ECX,dword ptr [EBP + 0xffffff5c]
00a504bd : LEA EAX,[ECX + 0x1c]
00a504c0 : MOV byte ptr [ESI + 0x1f4],0x0
00a504c7 : CALL 0x00404010
00a504cc : TEST AL,AL
00a504ce : JZ 0x00a5055d
00a504d4 : PUSH 0xcc6e88
00a504d9 : LEA ECX,[EBP + 0xffffff38]
00a504df : CALL 0x00406460
00a504e4 : MOV byte ptr [EBP + -0x4],0x3
00a504e8 : LEA ECX,[EBP + 0xffffff38]
00a504ee : PUSH ECX
00a504ef : MOV ECX,dword ptr [0x0172491c]
00a504f5 : LEA EDI,[EBP + 0xffffff1c]
00a504fb : CALL 0x0081d120
00a50500 : MOV byte ptr [EBP + -0x4],0x4
00a50504 : MOV EDX,dword ptr [0x00da9894]
00a5050a : MOV ECX,dword ptr [EDX]
00a5050c : PUSH 0x0
00a5050e : PUSH EAX
00a5050f : CALL 0x008ede80
00a50514 : MOV EDI,EAX
00a50516 : MOV byte ptr [EBP + -0x4],0x3
00a5051a : LEA ECX,[EBP + 0xffffff1c]
00a50520 : CALL 0x00406560
00a50525 : MOV byte ptr [EBP + -0x4],0x2
00a50529 : LEA ECX,[EBP + 0xffffff38]
00a5052f : CALL 0x00406560
00a50534 : TEST EDI,EDI
00a50536 : JZ 0x00a50665
00a5053c : MOV EAX,dword ptr [EDI + 0x60]
00a5053f : TEST EAX,EAX
00a50541 : JZ 0x00a50548
00a50543 : PUSH EDI
00a50544 : PUSH 0x1
00a50546 : CALL EAX
00a50548 : XOR DL,DL
00a5054a : MOV EAX,ESI
00a5054c : MOV dword ptr [EDI + 0x60],0xa49980
00a50553 : CALL 0x00a49030
00a50558 : JMP 0x00a50665
00a5055d : PUSH 0x7f
00a5055f : LEA EAX,[EBP + 0xffffff71]
00a50565 : PUSH 0x0
00a50567 : PUSH EAX
00a50568 : MOV byte ptr [EBP + 0xffffff70],0x0
00a5056f : CALL 0x0063b700
00a50574 : MOV EAX,dword ptr [EBP + 0xffffff5c]
00a5057a : ADD ESP,0xc
00a5057d : CMP dword ptr [EAX + 0x34],EDI
00a50580 : JC 0x00a50587
00a50582 : MOV EAX,dword ptr [EAX + 0x20]
00a50585 : JMP 0x00a5058a
00a50587 : ADD EAX,0x20
00a5058a : PUSH EAX
00a5058b : CALL 0x0070cf00
00a50590 : ADD ESP,0x4
00a50593 : LEA EDX,[EBP + 0xffffff70]
00a50599 : LEA ESP,[ESP]
00a505a0 : MOV CL,byte ptr [EAX]
00a505a2 : MOV byte ptr [EDX],CL
00a505a4 : INC EAX
00a505a5 : INC EDX
00a505a6 : TEST CL,CL
00a505a8 : JNZ 0x00a505a0
00a505aa : LEA EAX,[EBP + 0xffffff70]
00a505b0 : LEA EDX,[EAX + 0x1]
00a505b3 : MOV CL,byte ptr [EAX]
00a505b5 : INC EAX
00a505b6 : TEST CL,CL
00a505b8 : JNZ 0x00a505b3
00a505ba : PUSH 0x80
00a505bf : SUB EAX,EDX
00a505c1 : LEA ECX,[EBP + 0xffffff54]
00a505c7 : PUSH ECX
00a505c8 : LEA EDX,[EBP + 0xffffff70]
00a505ce : INC EAX
00a505cf : PUSH EDX
00a505d0 : LEA ECX,[ESI + 0x2dc]
00a505d6 : MOV dword ptr [EBP + 0xffffff54],EAX
00a505dc : CALL 0x006f00e0
00a505e1 : MOV EAX,FS:[0x2c]
00a505e7 : MOV ECX,dword ptr [EAX]
00a505e9 : MOVZX EAX,byte ptr [ECX + 0x18]
00a505ed : INC EAX
00a505ee : CDQ
00a505ef : MOV ESI,0x3
00a505f4 : IDIV ESI
00a505f6 : MOV byte ptr [ECX + 0x18],DL
00a505f9 : MOVZX EDX,DL
00a505fc : SHL EDX,0xd
00a505ff : LEA EAX,[EDX + ECX*0x1 + 0x122cb8]
00a50606 : MOV dword ptr [EBP + 0xffffff68],EAX
00a5060c : MOV byte ptr [EBP + -0x4],0x5
00a50610 : TEST EAX,EAX
00a50612 : JZ 0x00a5063f
00a50614 : MOV ECX,dword ptr [EBP + 0xffffff6c]
00a5061a : MOV ECX,dword ptr [ECX + 0x4]
00a5061d : MOV dword ptr [EAX + 0x4],ECX
00a50620 : XOR EDX,EDX
00a50622 : LEA EDI,[EAX + 0x8]
00a50625 : MOV ECX,0x20
00a5062a : LEA ESI,[EBP + 0xffffff70]
00a50630 : MOV word ptr [EAX],DX
00a50633 : MOV byte ptr [EAX + 0x2],0x33
00a50637 : MOV byte ptr [EAX + 0x3],0x2a
00a5063b : MOVSD.REP ES:EDI,ESI
00a5063d : JMP 0x00a50641
00a5063f : XOR EAX,EAX
00a50641 : MOV byte ptr [EBP + -0x4],0x2
00a50645 : MOV EDX,dword ptr [0x017247d4]
00a5064b : MOV ECX,dword ptr [EDX + 0x4]
00a5064e : TEST ECX,ECX
00a50650 : JZ 0x00a50665
00a50652 : CMP byte ptr [EDX + 0x8],0x0
00a50656 : JZ 0x00a50665
00a50658 : PUSH 0x88
00a5065d : PUSH ECX
00a5065e : MOV EDI,EAX
00a50660 : CALL 0x00a0dd40
00a50665 : MOV dword ptr [EBP + -0x4],0xffffffff
00a5066c : LEA ESI,[EBP + 0xffffff58]
00a50672 : CALL 0x004042c0
00a50677 : MOV ECX,dword ptr [EBP + -0xc]
00a5067a : MOV dword ptr FS:[0x0],ECX
00a50681 : POP ECX
00a50682 : POP EDI
00a50683 : POP ESI
00a50684 : MOV ECX,dword ptr [EBP + -0x10]
00a50687 : XOR ECX,EBP
00a50689 : CALL 0x00633e6b
00a5068e : MOV ESP,EBP
00a50690 : POP EBP
00a50691 : RET
