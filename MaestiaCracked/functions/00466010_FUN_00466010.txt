PROGRAM  : Maestia.exe
FUNCTION : FUN_00466010
ENTRY    : 00466010
BODY     : [[00466010, 0046642d]]

============================================================
DECOMPILED C CODE
============================================================

byte FUN_00466010(int param_1,short param_2)

{
  int iVar1;
  int *piVar2;
  bool bVar3;
  char cVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  int in_EAX;
  int iVar8;
  int iVar9;
  int iVar10;
  int *piVar11;
  int iVar12;
  int iVar13;
  int *piVar14;
  int iVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  int local_28;
  int local_24;
  int local_c;
  bool local_6;
  byte local_5;
  
  local_5 = 0;
  if ((*(int *)(param_1 + 4) == 0) || (*(int *)(param_1 + 0x10) == 0)) {
    return 1;
  }
  cVar4 = FUN_0046c730();
  if (cVar4 != '\0') {
    iVar13 = *(int *)(param_1 + 4);
    local_5 = 1;
    bVar3 = false;
    local_28 = 0;
    if (0 < *(int *)(iVar13 + 8)) {
      do {
        iVar13 = *(int *)(*(int *)(iVar13 + 4) + local_28 * 4);
        if (((*(char *)(iVar13 + 500) != '\0') && (iVar8 = FUN_0046c9c0(local_28), iVar8 != 0)) &&
           (iVar1 = *(int *)(iVar8 + 8), iVar1 != 0)) {
          if (!bVar3) {
            bVar5 = FUN_0046ab70();
            local_5 = local_5 & bVar5;
            bVar3 = true;
          }
          bVar5 = FUN_0046ab90();
          iVar9 = (**(code **)(*DAT_01720efc + 0x1a0))(DAT_01720efc,*(undefined4 *)(iVar13 + 0xee8))
          ;
          local_5 = local_5 & bVar5 & iVar9 == 0;
          *(int *)(in_EAX + 0x7440) = *(int *)(in_EAX + 0x7440) + 1;
          FUN_0046a440();
          if (0 < iVar1) {
            iVar10 = 0;
            iVar9 = iVar1;
            do {
              if (*(char *)(*(char *)(iVar10 + 0x1c + *(int *)(iVar8 + 4)) + 1 +
                           *(int *)(iVar13 + 0xdd8)) != '\0') {
                *(int *)(in_EAX + 0x7434) = *(int *)(in_EAX + 0x7434) + 1;
              }
              iVar10 = iVar10 + 0x20;
              iVar9 = iVar9 + -1;
            } while (iVar9 != 0);
          }
          piVar11 = *(int **)(iVar13 + 0xdec);
          if (piVar11 != piVar11 + *(int *)(iVar13 + 0xdf0)) {
            do {
              iVar9 = *piVar11;
              iVar15 = iVar9 * 0x1128 + *(int *)(iVar13 + 0xda8);
              iVar10 = FUN_0046a050(in_EAX,iVar15,0);
              if (0 < iVar10) {
                *(int *)(in_EAX + 0x7438) = *(int *)(in_EAX + 0x7438) + iVar10;
              }
              iVar10 = *(int *)(iVar15 + 0x58);
              cVar4 = (**(code **)(*(int *)PTR_DAT_00d6df20 + 4))();
              if (cVar4 != '\0') {
                iVar10 = *(int *)(&DAT_00d72c28 + iVar10 * 4);
              }
              if (iVar10 == 2) {
                uVar16 = 2;
              }
              else if (iVar10 == 1) {
                uVar16 = 3;
              }
              else {
                uVar16 = 1;
              }
              (**(code **)(*DAT_01720efc + 0xe4))(DAT_01720efc,0x16,uVar16);
              if (0 < iVar1) {
                local_c = 0;
                local_24 = iVar1;
                do {
                  piVar14 = (int *)(*(int *)(iVar8 + 4) + local_c);
                  if (-1 < (char)piVar14[7]) {
                    iVar10 = *piVar14;
                    if (param_2 == 1) {
                      if (*(char *)(iVar10 + 0x12d) == '\0') {
LAB_004661f8:
                        iVar12 = *(int *)(iVar13 + 0xdb8) * iVar9 + (int)(char)piVar14[7];
                        iVar15 = *(int *)(iVar13 + 0xdc4) + iVar12 * 0x14;
                        if (*(int *)(*(int *)(iVar13 + 0xdc4) + iVar12 * 0x14) != -1) {
                          local_6 = false;
                          if (*(int *)(in_EAX + 0x32b8) != 0) {
                            piVar2 = *(int **)(*(int *)(in_EAX + 0x32c0) + 0xc);
                            iVar12 = (**(code **)(*piVar2 + 0x4c))
                                               (piVar2,DAT_01720efc,*(int *)(in_EAX + 0x32b8),iVar10
                                               );
                            local_6 = -1 < iVar12;
                          }
                          if (*(int *)(in_EAX + 0x32bc) != 0) {
                            piVar2 = *(int **)(*(int *)(in_EAX + 0x32c0) + 0x10);
                            iVar12 = (**(code **)(*piVar2 + 0x4c))
                                               (piVar2,DAT_01720efc,*(int *)(in_EAX + 0x32bc),iVar10
                                               );
                            local_6 = -1 < iVar12;
                          }
                          bVar5 = FUN_0046c3b0((float)(int)*(char *)(iVar10 + 0x21) * 0.007874016,
                                               piVar14[3],piVar14[2]);
                          if (*(char *)(iVar10 + 300) == '\0') {
                            uVar16 = 0;
                            uVar17 = 0;
                          }
                          else {
                            uVar16 = *(undefined4 *)(iVar10 + 0x134);
                            uVar17 = *(undefined4 *)(iVar10 + 0x138);
                          }
                          bVar6 = FUN_0046c4d0(uVar16,uVar17);
                          if (*(char *)(iVar10 + 0x12d) == '\0') {
                            uVar16 = 0x3f800000;
                          }
                          else {
                            uVar16 = 0x3e99999a;
                          }
                          FUN_0046c5e0(uVar16);
                          if (*(int *)(iVar15 + 8) == 0) {
                            bVar7 = 0;
                          }
                          else {
                            bVar7 = FUN_0046c640(*(undefined4 *)(iVar15 + 4),
                                                 *(undefined4 *)(iVar15 + 0xc),
                                                 *(undefined4 *)(iVar15 + 0x10));
                          }
                          local_5 = local_5 & bVar5 & local_6 & bVar6 & bVar7;
                          *(int *)(in_EAX + 0x743c) = *(int *)(in_EAX + 0x743c) + 1;
                          *(int *)(in_EAX + 0x7444) =
                               *(int *)(in_EAX + 0x7444) + *(uint *)(iVar15 + 8) / 3;
                        }
                      }
                    }
                    else if ((param_2 != 2) || (*(char *)(iVar10 + 0x12d) != '\0'))
                    goto LAB_004661f8;
                  }
                  local_c = local_c + 0x20;
                  local_24 = local_24 + -1;
                } while (local_24 != 0);
              }
              piVar11 = piVar11 + 1;
            } while (piVar11 != (int *)(*(int *)(iVar13 + 0xdec) + *(int *)(iVar13 + 0xdf0) * 4));
          }
          iVar13 = (**(code **)(*DAT_01720efc + 400))(DAT_01720efc,0,0,0,0);
          iVar8 = (**(code **)(*DAT_01720efc + 0x1a0))(DAT_01720efc,0);
          local_5 = local_5 & iVar13 == 0 & iVar8 == 0;
        }
        iVar13 = *(int *)(param_1 + 4);
        local_28 = local_28 + 1;
      } while (local_28 < *(int *)(iVar13 + 8));
    }
    (**(code **)(*DAT_01720efc + 0x170))(DAT_01720efc,0);
    (**(code **)(*DAT_01720efc + 0x1ac))(DAT_01720efc,0);
  }
  return local_5;
}



============================================================
DISASSEMBLY
============================================================
00466010 : PUSH EBP
00466011 : MOV EBP,ESP
00466013 : SUB ESP,0x2c
00466016 : PUSH EBX
00466017 : MOV EBX,dword ptr [EBP + 0x8]
0046601a : CMP dword ptr [EBX + 0x4],0x0
0046601e : PUSH ESI
0046601f : PUSH EDI
00466020 : MOV EDI,EAX
00466022 : MOV byte ptr [EBP + -0x1],0x0
00466026 : JZ 0x00466423
0046602c : CMP dword ptr [EBX + 0x10],0x0
00466030 : JZ 0x00466423
00466036 : LEA EAX,[EDI + 0x1538]
0046603c : CALL 0x0046c730
00466041 : TEST AL,AL
00466043 : JZ 0x00466417
00466049 : MOV EAX,dword ptr [EBX + 0x4]
0046604c : XOR ESI,ESI
0046604e : CMP dword ptr [EAX + 0x8],ESI
00466051 : MOV byte ptr [EBP + -0x1],0x1
00466055 : MOV byte ptr [EBP + -0x3],0x0
00466059 : MOV dword ptr [EBP + -0x24],ESI
0046605c : JLE 0x004663ef
00466062 : MOV EAX,dword ptr [EAX + 0x4]
00466065 : MOV EBX,dword ptr [EAX + ESI*0x4]
00466068 : CMP byte ptr [EBX + 0x1f4],0x0
0046606f : MOV dword ptr [EBP + -0x1c],EBX
00466072 : JZ 0x004663d2
00466078 : MOV EAX,dword ptr [EBP + 0x8]
0046607b : PUSH ESI
0046607c : CALL 0x0046c9c0
00466081 : MOV dword ptr [EBP + -0x14],EAX
00466084 : TEST EAX,EAX
00466086 : JZ 0x004663d2
0046608c : MOV EAX,dword ptr [EAX + 0x8]
0046608f : MOV dword ptr [EBP + -0x10],EAX
00466092 : TEST EAX,EAX
00466094 : JZ 0x004663d2
0046609a : CMP byte ptr [EBP + -0x3],0x0
0046609e : LEA ESI,[EBX + 0xed8]
004660a4 : JNZ 0x004660b4
004660a6 : MOV EDX,ESI
004660a8 : CALL 0x0046ab70
004660ad : AND byte ptr [EBP + -0x1],AL
004660b0 : MOV byte ptr [EBP + -0x3],0x1
004660b4 : MOV ECX,ESI
004660b6 : CALL 0x0046ab90
004660bb : AND byte ptr [EBP + -0x1],AL
004660be : MOV EAX,[0x01720efc]
004660c3 : MOV EDX,dword ptr [ESI + 0x10]
004660c6 : MOV ECX,dword ptr [EAX]
004660c8 : PUSH EDX
004660c9 : PUSH EAX
004660ca : MOV EAX,dword ptr [ECX + 0x1a0]
004660d0 : CALL EAX
004660d2 : TEST EAX,EAX
004660d4 : SETZ CL
004660d7 : AND byte ptr [EBP + -0x1],CL
004660da : INC dword ptr [EDI + 0x7440]
004660e0 : MOV ESI,EBX
004660e2 : CALL 0x0046a440
004660e7 : MOV ECX,dword ptr [EBP + -0x10]
004660ea : TEST ECX,ECX
004660ec : JLE 0x00466116
004660ee : XOR EAX,EAX
004660f0 : MOV EDX,dword ptr [EBP + -0x14]
004660f3 : MOV EDX,dword ptr [EDX + 0x4]
004660f6 : MOVSX EDX,byte ptr [EAX + EDX*0x1 + 0x1c]
004660fb : MOV ESI,dword ptr [EBX + 0xdd8]
00466101 : CMP byte ptr [EDX + ESI*0x1 + 0x1],0x0
00466106 : JZ 0x0046610e
00466108 : INC dword ptr [EDI + 0x7434]
0046610e : ADD EAX,0x20
00466111 : SUB ECX,0x1
00466114 : JNZ 0x004660f0
00466116 : MOV EAX,dword ptr [EBX + 0xdec]
0046611c : MOV ECX,dword ptr [EBX + 0xdf0]
00466122 : LEA EDX,[EAX + ECX*0x4]
00466125 : MOV dword ptr [EBP + -0xc],EAX
00466128 : CMP EAX,EDX
0046612a : JZ 0x00466391
00466130 : JMP 0x00466135
00466132 : MOV EAX,dword ptr [EBP + -0xc]
00466135 : MOV ESI,dword ptr [EAX]
00466137 : MOV dword ptr [EBP + -0x28],ESI
0046613a : IMUL ESI,ESI,0x1128
00466140 : ADD ESI,dword ptr [EBX + 0xda8]
00466146 : PUSH 0x0
00466148 : PUSH ESI
00466149 : PUSH EDI
0046614a : CALL 0x0046a050
0046614f : TEST EAX,EAX
00466151 : JLE 0x0046615d
00466153 : AND byte ptr [EBP + -0x1],0x1
00466157 : ADD dword ptr [EDI + 0x7438],EAX
0046615d : MOV ECX,dword ptr [0x00d6df20]
00466163 : MOV EAX,dword ptr [ECX]
00466165 : MOV EDX,dword ptr [EAX + 0x4]
00466168 : MOV ESI,dword ptr [ESI + 0x58]
0046616b : CALL EDX
0046616d : TEST AL,AL
0046616f : JZ 0x00466178
00466171 : MOV ESI,dword ptr [ESI*0x4 + 0xd72c28]
00466178 : CMP ESI,0x2
0046617b : JNZ 0x00466180
0046617d : PUSH ESI
0046617e : JMP 0x0046618b
00466180 : CMP ESI,0x1
00466183 : JNZ 0x00466189
00466185 : PUSH 0x3
00466187 : JMP 0x0046618b
00466189 : PUSH 0x1
0046618b : MOV EAX,[0x01720efc]
00466190 : MOV ECX,dword ptr [EAX]
00466192 : MOV EDX,dword ptr [ECX + 0xe4]
00466198 : PUSH 0x16
0046619a : PUSH EAX
0046619b : CALL EDX
0046619d : MOV EAX,dword ptr [EBP + -0x10]
004661a0 : TEST EAX,EAX
004661a2 : JLE 0x00466371
004661a8 : MOV dword ptr [EBP + -0x8],0x0
004661af : MOV dword ptr [EBP + -0x20],EAX
004661b2 : MOV EAX,dword ptr [EBP + -0x14]
004661b5 : MOV ECX,dword ptr [EAX + 0x4]
004661b8 : ADD ECX,dword ptr [EBP + -0x8]
004661bb : MOV DL,byte ptr [ECX + 0x1c]
004661be : CMP DL,0xff
004661c1 : MOV dword ptr [EBP + -0x18],ECX
004661c4 : JLE 0x00466363
004661ca : MOV AX,word ptr [EBP + 0xc]
004661ce : MOV ESI,dword ptr [ECX]
004661d0 : CMP AX,0x1
004661d4 : JNZ 0x004661e5
004661d6 : CMP byte ptr [ESI + 0x12d],0x0
004661dd : JNZ 0x00466363
004661e3 : JMP 0x004661f8
004661e5 : CMP AX,0x2
004661e9 : JNZ 0x004661f8
004661eb : CMP byte ptr [ESI + 0x12d],0x0
004661f2 : JZ 0x00466363
004661f8 : MOV EAX,dword ptr [EBX + 0xdb8]
004661fe : IMUL EAX,dword ptr [EBP + -0x28]
00466202 : MOVSX EDX,DL
00466205 : ADD EAX,EDX
00466207 : MOV EDX,dword ptr [EBX + 0xdc4]
0046620d : LEA EAX,[EAX + EAX*0x4]
00466210 : CMP dword ptr [EDX + EAX*0x4],-0x1
00466214 : LEA EBX,[EDX + EAX*0x4]
00466217 : JZ 0x00466360
0046621d : MOV EDX,dword ptr [EDI + 0x32b8]
00466223 : MOV byte ptr [EBP + -0x2],0x0
00466227 : TEST EDX,EDX
00466229 : JZ 0x0046624e
0046622b : MOV EAX,dword ptr [EDI + 0x32c0]
00466231 : MOV EAX,dword ptr [EAX + 0xc]
00466234 : MOV ECX,dword ptr [EAX]
00466236 : PUSH ESI
00466237 : PUSH EDX
00466238 : MOV EDX,dword ptr [0x01720efc]
0046623e : PUSH EDX
0046623f : PUSH EAX
00466240 : MOV EAX,dword ptr [ECX + 0x4c]
00466243 : CALL EAX
00466245 : MOV ECX,dword ptr [EBP + -0x18]
00466248 : TEST EAX,EAX
0046624a : SETGE byte ptr [EBP + -0x2]
0046624e : MOV EDX,dword ptr [EDI + 0x32bc]
00466254 : TEST EDX,EDX
00466256 : JZ 0x0046627b
00466258 : MOV ECX,dword ptr [EDI + 0x32c0]
0046625e : MOV EAX,dword ptr [ECX + 0x10]
00466261 : MOV ECX,dword ptr [EAX]
00466263 : PUSH ESI
00466264 : PUSH EDX
00466265 : MOV EDX,dword ptr [0x01720efc]
0046626b : PUSH EDX
0046626c : PUSH EAX
0046626d : MOV EAX,dword ptr [ECX + 0x4c]
00466270 : CALL EAX
00466272 : MOV ECX,dword ptr [EBP + -0x18]
00466275 : TEST EAX,EAX
00466277 : SETGE byte ptr [EBP + -0x2]
0046627b : MOVSX EAX,byte ptr [ESI + 0x21]
0046627f : MOVSX EDX,byte ptr [ESI + 0x20]
00466283 : MOV dword ptr [EBP + -0x18],EAX
00466286 : SUB ESP,0xc
00466289 : CVTSI2SS XMM0,EDX
0046628d : FILD dword ptr [EBP + -0x18]
00466290 : MULSS XMM0,dword ptr [0x00cdf310]
00466298 : LEA EAX,[EDI + 0x33cc]
0046629e : FMUL float ptr [0x00cdf310]
004662a4 : FLD float ptr [ECX + 0xc]
004662a7 : FLD float ptr [ECX + 0x8]
004662aa : FSTP float ptr [ESP + 0x8]
004662ae : FSTP float ptr [ESP + 0x4]
004662b2 : FSTP float ptr [ESP]
004662b5 : CALL 0x0046c3b0
004662ba : AND AL,byte ptr [EBP + -0x2]
004662bd : SUB ESP,0x8
004662c0 : AND byte ptr [EBP + -0x1],AL
004662c3 : CMP byte ptr [ESI + 0x12c],0x0
004662ca : LEA EAX,[EDI + 0x6778]
004662d0 : JZ 0x004662ec
004662d2 : FLD float ptr [ESI + 0x134]
004662d8 : MOVSS XMM0,dword ptr [ESI + 0x130]
004662e0 : FLD float ptr [ESI + 0x138]
004662e6 : FSTP float ptr [ESP + 0x4]
004662ea : JMP 0x004662f5
004662ec : FLDZ
004662ee : XORPS XMM0,XMM0
004662f1 : FST float ptr [ESP + 0x4]
004662f5 : FSTP float ptr [ESP]
004662f8 : CALL 0x0046c4d0
004662fd : AND byte ptr [EBP + -0x1],AL
00466300 : CMP byte ptr [ESI + 0x12d],0x0
00466307 : PUSH ECX
00466308 : LEA ESI,[EDI + 0x6890]
0046630e : JZ 0x00466318
00466310 : FLD float ptr [0x00cdf0e8]
00466316 : JMP 0x0046631a
00466318 : FLD1
0046631a : FSTP float ptr [ESP]
0046631d : CALL 0x0046c5e0
00466322 : MOV ECX,dword ptr [EBX + 0x8]
00466325 : AND byte ptr [EBP + -0x1],0x1
00466329 : MOV EAX,dword ptr [EBX + 0x10]
0046632c : MOV EDX,dword ptr [EBX + 0xc]
0046632f : MOV ESI,dword ptr [EBX + 0x4]
00466332 : TEST ECX,ECX
00466334 : JBE 0x00466345
00466336 : PUSH EAX
00466337 : PUSH EDX
00466338 : PUSH ESI
00466339 : MOV EAX,0x6
0046633e : CALL 0x0046c640
00466343 : JMP 0x00466347
00466345 : XOR AL,AL
00466347 : AND byte ptr [EBP + -0x1],AL
0046634a : INC dword ptr [EDI + 0x743c]
00466350 : MOV EAX,0xaaaaaaab
00466355 : MUL dword ptr [EBX + 0x8]
00466358 : SHR EDX,0x1
0046635a : ADD dword ptr [EDI + 0x7444],EDX
00466360 : MOV EBX,dword ptr [EBP + -0x1c]
00466363 : ADD dword ptr [EBP + -0x8],0x20
00466367 : SUB dword ptr [EBP + -0x20],0x1
0046636b : JNZ 0x004661b2
00466371 : MOV EAX,dword ptr [EBP + -0xc]
00466374 : MOV ECX,dword ptr [EBX + 0xdf0]
0046637a : MOV EDX,dword ptr [EBX + 0xdec]
00466380 : ADD EAX,0x4
00466383 : LEA ECX,[EDX + ECX*0x4]
00466386 : MOV dword ptr [EBP + -0xc],EAX
00466389 : CMP EAX,ECX
0046638b : JNZ 0x00466132
00466391 : MOV EAX,[0x01720efc]
00466396 : MOV EDX,dword ptr [EAX]
00466398 : PUSH 0x0
0046639a : PUSH 0x0
0046639c : PUSH 0x0
0046639e : PUSH 0x0
004663a0 : PUSH EAX
004663a1 : MOV EAX,dword ptr [EDX + 0x190]
004663a7 : CALL EAX
004663a9 : MOV BL,byte ptr [EBP + -0x1]
004663ac : TEST EAX,EAX
004663ae : MOV EAX,[0x01720efc]
004663b3 : MOV EDX,dword ptr [EAX]
004663b5 : PUSH 0x0
004663b7 : SETZ CL
004663ba : PUSH EAX
004663bb : MOV EAX,dword ptr [EDX + 0x1a0]
004663c1 : AND BL,CL
004663c3 : CALL EAX
004663c5 : MOV ESI,dword ptr [EBP + -0x24]
004663c8 : TEST EAX,EAX
004663ca : SETZ CL
004663cd : AND BL,CL
004663cf : MOV byte ptr [EBP + -0x1],BL
004663d2 : MOV EDX,dword ptr [EBP + 0x8]
004663d5 : MOV EAX,dword ptr [EDX + 0x4]
004663d8 : INC ESI
004663d9 : CMP ESI,dword ptr [EAX + 0x8]
004663dc : MOV dword ptr [EBP + -0x24],ESI
004663df : JL 0x00466062
004663e5 : CMP byte ptr [EBP + -0x3],0x0
004663e9 : JZ 0x004663ef
004663eb : AND byte ptr [EBP + -0x1],0x1
004663ef : MOV EAX,[0x01720efc]
004663f4 : MOV ECX,dword ptr [EAX]
004663f6 : MOV EDX,dword ptr [ECX + 0x170]
004663fc : PUSH 0x0
004663fe : PUSH EAX
004663ff : CALL EDX
00466401 : MOV EAX,[0x01720efc]
00466406 : MOV ECX,dword ptr [EAX]
00466408 : MOV EDX,dword ptr [ECX + 0x1ac]
0046640e : PUSH 0x0
00466410 : PUSH EAX
00466411 : CALL EDX
00466413 : AND byte ptr [EBP + -0x1],0x1
00466417 : MOV AL,byte ptr [EBP + -0x1]
0046641a : POP EDI
0046641b : POP ESI
0046641c : POP EBX
0046641d : MOV ESP,EBP
0046641f : POP EBP
00466420 : RET 0x8
00466423 : POP EDI
00466424 : POP ESI
00466425 : MOV AL,0x1
00466427 : POP EBX
00466428 : MOV ESP,EBP
0046642a : POP EBP
0046642b : RET 0x8
