PROGRAM  : Maestia.exe
FUNCTION : Init
ENTRY    : 0062607a
BODY     : [[0062607a, 006261cd]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3 */
/* WARNING: Function: __EH_epilog3 replaced with injection: EH_epilog3 */
/* Library Function - Multiple Matches With Same Base Name
    protected: void __thiscall std::_Mpunct<unsigned short>::_Init(class std::_Locinfo const &,bool)
    protected: void __thiscall std::_Mpunct<wchar_t>::_Init(class std::_Locinfo const &,bool)
   
   Library: Visual Studio 2008 Release */

void Init(_Locinfo *param_1,char param_2)

{
  uint *puVar1;
  char cVar2;
  undefined2 uVar3;
  _Cvtvec *p_Var4;
  lconv *plVar5;
  undefined4 uVar6;
  char *pcVar7;
  int in_ECX;
  uchar local_8 [8];
  int iVar8;
  
  local_8[4] = '\x10';
  local_8[5] = '\0';
  local_8[6] = '\0';
  local_8[7] = '\0';
  local_8[0] = 0x86;
  local_8[1] = '`';
  local_8[2] = 'b';
  local_8[3] = '\0';
  p_Var4 = std::_Locinfo::_Getcvt(param_1,(_Cvtvec *)&stack0xffffffe0);
  puVar1 = (uint *)(in_ECX + 0x2c);
  *puVar1 = p_Var4->_Page;
  *(uint *)(in_ECX + 0x30) = p_Var4->_Mbcurmax;
  plVar5 = _localeconv();
  *(undefined4 *)(in_ECX + 8) = 0;
  *(undefined4 *)(in_ECX + 0x10) = 0;
  *(undefined4 *)(in_ECX + 0x14) = 0;
  *(undefined4 *)(in_ECX + 0x18) = 0;
  local_8[0] = '\0';
  local_8[1] = '\0';
  local_8[2] = '\0';
  local_8[3] = '\0';
  uVar6 = FUN_004d4aa0(plVar5->mon_grouping,0,puVar1);
  *(undefined4 *)(in_ECX + 8) = uVar6;
  if (*(char *)(in_ECX + 0x28) == '\0') {
    pcVar7 = plVar5->currency_symbol;
  }
  else {
    pcVar7 = plVar5->int_curr_symbol;
  }
  uVar6 = _Maklocstr<>(pcVar7,0,puVar1);
  *(undefined4 *)(in_ECX + 0x10) = uVar6;
  pcVar7 = "";
  if ((byte)plVar5->p_sign_posn < 5) {
    pcVar7 = plVar5->positive_sign;
  }
  uVar6 = _Maklocstr<>(pcVar7,0,puVar1);
  *(undefined4 *)(in_ECX + 0x14) = uVar6;
  pcVar7 = "-";
  if ((byte)plVar5->n_sign_posn < 5) {
    pcVar7 = plVar5->negative_sign;
  }
  uVar6 = _Maklocstr<>(pcVar7,0,puVar1);
  *(undefined4 *)(in_ECX + 0x18) = uVar6;
  uVar3 = _Maklocchr<>(*plVar5->mon_decimal_point,0,puVar1);
  *(undefined2 *)(in_ECX + 0xc) = uVar3;
  uVar3 = _Maklocchr<>(*plVar5->mon_thousands_sep,0,puVar1);
  *(undefined2 *)(in_ECX + 0xe) = uVar3;
  if (*(char *)(in_ECX + 0x28) == '\0') {
    cVar2 = plVar5->frac_digits;
  }
  else {
    cVar2 = plVar5->int_frac_digits;
  }
  iVar8 = (int)cVar2;
  *(int *)(in_ECX + 0x1c) = iVar8;
  if ((iVar8 < 0) || (0x7e < iVar8)) {
    *(undefined4 *)(in_ECX + 0x1c) = 0;
  }
  Makpat((void *)(in_ECX + 0x20),(int)plVar5->p_sep_by_space,(int)plVar5->p_cs_precedes,
         (int)plVar5->p_sign_posn);
  Makpat((void *)(in_ECX + 0x24),(int)plVar5->n_sep_by_space,(int)plVar5->n_cs_precedes,
         (int)plVar5->n_sign_posn);
  if (param_2 != '\0') {
    _memcpy((void *)(in_ECX + 0x20),&DAT_00b95a64,4);
    _memcpy((void *)(in_ECX + 0x24),&DAT_00b95a64,4);
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
0062607a : PUSH 0x10
0062607c : MOV EAX,0xb0b772
00626081 : CALL 0x00640e50
00626086 : MOV ESI,ECX
00626088 : MOV dword ptr [EBP + -0x14],ESI
0062608b : MOV ECX,dword ptr [EBP + 0x8]
0062608e : LEA EAX,[EBP + -0x1c]
00626091 : PUSH EAX
00626092 : CALL 0x004d03c0
00626097 : MOV ECX,dword ptr [EAX]
00626099 : LEA EBX,[ESI + 0x2c]
0062609c : MOV dword ptr [EBX],ECX
0062609e : MOV EAX,dword ptr [EAX + 0x4]
006260a1 : MOV dword ptr [EBX + 0x4],EAX
006260a4 : CALL 0x0063bc64
006260a9 : MOV EDI,EAX
006260ab : XOR EAX,EAX
006260ad : PUSH EBX
006260ae : PUSH EAX
006260af : MOV dword ptr [ESI + 0x8],EAX
006260b2 : MOV dword ptr [ESI + 0x10],EAX
006260b5 : MOV dword ptr [ESI + 0x14],EAX
006260b8 : MOV dword ptr [ESI + 0x18],EAX
006260bb : PUSH dword ptr [EDI + 0x1c]
006260be : MOV dword ptr [EBP + -0x4],EAX
006260c1 : CALL 0x004d4aa0
006260c6 : ADD ESP,0xc
006260c9 : CMP byte ptr [ESI + 0x28],0x0
006260cd : MOV dword ptr [ESI + 0x8],EAX
006260d0 : JZ 0x006260d7
006260d2 : MOV EAX,dword ptr [EDI + 0xc]
006260d5 : JMP 0x006260da
006260d7 : MOV EAX,dword ptr [EDI + 0x10]
006260da : PUSH EBX
006260db : PUSH 0x0
006260dd : PUSH EAX
006260de : CALL 0x00624d9a
006260e3 : MOV dword ptr [ESI + 0x10],EAX
006260e6 : ADD ESP,0xc
006260e9 : CMP byte ptr [EDI + 0x2e],0x4
006260ed : MOV EAX,0xcca874
006260f2 : JA 0x006260f7
006260f4 : MOV EAX,dword ptr [EDI + 0x20]
006260f7 : PUSH EBX
006260f8 : PUSH 0x0
006260fa : PUSH EAX
006260fb : CALL 0x00624d9a
00626100 : MOV dword ptr [ESI + 0x14],EAX
00626103 : ADD ESP,0xc
00626106 : CMP byte ptr [EDI + 0x2f],0x4
0062610a : MOV EAX,0xb95d70
0062610f : JA 0x00626114
00626111 : MOV EAX,dword ptr [EDI + 0x24]
00626114 : PUSH EBX
00626115 : PUSH 0x0
00626117 : PUSH EAX
00626118 : CALL 0x00624d9a
0062611d : MOV dword ptr [ESI + 0x18],EAX
00626120 : MOV EAX,dword ptr [EDI + 0x14]
00626123 : MOVZX EAX,byte ptr [EAX]
00626126 : ADD ESP,0xc
00626129 : PUSH EBX
0062612a : PUSH 0x0
0062612c : PUSH EAX
0062612d : CALL 0x00624d6c
00626132 : MOV word ptr [ESI + 0xc],AX
00626136 : MOV EAX,dword ptr [EDI + 0x18]
00626139 : MOVZX EAX,byte ptr [EAX]
0062613c : PUSH EBX
0062613d : PUSH 0x0
0062613f : PUSH EAX
00626140 : CALL 0x00624d6c
00626145 : ADD ESP,0x18
00626148 : CMP byte ptr [ESI + 0x28],0x0
0062614c : MOV word ptr [ESI + 0xe],AX
00626150 : JZ 0x00626157
00626152 : MOV AL,byte ptr [EDI + 0x28]
00626155 : JMP 0x0062615a
00626157 : MOV AL,byte ptr [EDI + 0x29]
0062615a : MOVSX EAX,AL
0062615d : MOV dword ptr [ESI + 0x1c],EAX
00626160 : TEST EAX,EAX
00626162 : JL 0x00626169
00626164 : CMP EAX,0x7f
00626167 : JL 0x0062616d
00626169 : AND dword ptr [ESI + 0x1c],0x0
0062616d : MOVSX EAX,byte ptr [EDI + 0x2e]
00626171 : PUSH EAX
00626172 : MOVSX EAX,byte ptr [EDI + 0x2a]
00626176 : PUSH EAX
00626177 : MOVSX EAX,byte ptr [EDI + 0x2b]
0062617b : PUSH EAX
0062617c : LEA EBX,[ESI + 0x20]
0062617f : PUSH EBX
00626180 : MOV ECX,ESI
00626182 : CALL 0x00624f72
00626187 : MOVSX ECX,byte ptr [EDI + 0x2f]
0062618b : PUSH ECX
0062618c : MOVSX ECX,byte ptr [EDI + 0x2c]
00626190 : PUSH ECX
00626191 : MOVSX ECX,byte ptr [EDI + 0x2d]
00626195 : LEA EAX,[ESI + 0x24]
00626198 : PUSH ECX
00626199 : PUSH EAX
0062619a : MOV ECX,ESI
0062619c : MOV dword ptr [EBP + 0x8],EAX
0062619f : CALL 0x00624f72
006261a4 : CMP byte ptr [EBP + 0xc],0x0
006261a8 : JZ 0x006261c6
006261aa : PUSH 0x4
006261ac : MOV ESI,0xb95a64
006261b1 : PUSH ESI
006261b2 : PUSH EBX
006261b3 : CALL 0x0063ae40
006261b8 : PUSH 0x4
006261ba : PUSH ESI
006261bb : PUSH dword ptr [EBP + 0x8]
006261be : CALL 0x0063ae40
006261c3 : ADD ESP,0x18
006261c6 : CALL 0x00640ebc
006261cb : RET 0x8
