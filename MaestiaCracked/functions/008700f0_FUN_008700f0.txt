PROGRAM  : Maestia.exe
FUNCTION : FUN_008700f0
ENTRY    : 008700f0
BODY     : [[008700f0, 00870255]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_008700f0(undefined4 param_1)

{
  int iVar1;
  void *pvVar2;
  uint8_t *puVar3;
  int in_ECX;
  byte bVar4;
  int iVar5;
  void *local_10;
  undefined1 *puStack_c;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  puStack_c = &LAB_00b3db9d;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  if ((DAT_00da93ec != 0) && (*(int *)(DAT_00da93ec + 400) != 0)) {
    (**(code **)(**(int **)(DAT_00da93ec + 400) + 0x24))(DAT_00d66fa0 ^ (uint)&stack0xfffffffc);
  }
  pvVar2 = ThreadLocalStoragePointer;
  iVar5 = DAT_017247d4;
  if (*(char *)(in_ECX + 0x1abd) != '\0') {
    iVar5 = *(int *)ThreadLocalStoragePointer;
    bVar4 = (byte)((ulonglong)(*(byte *)(iVar5 + 0x18) + 1) % 3);
    *(byte *)(iVar5 + 0x18) = bVar4;
    puVar3 = (uint8_t *)((uint)bVar4 * 0x2000 + 0x122cb8 + iVar5);
    if (puVar3 == (uint8_t *)0x0) {
      puVar3 = (uint8_t *)0x0;
    }
    else {
      puVar3[0] = '\0';
      puVar3[1] = '\0';
      puVar3[2] = ':';
      puVar3[3] = '\f';
    }
    local_8 = 0xffffffff;
    if ((*(int *)(DAT_017247d4 + 4) != 0) && (*(char *)(DAT_017247d4 + 8) != '\0')) {
      FUN_00a0dd40(*(int *)(DAT_017247d4 + 4),4,puVar3);
    }
    iVar5 = DAT_017247d4;
    *(undefined1 *)(in_ECX + 0x1abd) = 0;
  }
  if (*(char *)(in_ECX + 0x1abe) != '\0') {
    iVar1 = *(int *)pvVar2;
    bVar4 = (byte)((ulonglong)(*(byte *)(iVar1 + 0x18) + 1) % 3);
    *(byte *)(iVar1 + 0x18) = bVar4;
    puVar3 = (uint8_t *)((uint)bVar4 * 0x2000 + 0x122cb8 + iVar1);
    if (puVar3 == (uint8_t *)0x0) {
      puVar3 = (uint8_t *)0x0;
    }
    else {
      puVar3[0] = '\0';
      puVar3[1] = '\0';
      puVar3[2] = '4';
      puVar3[3] = '&';
    }
    local_8 = 0xffffffff;
    if ((*(int *)(iVar5 + 4) != 0) && (*(char *)(iVar5 + 8) != '\0')) {
      FUN_00a0dd40(*(int *)(iVar5 + 4),4,puVar3);
    }
    *(undefined1 *)(in_ECX + 0x1abe) = 0;
  }
  FUN_00855f80(param_1);
  ExceptionList = local_10;
  return;
}



============================================================
DISASSEMBLY
============================================================
008700f0 : PUSH EBP
008700f1 : MOV EBP,ESP
008700f3 : PUSH -0x1
008700f5 : PUSH 0xb3db9d
008700fa : MOV EAX,FS:[0x0]
00870100 : PUSH EAX
00870101 : SUB ESP,0x8
00870104 : PUSH EBX
00870105 : PUSH ESI
00870106 : PUSH EDI
00870107 : MOV EAX,[0x00d66fa0]
0087010c : XOR EAX,EBP
0087010e : PUSH EAX
0087010f : LEA EAX,[EBP + -0xc]
00870112 : MOV FS:[0x0],EAX
00870118 : MOV EDI,ECX
0087011a : MOV dword ptr [EBP + -0x10],EDI
0087011d : MOV EAX,[0x00da93ec]
00870122 : TEST EAX,EAX
00870124 : JZ 0x0087013e
00870126 : CMP dword ptr [EAX + 0x190],0x0
0087012d : JZ 0x0087013e
0087012f : MOV EAX,dword ptr [EAX + 0x190]
00870135 : MOV EDX,dword ptr [EAX]
00870137 : MOV ECX,EAX
00870139 : MOV EAX,dword ptr [EDX + 0x24]
0087013c : CALL EAX
0087013e : CMP byte ptr [EDI + 0x1abd],0x0
00870145 : MOV EBX,dword ptr FS:[0x2c]
0087014c : JZ 0x008701c2
0087014e : MOV ECX,dword ptr [EBX]
00870150 : MOVZX EAX,byte ptr [ECX + 0x18]
00870154 : INC EAX
00870155 : CDQ
00870156 : MOV ESI,0x3
0087015b : IDIV ESI
0087015d : MOV byte ptr [ECX + 0x18],DL
00870160 : MOVZX EDX,DL
00870163 : SHL EDX,0xd
00870166 : LEA EAX,[EDX + ECX*0x1 + 0x122cb8]
0087016d : MOV dword ptr [EBP + -0x14],EAX
00870170 : MOV dword ptr [EBP + -0x4],0x0
00870177 : TEST EAX,EAX
00870179 : JZ 0x0087018a
0087017b : XOR ECX,ECX
0087017d : MOV word ptr [EAX],CX
00870180 : MOV byte ptr [EAX + 0x2],0x3a
00870184 : MOV byte ptr [EAX + 0x3],0xc
00870188 : JMP 0x0087018c
0087018a : XOR EAX,EAX
0087018c : MOV dword ptr [EBP + -0x4],0xffffffff
00870193 : MOV ESI,dword ptr [0x017247d4]
00870199 : MOV ECX,dword ptr [ESI + 0x4]
0087019c : TEST ECX,ECX
0087019e : JZ 0x008701b9
008701a0 : CMP byte ptr [ESI + 0x8],0x0
008701a4 : JZ 0x008701b9
008701a6 : PUSH 0x4
008701a8 : PUSH ECX
008701a9 : MOV EDI,EAX
008701ab : CALL 0x00a0dd40
008701b0 : MOV ESI,dword ptr [0x017247d4]
008701b6 : MOV EDI,dword ptr [EBP + -0x10]
008701b9 : MOV byte ptr [EDI + 0x1abd],0x0
008701c0 : JMP 0x008701c8
008701c2 : MOV ESI,dword ptr [0x017247d4]
008701c8 : CMP byte ptr [EDI + 0x1abe],0x0
008701cf : JZ 0x00870237
008701d1 : MOV ECX,dword ptr [EBX]
008701d3 : MOVZX EAX,byte ptr [ECX + 0x18]
008701d7 : INC EAX
008701d8 : CDQ
008701d9 : MOV EBX,0x3
008701de : IDIV EBX
008701e0 : MOV byte ptr [ECX + 0x18],DL
008701e3 : MOVZX EDX,DL
008701e6 : SHL EDX,0xd
008701e9 : LEA EAX,[EDX + ECX*0x1 + 0x122cb8]
008701f0 : MOV dword ptr [EBP + -0x14],EAX
008701f3 : MOV dword ptr [EBP + -0x4],0x1
008701fa : TEST EAX,EAX
008701fc : JZ 0x0087020d
008701fe : XOR ECX,ECX
00870200 : MOV word ptr [EAX],CX
00870203 : MOV byte ptr [EAX + 0x2],0x34
00870207 : MOV byte ptr [EAX + 0x3],0x26
0087020b : JMP 0x0087020f
0087020d : XOR EAX,EAX
0087020f : MOV dword ptr [EBP + -0x4],0xffffffff
00870216 : MOV ECX,dword ptr [ESI + 0x4]
00870219 : TEST ECX,ECX
0087021b : JZ 0x00870230
0087021d : CMP byte ptr [ESI + 0x8],0x0
00870221 : JZ 0x00870230
00870223 : PUSH 0x4
00870225 : PUSH ECX
00870226 : MOV EDI,EAX
00870228 : CALL 0x00a0dd40
0087022d : MOV EDI,dword ptr [EBP + -0x10]
00870230 : MOV byte ptr [EDI + 0x1abe],0x0
00870237 : MOV EDX,dword ptr [EBP + 0x8]
0087023a : PUSH EDX
0087023b : MOV ECX,EDI
0087023d : CALL 0x00855f80
00870242 : MOV ECX,dword ptr [EBP + -0xc]
00870245 : MOV dword ptr FS:[0x0],ECX
0087024c : POP ECX
0087024d : POP EDI
0087024e : POP ESI
0087024f : POP EBX
00870250 : MOV ESP,EBP
00870252 : POP EBP
00870253 : RET 0x4
