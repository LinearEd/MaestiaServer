PROGRAM  : Maestia.exe
FUNCTION : FUN_0085dcf0
ENTRY    : 0085dcf0
BODY     : [[0085dcf0, 0085de1d]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0085dcf0(void)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  short sVar5;
  uint uVar6;
  short *psVar7;
  int unaff_ESI;
  int iVar8;
  short local_14;
  int local_10;
  int local_c;
  undefined1 local_8 [4];
  
  iVar2 = *(int *)(unaff_ESI + 0x18a8);
  if ((((iVar2 != 0) && (*(char *)(iVar2 + 0x20) != '\0')) &&
      (iVar2 = *(int *)(iVar2 + 0x24), iVar2 != 0)) && (DAT_017247ec != 0)) {
    local_10 = -(uint)(*(int *)(DAT_017247ec + 0x28) != 0);
    iVar3 = local_10;
    iVar4 = DAT_017247ec;
joined_r0x0085dd36:
    if (iVar3 != 0) {
      if (iVar4 != 0) {
        local_c = 0;
        FUN_00404160(&local_10,local_8,&local_c);
        iVar3 = local_10;
        if ((local_c != 0) && (local_14 = (short)iVar2, *(short *)(local_c + 0x9e) == local_14)) {
          iVar8 = 0;
          psVar7 = (short *)(local_c + 0x48);
          do {
            sVar1 = *psVar7;
            if (sVar1 != 0) {
              uVar6 = 0;
              do {
                if (((byte)uVar6 < 0x21) && (*(int *)(unaff_ESI + 0x17f0 + (uVar6 & 0xff) * 4) != 0)
                   ) {
                  sVar5 = (short)*(undefined4 *)(unaff_ESI + 0x16e8 + (uVar6 & 0xff) * 4);
                }
                else {
                  sVar5 = 0;
                }
                if (sVar5 == sVar1) goto LAB_0085de0f;
                uVar6 = uVar6 + 1;
              } while ((int)uVar6 < 0xc);
              uVar6 = 0x14;
              while( true ) {
                if (((byte)uVar6 < 0x21) && (*(int *)(unaff_ESI + 0x17f0 + (uVar6 & 0xff) * 4) != 0)
                   ) {
                  sVar5 = (short)*(undefined4 *)(unaff_ESI + 0x16e8 + (uVar6 & 0xff) * 4);
                }
                else {
                  sVar5 = 0;
                }
                if (sVar5 == sVar1) break;
                uVar6 = uVar6 + 1;
                if (0x1d < (int)uVar6) {
                  FUN_0085c0c0(unaff_ESI,*(undefined2 *)(local_c + 6),1);
                  iVar3 = local_10;
                  iVar4 = DAT_017247ec;
                  goto joined_r0x0085dd36;
                }
              }
            }
LAB_0085de0f:
            iVar8 = iVar8 + 1;
            psVar7 = psVar7 + 1;
            iVar4 = DAT_017247ec;
          } while (iVar8 < 0xc);
        }
      }
      goto joined_r0x0085dd36;
    }
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
0085dcf0 : PUSH EBP
0085dcf1 : MOV EBP,ESP
0085dcf3 : MOV EAX,dword ptr [ESI + 0x18a8]
0085dcf9 : SUB ESP,0x10
0085dcfc : PUSH EBX
0085dcfd : PUSH EDI
0085dcfe : TEST EAX,EAX
0085dd00 : JZ 0x0085de09
0085dd06 : CMP byte ptr [EAX + 0x20],0x0
0085dd0a : JZ 0x0085de09
0085dd10 : MOV EAX,dword ptr [EAX + 0x24]
0085dd13 : MOV dword ptr [EBP + -0x10],EAX
0085dd16 : TEST EAX,EAX
0085dd18 : JZ 0x0085de09
0085dd1e : MOV EDI,dword ptr [0x017247ec]
0085dd24 : TEST EDI,EDI
0085dd26 : JZ 0x0085de09
0085dd2c : MOV EAX,dword ptr [EDI + 0x28]
0085dd2f : NEG EAX
0085dd31 : SBB EAX,EAX
0085dd33 : MOV dword ptr [EBP + -0xc],EAX
0085dd36 : JZ 0x0085de09
0085dd3c : LEA ESP,[ESP]
0085dd40 : TEST EDI,EDI
0085dd42 : JZ 0x0085de01
0085dd48 : LEA EAX,[EBP + -0x8]
0085dd4b : PUSH EAX
0085dd4c : LEA ECX,[EBP + -0x4]
0085dd4f : PUSH ECX
0085dd50 : LEA EDX,[EBP + -0xc]
0085dd53 : PUSH EDX
0085dd54 : MOV EAX,EDI
0085dd56 : MOV dword ptr [EBP + -0x8],0x0
0085dd5d : CALL 0x00404160
0085dd62 : MOV EBX,dword ptr [EBP + -0x8]
0085dd65 : TEST EBX,EBX
0085dd67 : JZ 0x0085ddfe
0085dd6d : MOV AX,word ptr [EBP + -0x10]
0085dd71 : CMP word ptr [EBX + 0x9e],AX
0085dd78 : JNZ 0x0085ddfe
0085dd7e : XOR EDI,EDI
0085dd80 : ADD EBX,0x48
0085dd83 : MOVZX EDX,word ptr [EBX]
0085dd86 : TEST DX,DX
0085dd89 : JZ 0x0085de0f
0085dd8f : XOR ECX,ECX
0085dd91 : CMP CL,0x21
0085dd94 : JNC 0x0085ddac
0085dd96 : MOVZX EAX,CL
0085dd99 : CMP dword ptr [ESI + EAX*0x4 + 0x17f0],0x0
0085dda1 : JZ 0x0085ddac
0085dda3 : MOV EAX,dword ptr [ESI + EAX*0x4 + 0x16e8]
0085ddaa : JMP 0x0085ddae
0085ddac : XOR EAX,EAX
0085ddae : CMP AX,DX
0085ddb1 : JZ 0x0085de0f
0085ddb3 : INC ECX
0085ddb4 : CMP ECX,0xb
0085ddb7 : JLE 0x0085dd91
0085ddb9 : MOV ECX,0x14
0085ddbe : MOV EDI,EDI
0085ddc0 : CMP CL,0x21
0085ddc3 : JNC 0x0085dddb
0085ddc5 : MOVZX EAX,CL
0085ddc8 : CMP dword ptr [ESI + EAX*0x4 + 0x17f0],0x0
0085ddd0 : JZ 0x0085dddb
0085ddd2 : MOV EAX,dword ptr [ESI + EAX*0x4 + 0x16e8]
0085ddd9 : JMP 0x0085dddd
0085dddb : XOR EAX,EAX
0085dddd : CMP AX,DX
0085dde0 : JZ 0x0085de0f
0085dde2 : INC ECX
0085dde3 : CMP ECX,0x1d
0085dde6 : JLE 0x0085ddc0
0085dde8 : MOV ECX,dword ptr [EBP + -0x8]
0085ddeb : MOVZX EDX,word ptr [ECX + 0x6]
0085ddef : PUSH 0x1
0085ddf1 : PUSH EDX
0085ddf2 : PUSH ESI
0085ddf3 : CALL 0x0085c0c0
0085ddf8 : MOV EDI,dword ptr [0x017247ec]
0085ddfe : MOV EAX,dword ptr [EBP + -0xc]
0085de01 : TEST EAX,EAX
0085de03 : JNZ 0x0085dd40
0085de09 : POP EDI
0085de0a : POP EBX
0085de0b : MOV ESP,EBP
0085de0d : POP EBP
0085de0e : RET
0085de0f : INC EDI
0085de10 : ADD EBX,0x2
0085de13 : CMP EDI,0xc
0085de16 : JL 0x0085dd83
0085de1c : JMP 0x0085ddf8
