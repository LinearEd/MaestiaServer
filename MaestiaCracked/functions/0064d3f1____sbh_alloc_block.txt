PROGRAM  : Maestia.exe
FUNCTION : ___sbh_alloc_block
ENTRY    : 0064d3f1
BODY     : [[0064d3f1, 0064d6d5]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    ___sbh_alloc_block
   
   Library: Visual Studio 2008 Release */

int * ___sbh_alloc_block(uint *param_1)

{
  int *piVar1;
  char *pcVar2;
  int *piVar3;
  char cVar4;
  int *piVar5;
  undefined4 uVar6;
  byte bVar7;
  uint uVar8;
  int iVar9;
  uint *puVar10;
  int iVar11;
  uint uVar12;
  int *piVar13;
  uint *puVar14;
  uint *puVar15;
  uint uVar16;
  int iVar17;
  uint local_c;
  int local_8;
  
  puVar10 = DAT_01728d48 + DAT_01728d44 * 5;
  uVar8 = (int)param_1 + 0x17U & 0xfffffff0;
  iVar9 = ((int)((int)param_1 + 0x17U) >> 4) + -1;
  bVar7 = (byte)iVar9;
  param_1 = DAT_01728d50;
  if (iVar9 < 0x20) {
    uVar16 = 0xffffffff >> (bVar7 & 0x1f);
    local_c = 0xffffffff;
  }
  else {
    uVar16 = 0;
    local_c = 0xffffffff >> (bVar7 - 0x20 & 0x1f);
  }
  for (; (param_1 < puVar10 && ((param_1[1] & local_c) == 0 && (*param_1 & uVar16) == 0));
      param_1 = param_1 + 5) {
  }
  puVar14 = DAT_01728d48;
  if (param_1 == puVar10) {
    for (; (puVar14 < DAT_01728d50 && ((puVar14[1] & local_c) == 0 && (*puVar14 & uVar16) == 0));
        puVar14 = puVar14 + 5) {
    }
    param_1 = puVar14;
    if (puVar14 == DAT_01728d50) {
      for (; (puVar14 < puVar10 && (puVar14[2] == 0)); puVar14 = puVar14 + 5) {
      }
      puVar15 = DAT_01728d48;
      param_1 = puVar14;
      if (puVar14 == puVar10) {
        for (; (puVar15 < DAT_01728d50 && (puVar15[2] == 0)); puVar15 = puVar15 + 5) {
        }
        param_1 = puVar15;
        if ((puVar15 == DAT_01728d50) &&
           (param_1 = (uint *)___sbh_alloc_new_region(), param_1 == (uint *)0x0)) {
          return (int *)0x0;
        }
      }
      uVar6 = ___sbh_alloc_new_group(param_1);
      *(undefined4 *)param_1[4] = uVar6;
      if (*(int *)param_1[4] == -1) {
        return (int *)0x0;
      }
    }
  }
  piVar5 = (int *)param_1[4];
  local_8 = *piVar5;
  if ((local_8 == -1) ||
     ((piVar5[local_8 + 0x31] & local_c) == 0 && (piVar5[local_8 + 0x11] & uVar16) == 0)) {
    local_8 = 0;
    puVar10 = (uint *)(piVar5 + 0x11);
    uVar12 = piVar5[0x31];
    while ((uVar12 & local_c) == 0 && (*puVar10 & uVar16) == 0) {
      local_8 = local_8 + 1;
      puVar14 = puVar10 + 0x21;
      puVar10 = puVar10 + 1;
      uVar12 = *puVar14;
    }
  }
  piVar3 = piVar5 + local_8 * 0x81 + 0x51;
  iVar9 = 0;
  uVar16 = piVar5[local_8 + 0x11] & uVar16;
  if (uVar16 == 0) {
    uVar16 = piVar5[local_8 + 0x31] & local_c;
    iVar9 = 0x20;
  }
  for (; -1 < (int)uVar16; uVar16 = uVar16 * 2) {
    iVar9 = iVar9 + 1;
  }
  piVar13 = (int *)piVar3[iVar9 * 2 + 1];
  iVar11 = *piVar13 - uVar8;
  iVar17 = (iVar11 >> 4) + -1;
  if (0x3f < iVar17) {
    iVar17 = 0x3f;
  }
  DAT_01728d50 = param_1;
  if (iVar17 != iVar9) {
    if (piVar13[1] == piVar13[2]) {
      if (iVar9 < 0x20) {
        pcVar2 = (char *)((int)piVar5 + iVar9 + 4);
        uVar16 = ~(0x80000000U >> ((byte)iVar9 & 0x1f));
        piVar5[local_8 + 0x11] = uVar16 & piVar5[local_8 + 0x11];
        *pcVar2 = *pcVar2 + -1;
        if (*pcVar2 == '\0') {
          *param_1 = *param_1 & uVar16;
        }
      }
      else {
        pcVar2 = (char *)((int)piVar5 + iVar9 + 4);
        uVar16 = ~(0x80000000U >> ((byte)iVar9 - 0x20 & 0x1f));
        piVar5[local_8 + 0x31] = piVar5[local_8 + 0x31] & uVar16;
        *pcVar2 = *pcVar2 + -1;
        if (*pcVar2 == '\0') {
          param_1[1] = param_1[1] & uVar16;
        }
      }
    }
    *(int *)(piVar13[2] + 4) = piVar13[1];
    *(int *)(piVar13[1] + 8) = piVar13[2];
    if (iVar11 == 0) goto LAB_0064d693;
    piVar1 = piVar3 + iVar17 * 2;
    iVar9 = piVar1[1];
    piVar13[2] = (int)piVar1;
    piVar13[1] = iVar9;
    piVar1[1] = (int)piVar13;
    *(int **)(piVar13[1] + 8) = piVar13;
    if (piVar13[1] == piVar13[2]) {
      cVar4 = *(char *)(iVar17 + 4 + (int)piVar5);
      *(char *)(iVar17 + 4 + (int)piVar5) = cVar4 + '\x01';
      bVar7 = (byte)iVar17;
      if (iVar17 < 0x20) {
        if (cVar4 == '\0') {
          *param_1 = *param_1 | 0x80000000U >> (bVar7 & 0x1f);
        }
        piVar5[local_8 + 0x11] = piVar5[local_8 + 0x11] | 0x80000000U >> (bVar7 & 0x1f);
      }
      else {
        if (cVar4 == '\0') {
          param_1[1] = param_1[1] | 0x80000000U >> (bVar7 - 0x20 & 0x1f);
        }
        piVar5[local_8 + 0x31] = piVar5[local_8 + 0x31] | 0x80000000U >> (bVar7 - 0x20 & 0x1f);
      }
    }
  }
  if (iVar11 != 0) {
    *piVar13 = iVar11;
    *(int *)(iVar11 + -4 + (int)piVar13) = iVar11;
  }
LAB_0064d693:
  piVar13 = (int *)((int)piVar13 + iVar11);
  *piVar13 = uVar8 + 1;
  *(uint *)((int)piVar13 + (uVar8 - 4)) = uVar8 + 1;
  iVar9 = *piVar3;
  *piVar3 = iVar9 + 1;
  if (((iVar9 == 0) && (param_1 == DAT_00d7c098)) && (local_8 == DAT_01728d58)) {
    DAT_00d7c098 = (uint *)0x0;
  }
  *piVar5 = local_8;
  return piVar13 + 1;
}



============================================================
DISASSEMBLY
============================================================
0064d3f1 : MOV EDI,EDI
0064d3f3 : PUSH EBP
0064d3f4 : MOV EBP,ESP
0064d3f6 : SUB ESP,0x14
0064d3f9 : MOV EAX,[0x01728d44]
0064d3fe : MOV ECX,dword ptr [EBP + 0x8]
0064d401 : IMUL EAX,EAX,0x14
0064d404 : ADD EAX,dword ptr [0x01728d48]
0064d40a : ADD ECX,0x17
0064d40d : AND ECX,0xfffffff0
0064d410 : MOV dword ptr [EBP + -0x10],ECX
0064d413 : SAR ECX,0x4
0064d416 : PUSH EBX
0064d417 : DEC ECX
0064d418 : CMP ECX,0x20
0064d41b : PUSH ESI
0064d41c : PUSH EDI
0064d41d : JGE 0x0064d42a
0064d41f : OR ESI,0xffffffff
0064d422 : SHR ESI,CL
0064d424 : OR dword ptr [EBP + -0x8],0xffffffff
0064d428 : JMP 0x0064d437
0064d42a : ADD ECX,-0x20
0064d42d : OR EDX,0xffffffff
0064d430 : XOR ESI,ESI
0064d432 : SHR EDX,CL
0064d434 : MOV dword ptr [EBP + -0x8],EDX
0064d437 : MOV ECX,dword ptr [0x01728d50]
0064d43d : MOV EBX,ECX
0064d43f : JMP 0x0064d452
0064d441 : MOV EDX,dword ptr [EBX + 0x4]
0064d444 : MOV EDI,dword ptr [EBX]
0064d446 : AND EDX,dword ptr [EBP + -0x8]
0064d449 : AND EDI,ESI
0064d44b : OR EDX,EDI
0064d44d : JNZ 0x0064d459
0064d44f : ADD EBX,0x14
0064d452 : MOV dword ptr [EBP + 0x8],EBX
0064d455 : CMP EBX,EAX
0064d457 : JC 0x0064d441
0064d459 : CMP EBX,EAX
0064d45b : JNZ 0x0064d4dc
0064d45d : MOV EBX,dword ptr [0x01728d48]
0064d463 : JMP 0x0064d476
0064d465 : MOV EDX,dword ptr [EBX + 0x4]
0064d468 : MOV EDI,dword ptr [EBX]
0064d46a : AND EDX,dword ptr [EBP + -0x8]
0064d46d : AND EDI,ESI
0064d46f : OR EDX,EDI
0064d471 : JNZ 0x0064d47d
0064d473 : ADD EBX,0x14
0064d476 : MOV dword ptr [EBP + 0x8],EBX
0064d479 : CMP EBX,ECX
0064d47b : JC 0x0064d465
0064d47d : CMP EBX,ECX
0064d47f : JNZ 0x0064d4dc
0064d481 : JMP 0x0064d48f
0064d483 : CMP dword ptr [EBX + 0x8],0x0
0064d487 : JNZ 0x0064d493
0064d489 : ADD EBX,0x14
0064d48c : MOV dword ptr [EBP + 0x8],EBX
0064d48f : CMP EBX,EAX
0064d491 : JC 0x0064d483
0064d493 : CMP EBX,EAX
0064d495 : JNZ 0x0064d4c8
0064d497 : MOV EBX,dword ptr [0x01728d48]
0064d49d : JMP 0x0064d4a8
0064d49f : CMP dword ptr [EBX + 0x8],0x0
0064d4a3 : JNZ 0x0064d4af
0064d4a5 : ADD EBX,0x14
0064d4a8 : MOV dword ptr [EBP + 0x8],EBX
0064d4ab : CMP EBX,ECX
0064d4ad : JC 0x0064d49f
0064d4af : CMP EBX,ECX
0064d4b1 : JNZ 0x0064d4c8
0064d4b3 : CALL 0x0064cf58
0064d4b8 : MOV EBX,EAX
0064d4ba : MOV dword ptr [EBP + 0x8],EBX
0064d4bd : TEST EBX,EBX
0064d4bf : JNZ 0x0064d4c8
0064d4c1 : XOR EAX,EAX
0064d4c3 : JMP 0x0064d6d1
0064d4c8 : PUSH EBX
0064d4c9 : CALL 0x0064d008
0064d4ce : POP ECX
0064d4cf : MOV ECX,dword ptr [EBX + 0x10]
0064d4d2 : MOV dword ptr [ECX],EAX
0064d4d4 : MOV EAX,dword ptr [EBX + 0x10]
0064d4d7 : CMP dword ptr [EAX],-0x1
0064d4da : JZ 0x0064d4c1
0064d4dc : MOV dword ptr [0x01728d50],EBX
0064d4e2 : MOV EAX,dword ptr [EBX + 0x10]
0064d4e5 : MOV EDX,dword ptr [EAX]
0064d4e7 : MOV dword ptr [EBP + -0x4],EDX
0064d4ea : CMP EDX,-0x1
0064d4ed : JZ 0x0064d503
0064d4ef : MOV ECX,dword ptr [EAX + EDX*0x4 + 0xc4]
0064d4f6 : MOV EDI,dword ptr [EAX + EDX*0x4 + 0x44]
0064d4fa : AND ECX,dword ptr [EBP + -0x8]
0064d4fd : AND EDI,ESI
0064d4ff : OR ECX,EDI
0064d501 : JNZ 0x0064d52c
0064d503 : AND dword ptr [EBP + -0x4],0x0
0064d507 : MOV EDX,dword ptr [EAX + 0xc4]
0064d50d : LEA ECX,[EAX + 0x44]
0064d510 : MOV EDI,dword ptr [ECX]
0064d512 : AND EDX,dword ptr [EBP + -0x8]
0064d515 : AND EDI,ESI
0064d517 : OR EDX,EDI
0064d519 : JNZ 0x0064d529
0064d51b : INC dword ptr [EBP + -0x4]
0064d51e : MOV EDX,dword ptr [ECX + 0x84]
0064d524 : ADD ECX,0x4
0064d527 : JMP 0x0064d510
0064d529 : MOV EDX,dword ptr [EBP + -0x4]
0064d52c : MOV ECX,EDX
0064d52e : IMUL ECX,ECX,0x204
0064d534 : LEA ECX,[ECX + EAX*0x1 + 0x144]
0064d53b : MOV dword ptr [EBP + -0xc],ECX
0064d53e : MOV ECX,dword ptr [EAX + EDX*0x4 + 0x44]
0064d542 : XOR EDI,EDI
0064d544 : AND ECX,ESI
0064d546 : JNZ 0x0064d55a
0064d548 : MOV ECX,dword ptr [EAX + EDX*0x4 + 0xc4]
0064d54f : AND ECX,dword ptr [EBP + -0x8]
0064d552 : PUSH 0x20
0064d554 : POP EDI
0064d555 : JMP 0x0064d55a
0064d557 : ADD ECX,ECX
0064d559 : INC EDI
0064d55a : TEST ECX,ECX
0064d55c : JGE 0x0064d557
0064d55e : MOV ECX,dword ptr [EBP + -0xc]
0064d561 : MOV EDX,dword ptr [ECX + EDI*0x8 + 0x4]
0064d565 : MOV ECX,dword ptr [EDX]
0064d567 : SUB ECX,dword ptr [EBP + -0x10]
0064d56a : MOV ESI,ECX
0064d56c : SAR ESI,0x4
0064d56f : DEC ESI
0064d570 : CMP ESI,0x3f
0064d573 : MOV dword ptr [EBP + -0x8],ECX
0064d576 : JLE 0x0064d57b
0064d578 : PUSH 0x3f
0064d57a : POP ESI
0064d57b : CMP ESI,EDI
0064d57d : JZ 0x0064d684
0064d583 : MOV ECX,dword ptr [EDX + 0x4]
0064d586 : CMP ECX,dword ptr [EDX + 0x8]
0064d589 : JNZ 0x0064d5e7
0064d58b : CMP EDI,0x20
0064d58e : MOV EBX,0x80000000
0064d593 : JGE 0x0064d5bb
0064d595 : MOV ECX,EDI
0064d597 : SHR EBX,CL
0064d599 : MOV ECX,dword ptr [EBP + -0x4]
0064d59c : LEA EDI,[EAX + EDI*0x1 + 0x4]
0064d5a0 : NOT EBX
0064d5a2 : MOV dword ptr [EBP + -0x14],EBX
0064d5a5 : AND EBX,dword ptr [EAX + ECX*0x4 + 0x44]
0064d5a9 : MOV dword ptr [EAX + ECX*0x4 + 0x44],EBX
0064d5ad : DEC byte ptr [EDI]
0064d5af : JNZ 0x0064d5e4
0064d5b1 : MOV ECX,dword ptr [EBP + -0x14]
0064d5b4 : MOV EBX,dword ptr [EBP + 0x8]
0064d5b7 : AND dword ptr [EBX],ECX
0064d5b9 : JMP 0x0064d5e7
0064d5bb : LEA ECX,[EDI + -0x20]
0064d5be : SHR EBX,CL
0064d5c0 : MOV ECX,dword ptr [EBP + -0x4]
0064d5c3 : LEA ECX,[EAX + ECX*0x4 + 0xc4]
0064d5ca : LEA EDI,[EAX + EDI*0x1 + 0x4]
0064d5ce : NOT EBX
0064d5d0 : AND dword ptr [ECX],EBX
0064d5d2 : DEC byte ptr [EDI]
0064d5d4 : MOV dword ptr [EBP + -0x14],EBX
0064d5d7 : JNZ 0x0064d5e4
0064d5d9 : MOV EBX,dword ptr [EBP + 0x8]
0064d5dc : MOV ECX,dword ptr [EBP + -0x14]
0064d5df : AND dword ptr [EBX + 0x4],ECX
0064d5e2 : JMP 0x0064d5e7
0064d5e4 : MOV EBX,dword ptr [EBP + 0x8]
0064d5e7 : CMP dword ptr [EBP + -0x8],0x0
0064d5eb : MOV ECX,dword ptr [EDX + 0x8]
0064d5ee : MOV EDI,dword ptr [EDX + 0x4]
0064d5f1 : MOV dword ptr [ECX + 0x4],EDI
0064d5f4 : MOV ECX,dword ptr [EDX + 0x4]
0064d5f7 : MOV EDI,dword ptr [EDX + 0x8]
0064d5fa : MOV dword ptr [ECX + 0x8],EDI
0064d5fd : JZ 0x0064d690
0064d603 : MOV ECX,dword ptr [EBP + -0xc]
0064d606 : LEA ECX,[ECX + ESI*0x8]
0064d609 : MOV EDI,dword ptr [ECX + 0x4]
0064d60c : MOV dword ptr [EDX + 0x8],ECX
0064d60f : MOV dword ptr [EDX + 0x4],EDI
0064d612 : MOV dword ptr [ECX + 0x4],EDX
0064d615 : MOV ECX,dword ptr [EDX + 0x4]
0064d618 : MOV dword ptr [ECX + 0x8],EDX
0064d61b : MOV ECX,dword ptr [EDX + 0x4]
0064d61e : CMP ECX,dword ptr [EDX + 0x8]
0064d621 : JNZ 0x0064d681
0064d623 : MOV CL,byte ptr [ESI + EAX*0x1 + 0x4]
0064d627 : MOV byte ptr [EBP + 0xb],CL
0064d62a : INC CL
0064d62c : CMP ESI,0x20
0064d62f : MOV byte ptr [ESI + EAX*0x1 + 0x4],CL
0064d633 : JGE 0x0064d658
0064d635 : CMP byte ptr [EBP + 0xb],0x0
0064d639 : JNZ 0x0064d646
0064d63b : MOV EDI,0x80000000
0064d640 : MOV ECX,ESI
0064d642 : SHR EDI,CL
0064d644 : OR dword ptr [EBX],EDI
0064d646 : MOV ECX,ESI
0064d648 : MOV EDI,0x80000000
0064d64d : SHR EDI,CL
0064d64f : MOV ECX,dword ptr [EBP + -0x4]
0064d652 : OR dword ptr [EAX + ECX*0x4 + 0x44],EDI
0064d656 : JMP 0x0064d681
0064d658 : CMP byte ptr [EBP + 0xb],0x0
0064d65c : JNZ 0x0064d66b
0064d65e : LEA ECX,[ESI + -0x20]
0064d661 : MOV EDI,0x80000000
0064d666 : SHR EDI,CL
0064d668 : OR dword ptr [EBX + 0x4],EDI
0064d66b : MOV ECX,dword ptr [EBP + -0x4]
0064d66e : LEA EDI,[EAX + ECX*0x4 + 0xc4]
0064d675 : LEA ECX,[ESI + -0x20]
0064d678 : MOV ESI,0x80000000
0064d67d : SHR ESI,CL
0064d67f : OR dword ptr [EDI],ESI
0064d681 : MOV ECX,dword ptr [EBP + -0x8]
0064d684 : TEST ECX,ECX
0064d686 : JZ 0x0064d693
0064d688 : MOV dword ptr [EDX],ECX
0064d68a : MOV dword ptr [ECX + EDX*0x1 + -0x4],ECX
0064d68e : JMP 0x0064d693
0064d690 : MOV ECX,dword ptr [EBP + -0x8]
0064d693 : MOV ESI,dword ptr [EBP + -0x10]
0064d696 : ADD EDX,ECX
0064d698 : LEA ECX,[ESI + 0x1]
0064d69b : MOV dword ptr [EDX],ECX
0064d69d : MOV dword ptr [EDX + ESI*0x1 + -0x4],ECX
0064d6a1 : MOV ESI,dword ptr [EBP + -0xc]
0064d6a4 : MOV ECX,dword ptr [ESI]
0064d6a6 : LEA EDI,[ECX + 0x1]
0064d6a9 : MOV dword ptr [ESI],EDI
0064d6ab : TEST ECX,ECX
0064d6ad : JNZ 0x0064d6c9
0064d6af : CMP EBX,dword ptr [0x00d7c098]
0064d6b5 : JNZ 0x0064d6c9
0064d6b7 : MOV ECX,dword ptr [EBP + -0x4]
0064d6ba : CMP ECX,dword ptr [0x01728d58]
0064d6c0 : JNZ 0x0064d6c9
0064d6c2 : AND dword ptr [0x00d7c098],0x0
0064d6c9 : MOV ECX,dword ptr [EBP + -0x4]
0064d6cc : MOV dword ptr [EAX],ECX
0064d6ce : LEA EAX,[EDX + 0x4]
0064d6d1 : POP EDI
0064d6d2 : POP ESI
0064d6d3 : POP EBX
0064d6d4 : LEAVE
0064d6d5 : RET
