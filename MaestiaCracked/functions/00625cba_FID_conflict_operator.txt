PROGRAM  : Maestia.exe
FUNCTION : FID_conflict:operator+=
ENTRY    : 00625cba
BODY     : [[00625cba, 00625d1c]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Multiple Matches With Different Base Names
    public: class std::_String_const_iterator<unsigned short,struct std::char_traits<unsigned
   short>,class std::allocator<unsigned short> > & __thiscall std::_String_const_iterator<unsigned
   short,struct std::char_traits<unsigned short>,class std::allocator<unsigned short>
   >::operator+=(int)
    public: class std::_String_const_iterator<wchar_t,struct std::char_traits<wchar_t>,class
   std::allocator<wchar_t> > & __thiscall std::_String_const_iterator<wchar_t,struct
   std::char_traits<wchar_t>,class std::allocator<wchar_t> >::operator+=(int)
   
   Library: Visual Studio 2008 Release */

void FID_conflict_operator__(int param_1)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int *in_ECX;
  int iVar4;
  
  if (*in_ECX != -4) {
    if (*in_ECX == 0) {
      FUN_006372de();
    }
    iVar2 = *in_ECX;
    if (*(uint *)(iVar2 + 0x18) < 8) {
      iVar4 = iVar2 + 4;
    }
    else {
      iVar4 = *(int *)(iVar2 + 4);
    }
    uVar1 = in_ECX[1] + param_1 * 2;
    if (uVar1 <= (uint)(iVar4 + *(int *)(iVar2 + 0x14) * 2)) {
      if (*(uint *)(iVar2 + 0x18) < 8) {
        uVar3 = iVar2 + 4;
      }
      else {
        uVar3 = *(uint *)(iVar2 + 4);
      }
      if (uVar3 <= uVar1) goto LAB_00625d0f;
    }
    FUN_006372de();
  }
LAB_00625d0f:
  in_ECX[1] = in_ECX[1] + param_1 * 2;
  return;
}



============================================================
DISASSEMBLY
============================================================
00625cba : MOV EDI,EDI
00625cbc : PUSH EBP
00625cbd : MOV EBP,ESP
00625cbf : PUSH ESI
00625cc0 : MOV ESI,ECX
00625cc2 : MOV EAX,dword ptr [ESI]
00625cc4 : PUSH EDI
00625cc5 : MOV EDI,dword ptr [EBP + 0x8]
00625cc8 : CMP EAX,-0x4
00625ccb : JZ 0x00625d0f
00625ccd : TEST EAX,EAX
00625ccf : JNZ 0x00625cd6
00625cd1 : CALL 0x006372de
00625cd6 : MOV EAX,dword ptr [ESI]
00625cd8 : CMP dword ptr [EAX + 0x18],0x8
00625cdc : JC 0x00625ce3
00625cde : MOV ECX,dword ptr [EAX + 0x4]
00625ce1 : JMP 0x00625ce6
00625ce3 : LEA ECX,[EAX + 0x4]
00625ce6 : MOV EDX,dword ptr [ESI + 0x4]
00625ce9 : PUSH EBX
00625cea : MOV EBX,dword ptr [EAX + 0x14]
00625ced : LEA ECX,[ECX + EBX*0x2]
00625cf0 : LEA EDX,[EDX + EDI*0x2]
00625cf3 : POP EBX
00625cf4 : CMP EDX,ECX
00625cf6 : JA 0x00625d0a
00625cf8 : CMP dword ptr [EAX + 0x18],0x8
00625cfc : JC 0x00625d03
00625cfe : MOV EAX,dword ptr [EAX + 0x4]
00625d01 : JMP 0x00625d06
00625d03 : ADD EAX,0x4
00625d06 : CMP EDX,EAX
00625d08 : JNC 0x00625d0f
00625d0a : CALL 0x006372de
00625d0f : LEA EAX,[EDI + EDI*0x1]
00625d12 : ADD dword ptr [ESI + 0x4],EAX
00625d15 : POP EDI
00625d16 : MOV EAX,ESI
00625d18 : POP ESI
00625d19 : POP EBP
00625d1a : RET 0x4
