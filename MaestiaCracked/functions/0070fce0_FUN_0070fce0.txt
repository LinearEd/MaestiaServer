PROGRAM  : Maestia.exe
FUNCTION : FUN_0070fce0
ENTRY    : 0070fce0
BODY     : [[0070fce0, 0070feb2]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0070fce0(int param_1,int param_2)

{
  int iVar1;
  int iVar2;
  int in_EAX;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  int unaff_EDI;
  
  iVar2 = param_2;
  param_2 = 0;
  if (*(int *)(in_EAX + 0x7c) < 1) {
    uVar4 = iVar2 + 5;
  }
  else {
    if (*(char *)(in_EAX + 0x1c) == '\x02') {
      FUN_0070e4f0();
    }
    FUN_0070f9b0(in_EAX + 0xb10);
    FUN_0070f9b0(in_EAX + 0xb1c);
    param_2 = FUN_0070fc10();
    uVar5 = *(int *)(in_EAX + 0x16a0) + 10U >> 3;
    uVar4 = *(int *)(in_EAX + 0x16a4) + 10U >> 3;
    if (uVar5 < uVar4) goto LAB_0070fd4a;
  }
  uVar5 = uVar4;
LAB_0070fd4a:
  if ((uVar5 < iVar2 + 4U) || (param_1 == 0)) {
    iVar2 = *(int *)(in_EAX + 0x16b4);
    bVar3 = (byte)iVar2;
    if (uVar4 == uVar5) {
      iVar1 = unaff_EDI + 2;
      if (iVar2 < 0xe) {
        *(ushort *)(in_EAX + 0x16b0) =
             *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar1 << (bVar3 & 0x1f));
        *(int *)(in_EAX + 0x16b4) = iVar2 + 3;
      }
      else {
        *(ushort *)(in_EAX + 0x16b0) =
             *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar1 << (bVar3 & 0x1f));
        *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
             *(undefined1 *)(in_EAX + 0x16b0);
        *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
        *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
             *(undefined1 *)(in_EAX + 0x16b1);
        iVar2 = *(int *)(in_EAX + 0x16b4);
        *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
        *(int *)(in_EAX + 0x16b4) = iVar2 + -0xd;
        *(ushort *)(in_EAX + 0x16b0) = (ushort)iVar1 >> (0x10U - (char)iVar2 & 0x1f);
      }
      FUN_0070e5c0(&DAT_00bfdb48,&DAT_00bfdfc8);
    }
    else {
      iVar1 = unaff_EDI + 4;
      if (iVar2 < 0xe) {
        *(ushort *)(in_EAX + 0x16b0) =
             *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar1 << (bVar3 & 0x1f));
        *(int *)(in_EAX + 0x16b4) = iVar2 + 3;
      }
      else {
        *(ushort *)(in_EAX + 0x16b0) =
             *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar1 << (bVar3 & 0x1f));
        *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
             *(undefined1 *)(in_EAX + 0x16b0);
        *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
        *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
             *(undefined1 *)(in_EAX + 0x16b1);
        iVar2 = *(int *)(in_EAX + 0x16b4);
        *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
        *(int *)(in_EAX + 0x16b4) = iVar2 + -0xd;
        *(ushort *)(in_EAX + 0x16b0) = (ushort)iVar1 >> (0x10U - (char)iVar2 & 0x1f);
      }
      FUN_0070f760(*(int *)(in_EAX + 0xb14) + 1,*(int *)(in_EAX + 0xb20) + 1,param_2 + 1);
      FUN_0070e5c0(in_EAX + 0x8c,in_EAX + 0x980);
    }
  }
  else {
    FUN_0070f6c0(param_1,iVar2);
  }
  FUN_0070f5b0();
  if (unaff_EDI == 0) {
    return;
  }
  FUN_0070e3f0();
  return;
}



============================================================
DISASSEMBLY
============================================================
0070fce0 : PUSH EBP
0070fce1 : MOV EBP,ESP
0070fce3 : PUSH EBX
0070fce4 : MOV EBX,dword ptr [EBP + 0xc]
0070fce7 : PUSH ESI
0070fce8 : MOV ESI,EAX
0070fcea : CMP dword ptr [ESI + 0x7c],0x0
0070fcee : MOV dword ptr [EBP + 0xc],0x0
0070fcf5 : JLE 0x0070fd45
0070fcf7 : CMP byte ptr [ESI + 0x1c],0x2
0070fcfb : JNZ 0x0070fd02
0070fcfd : CALL 0x0070e4f0
0070fd02 : LEA EAX,[ESI + 0xb10]
0070fd08 : PUSH EAX
0070fd09 : CALL 0x0070f9b0
0070fd0e : LEA ECX,[ESI + 0xb1c]
0070fd14 : PUSH ECX
0070fd15 : CALL 0x0070f9b0
0070fd1a : ADD ESP,0x8
0070fd1d : MOV EAX,ESI
0070fd1f : CALL 0x0070fc10
0070fd24 : MOV EDX,dword ptr [ESI + 0x16a0]
0070fd2a : MOV ECX,dword ptr [ESI + 0x16a4]
0070fd30 : ADD EDX,0xa
0070fd33 : ADD ECX,0xa
0070fd36 : SHR EDX,0x3
0070fd39 : SHR ECX,0x3
0070fd3c : MOV dword ptr [EBP + 0xc],EAX
0070fd3f : CMP ECX,EDX
0070fd41 : JA 0x0070fd4a
0070fd43 : JMP 0x0070fd48
0070fd45 : LEA ECX,[EBX + 0x5]
0070fd48 : MOV EDX,ECX
0070fd4a : LEA EAX,[EBX + 0x4]
0070fd4d : CMP EAX,EDX
0070fd4f : JA 0x0070fd6b
0070fd51 : MOV EAX,dword ptr [EBP + 0x8]
0070fd54 : TEST EAX,EAX
0070fd56 : JZ 0x0070fd6b
0070fd58 : PUSH EBX
0070fd59 : PUSH EAX
0070fd5a : MOV ECX,EDI
0070fd5c : MOV EAX,ESI
0070fd5e : CALL 0x0070f6c0
0070fd63 : ADD ESP,0x8
0070fd66 : JMP 0x0070fe9a
0070fd6b : CMP ECX,EDX
0070fd6d : MOV ECX,dword ptr [ESI + 0x16b4]
0070fd73 : JNZ 0x0070fdfc
0070fd79 : CMP ECX,0xd
0070fd7c : LEA EAX,[EDI + 0x2]
0070fd7f : JLE 0x0070fdd1
0070fd81 : MOV EDX,EAX
0070fd83 : SHL EDX,CL
0070fd85 : MOV ECX,dword ptr [ESI + 0x8]
0070fd88 : OR word ptr [ESI + 0x16b0],DX
0070fd8f : MOVZX EBX,byte ptr [ESI + 0x16b0]
0070fd96 : MOV EDX,dword ptr [ESI + 0x14]
0070fd99 : MOV byte ptr [ECX + EDX*0x1],BL
0070fd9c : INC dword ptr [ESI + 0x14]
0070fd9f : MOVZX EBX,byte ptr [ESI + 0x16b1]
0070fda6 : MOV ECX,dword ptr [ESI + 0x14]
0070fda9 : MOV EDX,dword ptr [ESI + 0x8]
0070fdac : MOV byte ptr [ECX + EDX*0x1],BL
0070fdaf : MOV EDX,dword ptr [ESI + 0x16b4]
0070fdb5 : INC dword ptr [ESI + 0x14]
0070fdb8 : MOV CL,0x10
0070fdba : SUB CL,DL
0070fdbc : SHR AX,CL
0070fdbf : ADD EDX,-0xd
0070fdc2 : MOV dword ptr [ESI + 0x16b4],EDX
0070fdc8 : MOV word ptr [ESI + 0x16b0],AX
0070fdcf : JMP 0x0070fde3
0070fdd1 : SHL EAX,CL
0070fdd3 : OR word ptr [ESI + 0x16b0],AX
0070fdda : ADD ECX,0x3
0070fddd : MOV dword ptr [ESI + 0x16b4],ECX
0070fde3 : PUSH 0xbfdfc8
0070fde8 : PUSH 0xbfdb48
0070fded : MOV EAX,ESI
0070fdef : CALL 0x0070e5c0
0070fdf4 : ADD ESP,0x8
0070fdf7 : JMP 0x0070fe9a
0070fdfc : CMP ECX,0xd
0070fdff : LEA EDX,[EDI + 0x4]
0070fe02 : JLE 0x0070fe54
0070fe04 : MOV EAX,EDX
0070fe06 : SHL EAX,CL
0070fe08 : MOV ECX,dword ptr [ESI + 0x8]
0070fe0b : OR word ptr [ESI + 0x16b0],AX
0070fe12 : MOVZX EBX,byte ptr [ESI + 0x16b0]
0070fe19 : MOV EAX,dword ptr [ESI + 0x14]
0070fe1c : MOV byte ptr [ECX + EAX*0x1],BL
0070fe1f : INC dword ptr [ESI + 0x14]
0070fe22 : MOVZX EBX,byte ptr [ESI + 0x16b1]
0070fe29 : MOV ECX,dword ptr [ESI + 0x14]
0070fe2c : MOV EAX,dword ptr [ESI + 0x8]
0070fe2f : MOV byte ptr [ECX + EAX*0x1],BL
0070fe32 : MOV EBX,dword ptr [ESI + 0x16b4]
0070fe38 : INC dword ptr [ESI + 0x14]
0070fe3b : MOV CL,0x10
0070fe3d : SUB CL,BL
0070fe3f : SHR DX,CL
0070fe42 : ADD EBX,-0xd
0070fe45 : MOV dword ptr [ESI + 0x16b4],EBX
0070fe4b : MOV word ptr [ESI + 0x16b0],DX
0070fe52 : JMP 0x0070fe66
0070fe54 : SHL EDX,CL
0070fe56 : OR word ptr [ESI + 0x16b0],DX
0070fe5d : ADD ECX,0x3
0070fe60 : MOV dword ptr [ESI + 0x16b4],ECX
0070fe66 : MOV EAX,dword ptr [EBP + 0xc]
0070fe69 : MOV ECX,dword ptr [ESI + 0xb20]
0070fe6f : MOV EDX,dword ptr [ESI + 0xb14]
0070fe75 : INC EAX
0070fe76 : PUSH EAX
0070fe77 : INC ECX
0070fe78 : PUSH ECX
0070fe79 : INC EDX
0070fe7a : PUSH EDX
0070fe7b : MOV EAX,ESI
0070fe7d : CALL 0x0070f760
0070fe82 : LEA EAX,[ESI + 0x980]
0070fe88 : PUSH EAX
0070fe89 : LEA ECX,[ESI + 0x8c]
0070fe8f : PUSH ECX
0070fe90 : MOV EAX,ESI
0070fe92 : CALL 0x0070e5c0
0070fe97 : ADD ESP,0x14
0070fe9a : MOV EDX,ESI
0070fe9c : CALL 0x0070f5b0
0070fea1 : TEST EDI,EDI
0070fea3 : JZ 0x0070feaf
0070fea5 : MOV EAX,ESI
0070fea7 : POP ESI
0070fea8 : POP EBX
0070fea9 : POP EBP
0070feaa : JMP 0x0070e3f0
0070feaf : POP ESI
0070feb0 : POP EBX
0070feb1 : POP EBP
0070feb2 : RET
