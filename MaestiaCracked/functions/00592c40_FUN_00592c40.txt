PROGRAM  : Maestia.exe
FUNCTION : FUN_00592c40
ENTRY    : 00592c40
BODY     : [[00592c40, 00592d42]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00592c40(void)

{
  int *piVar1;
  int *piVar2;
  int iVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  int *in_ECX;
  uint uVar6;
  int unaff_EBX;
  ushort unaff_retaddr;
  
  (**(code **)(*in_ECX + 0x1c))(&DAT_00b8b8fc);
  piVar1 = (int *)(unaff_EBX + 0x14);
  iVar3 = FUN_0058c4d0(piVar1,0,*(undefined4 *)(unaff_EBX + 0x18),&stack0xfffffff8,&LAB_00589b40);
  if (iVar3 != 0) {
    piVar2 = *(int **)(*piVar1 + -4 + iVar3 * 4);
    iVar3 = iVar3 + -1;
    if ((piVar2[3] == (uint)unaff_retaddr) && (piVar2 != (int *)0x0)) {
      if ((char)piVar2[0xd] == '\0') {
        if (((int *)piVar2[4] != (int *)0x0) && (*(int *)(unaff_EBX + 0x30) == 0)) {
          puVar4 = (undefined4 *)(**(code **)(*(int *)piVar2[4] + 0x24))();
          if (puVar4 != (undefined4 *)0x0) {
            uVar6 = 0;
            if (puVar4[1] != 0) {
              puVar5 = (undefined4 *)*puVar4;
              do {
                if ((*(byte *)*puVar5 & 4) != 0) {
                  *(byte *)((int)piVar2 + 0x35) = *(byte *)((int)piVar2 + 0x35) | 2;
                  goto LAB_00592cb4;
                }
                uVar6 = uVar6 + 1;
                puVar5 = puVar5 + 1;
              } while (uVar6 < (uint)puVar4[1]);
            }
          }
        }
        piVar1 = *(int **)(*piVar1 + iVar3 * 4);
        *(int *)(*piVar1 + 4) = piVar1[1];
        *(int *)piVar1[1] = *piVar1;
        FUN_005e36b0(iVar3);
        *piVar1 = *(int *)(unaff_EBX + 0xc);
        *(int **)(unaff_EBX + 0xc) = piVar1;
        return;
      }
      *(int *)(*piVar2 + 4) = piVar2[1];
      *(int *)piVar2[1] = *piVar2;
      FUN_005e36b0(iVar3);
      *piVar2 = *(int *)(unaff_EBX + 0xc);
      *(int **)(unaff_EBX + 0xc) = piVar2;
    }
  }
LAB_00592cb4:
  if (*(int *)(unaff_EBX + 0x30) == 0) {
    iVar3 = FUN_0058ff30((uint)unaff_retaddr);
    *(byte *)(iVar3 + 0x35) = *(byte *)(iVar3 + 0x35) | 2;
    *(uint *)(iVar3 + 0xc) = (uint)unaff_retaddr;
    *(undefined1 *)(iVar3 + 0x34) = 3;
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00592c40 : PUSH ECX
00592c41 : MOV EAX,dword ptr [ECX]
00592c43 : MOV EDX,dword ptr [EAX + 0x1c]
00592c46 : PUSH EBP
00592c47 : PUSH ESI
00592c48 : PUSH EDI
00592c49 : PUSH 0xb8b8fc
00592c4e : CALL EDX
00592c50 : MOVZX EAX,word ptr [ESP + 0x14]
00592c55 : PUSH 0x589b40
00592c5a : LEA EDI,[EBX + 0x14]
00592c5d : LEA ECX,[ESP + 0x10]
00592c61 : PUSH ECX
00592c62 : MOV dword ptr [ESP + 0x14],EAX
00592c66 : MOV EAX,dword ptr [EDI + 0x4]
00592c69 : PUSH EAX
00592c6a : PUSH 0x0
00592c6c : PUSH EDI
00592c6d : CALL 0x0058c4d0
00592c72 : MOV EBP,EAX
00592c74 : ADD ESP,0x14
00592c77 : TEST EBP,EBP
00592c79 : JZ 0x00592cb4
00592c7b : MOV EDX,dword ptr [EDI]
00592c7d : MOV ESI,dword ptr [EDX + EBP*0x4 + -0x4]
00592c81 : MOV EAX,dword ptr [ESP + 0xc]
00592c85 : DEC EBP
00592c86 : CMP dword ptr [ESI + 0xc],EAX
00592c89 : JNZ 0x00592cb4
00592c8b : TEST ESI,ESI
00592c8d : JZ 0x00592cb4
00592c8f : CMP byte ptr [ESI + 0x34],0x0
00592c93 : JZ 0x00592cd7
00592c95 : MOV ECX,dword ptr [ESI]
00592c97 : MOV EDX,dword ptr [ESI + 0x4]
00592c9a : MOV dword ptr [ECX + 0x4],EDX
00592c9d : MOV ECX,dword ptr [ESI]
00592c9f : MOV EAX,dword ptr [ESI + 0x4]
00592ca2 : MOV dword ptr [EAX],ECX
00592ca4 : PUSH EBP
00592ca5 : MOV ECX,EDI
00592ca7 : CALL 0x005e36b0
00592cac : MOV EDX,dword ptr [EBX + 0xc]
00592caf : MOV dword ptr [ESI],EDX
00592cb1 : MOV dword ptr [EBX + 0xc],ESI
00592cb4 : CMP dword ptr [EBX + 0x30],0x0
00592cb8 : JNZ 0x00592cd2
00592cba : MOVZX ESI,word ptr [ESP + 0x14]
00592cbf : PUSH ESI
00592cc0 : MOV ECX,EBX
00592cc2 : CALL 0x0058ff30
00592cc7 : OR byte ptr [EAX + 0x35],0x2
00592ccb : MOV dword ptr [EAX + 0xc],ESI
00592cce : MOV byte ptr [EAX + 0x34],0x3
00592cd2 : POP EDI
00592cd3 : POP ESI
00592cd4 : POP EBP
00592cd5 : POP ECX
00592cd6 : RET
00592cd7 : MOV ECX,dword ptr [ESI + 0x10]
00592cda : TEST ECX,ECX
00592cdc : JZ 0x00592d11
00592cde : CMP dword ptr [EBX + 0x30],0x0
00592ce2 : JNZ 0x00592d11
00592ce4 : MOV EAX,dword ptr [ECX]
00592ce6 : MOV EDX,dword ptr [EAX + 0x24]
00592ce9 : CALL EDX
00592ceb : TEST EAX,EAX
00592ced : JZ 0x00592d11
00592cef : MOV EDX,dword ptr [EAX + 0x4]
00592cf2 : XOR ECX,ECX
00592cf4 : MOV dword ptr [ESP + 0xc],EDX
00592cf8 : TEST EDX,EDX
00592cfa : JBE 0x00592d11
00592cfc : MOV EAX,dword ptr [EAX]
00592cfe : MOV EDI,EDI
00592d00 : MOV EDX,dword ptr [EAX]
00592d02 : TEST byte ptr [EDX],0x4
00592d05 : JNZ 0x00592d3a
00592d07 : INC ECX
00592d08 : ADD EAX,0x4
00592d0b : CMP ECX,dword ptr [ESP + 0xc]
00592d0f : JC 0x00592d00
00592d11 : MOV EAX,dword ptr [EDI]
00592d13 : MOV ESI,dword ptr [EAX + EBP*0x4]
00592d16 : MOV ECX,dword ptr [ESI]
00592d18 : MOV EDX,dword ptr [ESI + 0x4]
00592d1b : MOV dword ptr [ECX + 0x4],EDX
00592d1e : MOV ECX,dword ptr [ESI]
00592d20 : MOV EAX,dword ptr [ESI + 0x4]
00592d23 : MOV dword ptr [EAX],ECX
00592d25 : PUSH EBP
00592d26 : MOV ECX,EDI
00592d28 : CALL 0x005e36b0
00592d2d : MOV EDX,dword ptr [EBX + 0xc]
00592d30 : MOV dword ptr [ESI],EDX
00592d32 : POP EDI
00592d33 : MOV dword ptr [EBX + 0xc],ESI
00592d36 : POP ESI
00592d37 : POP EBP
00592d38 : POP ECX
00592d39 : RET
00592d3a : OR byte ptr [ESI + 0x35],0x2
00592d3e : JMP 0x00592cb4
