PROGRAM  : Maestia.exe
FUNCTION : FUN_0068a100
ENTRY    : 0068a100
BODY     : [[0068a100, 0068a18c] [0068a190, 0068a1ed]]

============================================================
DECOMPILED C CODE
============================================================

char * FUN_0068a100(undefined4 param_1,char *param_2)

{
  char cVar1;
  char *in_EAX;
  char *pcVar2;
  char *pcVar3;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  int local_4;
  
  local_4 = 0;
  pcVar2 = in_EAX;
  do {
    cVar1 = *pcVar2;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  pcVar3 = param_2;
  do {
    cVar1 = *pcVar3;
    pcVar3 = pcVar3 + 1;
  } while (cVar1 != '\0');
  pcVar2 = (char *)FUN_00688c00(param_1,pcVar2 + (int)(pcVar3 + ((1 - (int)(param_2 + 1)) -
                                                                (int)(in_EAX + 1))),&local_4);
  if (local_4 == 0) {
    pcVar4 = _strrchr(in_EAX,0x2f);
    pcVar3 = param_2;
    if (pcVar4 == (char *)0x0) {
      *pcVar2 = '\0';
    }
    else {
      _strncpy(pcVar2,in_EAX,(size_t)(pcVar4 + (1 - (int)in_EAX)));
      pcVar2[(int)(pcVar4 + (1 - (int)in_EAX))] = '\0';
      in_EAX = pcVar4 + 1;
    }
    do {
      cVar1 = *pcVar3;
      pcVar3 = pcVar3 + 1;
    } while (cVar1 != '\0');
    uVar5 = (int)pcVar3 - (int)param_2;
    pcVar3 = pcVar2 + -1;
    do {
      pcVar4 = pcVar3 + 1;
      pcVar3 = pcVar3 + 1;
    } while (*pcVar4 != '\0');
    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
      *(undefined4 *)pcVar3 = *(undefined4 *)param_2;
      param_2 = param_2 + 4;
      pcVar3 = pcVar3 + 4;
    }
    for (uVar5 = uVar5 & 3; pcVar4 = in_EAX, uVar5 != 0; uVar5 = uVar5 - 1) {
      *pcVar3 = *param_2;
      param_2 = param_2 + 1;
      pcVar3 = pcVar3 + 1;
    }
    do {
      cVar1 = *pcVar4;
      pcVar4 = pcVar4 + 1;
    } while (cVar1 != '\0');
    uVar5 = (int)pcVar4 - (int)in_EAX;
    pcVar3 = pcVar2 + -1;
    do {
      pcVar4 = pcVar3 + 1;
      pcVar3 = pcVar3 + 1;
    } while (*pcVar4 != '\0');
    for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
      *(undefined4 *)pcVar3 = *(undefined4 *)in_EAX;
      in_EAX = in_EAX + 4;
      pcVar3 = pcVar3 + 4;
    }
    for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
      *pcVar3 = *in_EAX;
      in_EAX = in_EAX + 1;
      pcVar3 = pcVar3 + 1;
    }
    return pcVar2;
  }
  return (char *)0x0;
}



============================================================
DISASSEMBLY
============================================================
0068a100 : PUSH ECX
0068a101 : PUSH EBX
0068a102 : PUSH EBP
0068a103 : PUSH ESI
0068a104 : MOV EBX,EAX
0068a106 : MOV dword ptr [ESP + 0xc],0x0
0068a10e : LEA EDX,[EAX + 0x1]
0068a111 : MOV CL,byte ptr [EAX]
0068a113 : INC EAX
0068a114 : TEST CL,CL
0068a116 : JNZ 0x0068a111
0068a118 : SUB EAX,EDX
0068a11a : MOV EDX,EAX
0068a11c : MOV EAX,dword ptr [ESP + 0x18]
0068a120 : LEA ESI,[EAX + 0x1]
0068a123 : MOV CL,byte ptr [EAX]
0068a125 : INC EAX
0068a126 : TEST CL,CL
0068a128 : JNZ 0x0068a123
0068a12a : SUB EAX,ESI
0068a12c : LEA ECX,[ESP + 0xc]
0068a130 : PUSH ECX
0068a131 : LEA EDX,[EAX + EDX*0x1 + 0x1]
0068a135 : MOV EAX,dword ptr [ESP + 0x18]
0068a139 : PUSH EDX
0068a13a : PUSH EAX
0068a13b : CALL 0x00688c00
0068a140 : ADD ESP,0xc
0068a143 : CMP dword ptr [ESP + 0xc],0x0
0068a148 : MOV EBP,EAX
0068a14a : JZ 0x0068a153
0068a14c : POP ESI
0068a14d : POP EBP
0068a14e : XOR EAX,EAX
0068a150 : POP EBX
0068a151 : POP ECX
0068a152 : RET
0068a153 : PUSH EDI
0068a154 : PUSH 0x2f
0068a156 : PUSH EBX
0068a157 : CALL 0x0063b6d0
0068a15c : MOV EDI,EAX
0068a15e : ADD ESP,0x8
0068a161 : TEST EDI,EDI
0068a163 : JZ 0x0068a181
0068a165 : MOV ESI,EDI
0068a167 : SUB ESI,EBX
0068a169 : LEA ECX,[ESI + 0x1]
0068a16c : PUSH ECX
0068a16d : PUSH EBX
0068a16e : PUSH EBP
0068a16f : CALL 0x00636e50
0068a174 : ADD ESP,0xc
0068a177 : MOV byte ptr [ESI + EBP*0x1 + 0x1],0x0
0068a17c : LEA EBX,[EDI + 0x1]
0068a17f : JMP 0x0068a185
0068a181 : MOV byte ptr [EBP],0x0
0068a185 : MOV ECX,dword ptr [ESP + 0x1c]
0068a189 : MOV EDX,ECX
0068a18b : JMP 0x0068a190
0068a190 : MOV AL,byte ptr [ECX]
0068a192 : INC ECX
0068a193 : TEST AL,AL
0068a195 : JNZ 0x0068a190
0068a197 : SUB ECX,EDX
0068a199 : MOV EDI,EBP
0068a19b : MOV ESI,EDX
0068a19d : MOV EDX,ECX
0068a19f : DEC EDI
0068a1a0 : MOV CL,byte ptr [EDI + 0x1]
0068a1a3 : INC EDI
0068a1a4 : TEST CL,CL
0068a1a6 : JNZ 0x0068a1a0
0068a1a8 : MOV ECX,EDX
0068a1aa : SHR ECX,0x2
0068a1ad : MOVSD.REP ES:EDI,ESI
0068a1af : MOV ECX,EDX
0068a1b1 : AND ECX,0x3
0068a1b4 : MOV EAX,EBX
0068a1b6 : MOVSB.REP ES:EDI,ESI
0068a1b8 : MOV ECX,EAX
0068a1ba : LEA EBX,[EBX]
0068a1c0 : MOV DL,byte ptr [EAX]
0068a1c2 : INC EAX
0068a1c3 : TEST DL,DL
0068a1c5 : JNZ 0x0068a1c0
0068a1c7 : MOV EDI,EBP
0068a1c9 : SUB EAX,ECX
0068a1cb : MOV ESI,ECX
0068a1cd : DEC EDI
0068a1ce : MOV EDI,EDI
0068a1d0 : MOV CL,byte ptr [EDI + 0x1]
0068a1d3 : INC EDI
0068a1d4 : TEST CL,CL
0068a1d6 : JNZ 0x0068a1d0
0068a1d8 : MOV ECX,EAX
0068a1da : SHR ECX,0x2
0068a1dd : MOVSD.REP ES:EDI,ESI
0068a1df : MOV ECX,EAX
0068a1e1 : AND ECX,0x3
0068a1e4 : MOVSB.REP ES:EDI,ESI
0068a1e6 : POP EDI
0068a1e7 : POP ESI
0068a1e8 : MOV EAX,EBP
0068a1ea : POP EBP
0068a1eb : POP EBX
0068a1ec : POP ECX
0068a1ed : RET
