PROGRAM  : Maestia.exe
FUNCTION : __chsize_nolock
ENTRY    : 0065cee3
BODY     : [[0065cee3, 0065d098]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    __chsize_nolock
   
   Library: Visual Studio 2008 Release */

int __cdecl __chsize_nolock(int _FileHandle,longlong _Size)

{
  int iVar1;
  HANDLE pvVar2;
  LPVOID _Buf;
  int *piVar3;
  int iVar4;
  uint uVar5;
  ulong *puVar6;
  BOOL BVar7;
  uint uVar8;
  int unaff_EDI;
  int iVar9;
  bool bVar10;
  bool bVar11;
  ulonglong uVar12;
  longlong lVar13;
  uint in_stack_00000008;
  DWORD DVar14;
  SIZE_T dwBytes;
  uint local_14;
  uint local_10;
  
  local_14 = 0;
  local_10 = 0;
  uVar12 = __lseeki64_nolock(_FileHandle,0x100000000,unaff_EDI);
  if (uVar12 == 0xffffffffffffffff) goto LAB_0065cf6b;
  lVar13 = __lseeki64_nolock(_FileHandle,0x200000000,unaff_EDI);
  iVar4 = (int)((ulonglong)lVar13 >> 0x20);
  if (lVar13 == -1) goto LAB_0065cf6b;
  uVar8 = in_stack_00000008 - (uint)lVar13;
  uVar5 = (uint)(in_stack_00000008 < (uint)lVar13);
  iVar1 = (int)_Size - iVar4;
  iVar9 = iVar1 - uVar5;
  if ((iVar9 < 0) ||
     ((iVar9 == 0 || SBORROW4((int)_Size,iVar4) != SBORROW4(iVar1,uVar5) && (uVar8 == 0)))) {
    if ((iVar9 < 1) && (iVar9 < 0)) {
      lVar13 = __lseeki64_nolock(_FileHandle,_Size & 0xffffffff,unaff_EDI);
      if (lVar13 == -1) goto LAB_0065cf6b;
      pvVar2 = (HANDLE)__get_osfhandle(_FileHandle);
      BVar7 = SetEndOfFile(pvVar2);
      local_14 = (BVar7 != 0) - 1;
      local_10 = (int)local_14 >> 0x1f;
      if ((local_14 & local_10) == 0xffffffff) {
        piVar3 = __errno();
        *piVar3 = 0xd;
        puVar6 = ___doserrno();
        DVar14 = GetLastError();
        *puVar6 = DVar14;
        goto LAB_0065d069;
      }
    }
  }
  else {
    dwBytes = 0x1000;
    DVar14 = 8;
    pvVar2 = GetProcessHeap();
    _Buf = HeapAlloc(pvVar2,DVar14,dwBytes);
    if (_Buf == (LPVOID)0x0) {
      piVar3 = __errno();
      *piVar3 = 0xc;
      goto LAB_0065cf6b;
    }
    iVar4 = __setmode_nolock(_FileHandle,0x8000);
    while( true ) {
      uVar5 = uVar8;
      if ((-1 < iVar9) && ((0 < iVar9 || (0xfff < uVar8)))) {
        uVar5 = 0x1000;
      }
      uVar5 = __write_nolock(_FileHandle,_Buf,uVar5);
      if (uVar5 == 0xffffffff) break;
      bVar10 = uVar8 < uVar5;
      uVar8 = uVar8 - uVar5;
      bVar11 = SBORROW4(iVar9,(int)uVar5 >> 0x1f);
      iVar1 = iVar9 - ((int)uVar5 >> 0x1f);
      iVar9 = iVar1 - (uint)bVar10;
      if ((iVar9 < 0) || ((iVar9 == 0 || bVar11 != SBORROW4(iVar1,(uint)bVar10) && (uVar8 == 0))))
      goto LAB_0065cfbd;
    }
    puVar6 = ___doserrno();
    if (*puVar6 == 5) {
      piVar3 = __errno();
      *piVar3 = 0xd;
    }
    local_14 = 0xffffffff;
    local_10 = 0xffffffff;
LAB_0065cfbd:
    __setmode_nolock(_FileHandle,iVar4);
    DVar14 = 0;
    pvVar2 = GetProcessHeap();
    HeapFree(pvVar2,DVar14,_Buf);
LAB_0065d069:
    if ((local_14 & local_10) == 0xffffffff) goto LAB_0065cf6b;
  }
  lVar13 = __lseeki64_nolock(_FileHandle,uVar12 >> 0x20,unaff_EDI);
  if (lVar13 != -1) {
    return 0;
  }
LAB_0065cf6b:
  piVar3 = __errno();
  return *piVar3;
}



============================================================
DISASSEMBLY
============================================================
0065cee3 : MOV EDI,EDI
0065cee5 : PUSH EBP
0065cee6 : MOV EBP,ESP
0065cee8 : SUB ESP,0x18
0065ceeb : PUSH EBX
0065ceec : PUSH ESI
0065ceed : PUSH EDI
0065ceee : XOR EBX,EBX
0065cef0 : PUSH 0x1
0065cef2 : PUSH EBX
0065cef3 : PUSH EBX
0065cef4 : PUSH dword ptr [EBP + 0x8]
0065cef7 : MOV dword ptr [EBP + -0x10],EBX
0065cefa : MOV dword ptr [EBP + -0xc],EBX
0065cefd : CALL 0x0065c72d
0065cf02 : MOV dword ptr [EBP + -0x18],EAX
0065cf05 : AND EAX,EDX
0065cf07 : ADD ESP,0x10
0065cf0a : MOV dword ptr [EBP + -0x14],EDX
0065cf0d : CMP EAX,-0x1
0065cf10 : JZ 0x0065cf6b
0065cf12 : PUSH 0x2
0065cf14 : PUSH EBX
0065cf15 : PUSH EBX
0065cf16 : PUSH dword ptr [EBP + 0x8]
0065cf19 : CALL 0x0065c72d
0065cf1e : MOV ECX,EAX
0065cf20 : AND ECX,EDX
0065cf22 : ADD ESP,0x10
0065cf25 : CMP ECX,-0x1
0065cf28 : JZ 0x0065cf6b
0065cf2a : MOV ESI,dword ptr [EBP + 0xc]
0065cf2d : MOV EDI,dword ptr [EBP + 0x10]
0065cf30 : SUB ESI,EAX
0065cf32 : SBB EDI,EDX
0065cf34 : JS 0x0065d000
0065cf3a : JG 0x0065cf44
0065cf3c : CMP ESI,EBX
0065cf3e : JBE 0x0065d000
0065cf44 : MOV EBX,0x1000
0065cf49 : PUSH EBX
0065cf4a : PUSH 0x8
0065cf4c : CALL dword ptr [0x00b85340]
0065cf52 : PUSH EAX
0065cf53 : CALL dword ptr [0x00b852c8]
0065cf59 : MOV dword ptr [EBP + -0x4],EAX
0065cf5c : TEST EAX,EAX
0065cf5e : JNZ 0x0065cf77
0065cf60 : CALL 0x0063ab82
0065cf65 : MOV dword ptr [EAX],0xc
0065cf6b : CALL 0x0063ab82
0065cf70 : MOV EAX,dword ptr [EAX]
0065cf72 : POP EDI
0065cf73 : POP ESI
0065cf74 : POP EBX
0065cf75 : LEAVE
0065cf76 : RET
0065cf77 : PUSH 0x8000
0065cf7c : PUSH dword ptr [EBP + 0x8]
0065cf7f : CALL 0x0065d099
0065cf84 : POP ECX
0065cf85 : POP ECX
0065cf86 : MOV dword ptr [EBP + -0x8],EAX
0065cf89 : TEST EDI,EDI
0065cf8b : JL 0x0065cf97
0065cf8d : JG 0x0065cf93
0065cf8f : CMP ESI,EBX
0065cf91 : JC 0x0065cf97
0065cf93 : MOV EAX,EBX
0065cf95 : JMP 0x0065cf99
0065cf97 : MOV EAX,ESI
0065cf99 : PUSH EAX
0065cf9a : PUSH dword ptr [EBP + -0x4]
0065cf9d : PUSH dword ptr [EBP + 0x8]
0065cfa0 : CALL 0x00650626
0065cfa5 : ADD ESP,0xc
0065cfa8 : CMP EAX,-0x1
0065cfab : JZ 0x0065cfe3
0065cfad : CDQ
0065cfae : SUB ESI,EAX
0065cfb0 : SBB EDI,EDX
0065cfb2 : JS 0x0065cfba
0065cfb4 : JG 0x0065cf89
0065cfb6 : TEST ESI,ESI
0065cfb8 : JA 0x0065cf89
0065cfba : MOV ESI,dword ptr [EBP + -0x10]
0065cfbd : PUSH dword ptr [EBP + -0x8]
0065cfc0 : PUSH dword ptr [EBP + 0x8]
0065cfc3 : CALL 0x0065d099
0065cfc8 : POP ECX
0065cfc9 : POP ECX
0065cfca : PUSH dword ptr [EBP + -0x4]
0065cfcd : PUSH 0x0
0065cfcf : CALL dword ptr [0x00b85340]
0065cfd5 : PUSH EAX
0065cfd6 : CALL dword ptr [0x00b852c4]
0065cfdc : XOR EBX,EBX
0065cfde : JMP 0x0065d069
0065cfe3 : CALL 0x0063ab95
0065cfe8 : CMP dword ptr [EAX],0x5
0065cfeb : JNZ 0x0065cff8
0065cfed : CALL 0x0063ab82
0065cff2 : MOV dword ptr [EAX],0xd
0065cff8 : OR ESI,0xffffffff
0065cffb : MOV dword ptr [EBP + -0xc],ESI
0065cffe : JMP 0x0065cfbd
0065d000 : CMP EDI,EBX
0065d002 : JG 0x0065d075
0065d004 : JL 0x0065d00a
0065d006 : CMP ESI,EBX
0065d008 : JNC 0x0065d075
0065d00a : PUSH EBX
0065d00b : PUSH dword ptr [EBP + 0x10]
0065d00e : PUSH dword ptr [EBP + 0xc]
0065d011 : PUSH dword ptr [EBP + 0x8]
0065d014 : CALL 0x0065c72d
0065d019 : AND EAX,EDX
0065d01b : ADD ESP,0x10
0065d01e : CMP EAX,-0x1
0065d021 : JZ 0x0065cf6b
0065d027 : PUSH dword ptr [EBP + 0x8]
0065d02a : CALL 0x0065cc0b
0065d02f : POP ECX
0065d030 : PUSH EAX
0065d031 : CALL dword ptr [0x00b8533c]
0065d037 : NEG EAX
0065d039 : SBB EAX,EAX
0065d03b : NEG EAX
0065d03d : DEC EAX
0065d03e : CDQ
0065d03f : MOV dword ptr [EBP + -0x10],EAX
0065d042 : AND EAX,EDX
0065d044 : MOV dword ptr [EBP + -0xc],EDX
0065d047 : CMP EAX,-0x1
0065d04a : JNZ 0x0065d075
0065d04c : CALL 0x0063ab82
0065d051 : MOV dword ptr [EAX],0xd
0065d057 : CALL 0x0063ab95
0065d05c : MOV ESI,EAX
0065d05e : CALL dword ptr [0x00b85128]
0065d064 : MOV dword ptr [ESI],EAX
0065d066 : MOV ESI,dword ptr [EBP + -0x10]
0065d069 : AND ESI,dword ptr [EBP + -0xc]
0065d06c : CMP ESI,-0x1
0065d06f : JZ 0x0065cf6b
0065d075 : PUSH EBX
0065d076 : PUSH dword ptr [EBP + -0x14]
0065d079 : PUSH dword ptr [EBP + -0x18]
0065d07c : PUSH dword ptr [EBP + 0x8]
0065d07f : CALL 0x0065c72d
0065d084 : AND EAX,EDX
0065d086 : ADD ESP,0x10
0065d089 : CMP EAX,-0x1
0065d08c : JZ 0x0065cf6b
0065d092 : XOR EAX,EAX
0065d094 : JMP 0x0065cf72
