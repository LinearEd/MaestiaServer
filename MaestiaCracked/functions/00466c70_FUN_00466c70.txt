PROGRAM  : Maestia.exe
FUNCTION : FUN_00466c70
ENTRY    : 00466c70
BODY     : [[00466c70, 00467094]]

============================================================
DECOMPILED C CODE
============================================================

byte FUN_00466c70(int param_1,undefined4 param_2,short param_3)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  int *piVar4;
  bool bVar5;
  char cVar6;
  byte bVar7;
  byte bVar8;
  int in_EAX;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int *piVar14;
  int *piVar15;
  undefined4 uVar16;
  int local_20;
  int local_10;
  int local_c;
  bool local_5;
  
  bVar7 = 0;
  if ((*(int *)(param_1 + 4) == 0) || (*(int *)(param_1 + 0x10) == 0)) {
    return 1;
  }
  cVar6 = FUN_0046c730();
  if (cVar6 != '\0') {
    (**(code **)(*DAT_01720efc + 0xe4))(DAT_01720efc,0x16,1);
    param_2._3_1_ = FUN_0046c290(in_EAX + 0x319c);
    param_2._3_1_ = param_2._3_1_ & 1;
    iVar12 = *(int *)(param_1 + 4);
    bVar5 = false;
    local_10 = 0;
    if (0 < *(int *)(iVar12 + 8)) {
      do {
        iVar12 = *(int *)(*(int *)(iVar12 + 4) + local_10 * 4);
        if (((*(char *)(iVar12 + 0x1f6) != '\0') && (iVar9 = FUN_0046c9c0(local_10), iVar9 != 0)) &&
           (iVar3 = *(int *)(iVar9 + 8), iVar3 != 0)) {
          if (!bVar5) {
            bVar7 = FUN_0046ab70();
            param_2._3_1_ = param_2._3_1_ & bVar7;
            bVar5 = true;
          }
          bVar7 = FUN_0046ab90();
          param_2._3_1_ = param_2._3_1_ & bVar7;
          if (*(char *)(in_EAX + 0x7658) == '\0') {
            bVar7 = FUN_0046abe0();
            param_2._3_1_ = param_2._3_1_ & bVar7;
          }
          *(int *)(in_EAX + 0x74b8) = *(int *)(in_EAX + 0x74b8) + 1;
          FUN_0046a440();
          if (0 < iVar3) {
            iVar10 = 0;
            iVar13 = iVar3;
            do {
              if (*(char *)(*(char *)(iVar10 + 0x1e + *(int *)(iVar9 + 4)) + 1 +
                           *(int *)(iVar12 + 0xe68)) != '\0') {
                *(int *)(in_EAX + 0x74ac) = *(int *)(in_EAX + 0x74ac) + 1;
              }
              iVar10 = iVar10 + 0x20;
              iVar13 = iVar13 + -1;
            } while (iVar13 != 0);
          }
          piVar14 = *(int **)(iVar12 + 0xe7c);
          if (piVar14 != piVar14 + *(int *)(iVar12 + 0xe80)) {
            do {
              iVar13 = *piVar14;
              iVar10 = FUN_0046a050(in_EAX,iVar13 * 0x1128 + *(int *)(iVar12 + 0xda8),0);
              if (0 < iVar10) {
                param_2._3_1_ = param_2._3_1_ & 1;
                *(int *)(in_EAX + 0x74b0) = *(int *)(in_EAX + 0x74b0) + iVar10;
              }
              if (0 < iVar3) {
                local_c = 0;
                local_20 = iVar3;
                do {
                  piVar15 = (int *)(*(int *)(iVar9 + 4) + local_c);
                  if (-1 < *(char *)((int)piVar15 + 0x1e)) {
                    iVar10 = *piVar15;
                    if (param_3 == 1) {
                      if (*(char *)(iVar10 + 0x12d) == '\0') {
LAB_00466e33:
                        iVar11 = *(int *)(iVar12 + 0xe48) * iVar13 +
                                 (int)*(char *)((int)piVar15 + 0x1e);
                        iVar1 = *(int *)(iVar12 + 0xe54) + iVar11 * 0x14;
                        if (*(int *)(*(int *)(iVar12 + 0xe54) + iVar11 * 0x14) != -1) {
                          local_5 = false;
                          if (*(int *)(in_EAX + 0x32b8) != 0) {
                            piVar4 = *(int **)(*(int *)(in_EAX + 0x32c0) + 0xc);
                            iVar11 = (**(code **)(*piVar4 + 0x4c))
                                               (piVar4,DAT_01720efc,*(int *)(in_EAX + 0x32b8),iVar10
                                               );
                            local_5 = -1 < iVar11;
                          }
                          if (*(int *)(in_EAX + 0x32bc) != 0) {
                            piVar4 = *(int **)(*(int *)(in_EAX + 0x32c0) + 0x10);
                            iVar11 = (**(code **)(*piVar4 + 0x4c))
                                               (piVar4,DAT_01720efc,*(int *)(in_EAX + 0x32bc),iVar10
                                               );
                            local_5 = -1 < iVar11;
                          }
                          bVar7 = FUN_0046c3b0((float)(int)*(char *)(iVar10 + 0x21) * 0.007874016,
                                               piVar15[5],piVar15[2]);
                          bVar7 = param_2._3_1_ & bVar7 & local_5;
                          if (*(char *)(iVar10 + 300) == '\0') {
                            uVar2 = 0;
                            uVar16 = 0;
                          }
                          else {
                            uVar2 = *(undefined4 *)(iVar10 + 0x134);
                            uVar16 = *(undefined4 *)(iVar10 + 0x138);
                          }
                          bVar8 = FUN_0046c4d0(uVar2,uVar16);
                          bVar7 = bVar7 & bVar8;
                          if (*(char *)(iVar10 + 0x12d) == '\0') {
                            uVar2 = 0x3f800000;
                          }
                          else {
                            uVar2 = 0x3e99999a;
                          }
                          FUN_0046c5e0(uVar2);
                          param_2._3_1_ = bVar7;
                          if (*(char *)(in_EAX + 0x7658) == '\0') {
                            if (*(int *)(iVar1 + 8) == 0) {
                              bVar7 = 0;
                            }
                            else {
                              bVar7 = FUN_0046c640(*(undefined4 *)(iVar1 + 4),
                                                   *(undefined4 *)(iVar1 + 0xc),
                                                   *(undefined4 *)(iVar1 + 0x10));
                            }
                            param_2._3_1_ = param_2._3_1_ & bVar7;
                          }
                          else {
                            FUN_00807d70(
                                        "CGeometryBufferDirectX9::RenderArrays, PRIMITIVE_QUADS type is not supported under the DirectX9 render interface"
                                        );
                            param_2._3_1_ = 0;
                          }
                          *(int *)(in_EAX + 0x74b4) = *(int *)(in_EAX + 0x74b4) + 1;
                          *(int *)(in_EAX + 0x74bc) =
                               *(int *)(in_EAX + 0x74bc) + *(uint *)(iVar1 + 8) / 3;
                        }
                      }
                    }
                    else if ((param_3 != 2) || (*(char *)(iVar10 + 0x12d) != '\0'))
                    goto LAB_00466e33;
                  }
                  local_c = local_c + 0x20;
                  local_20 = local_20 + -1;
                } while (local_20 != 0);
              }
              piVar14 = piVar14 + 1;
            } while (piVar14 != (int *)(*(int *)(iVar12 + 0xe7c) + *(int *)(iVar12 + 0xe80) * 4));
          }
          iVar12 = (**(code **)(*DAT_01720efc + 400))(DAT_01720efc,0,0,0,0);
          param_2._3_1_ = param_2._3_1_ & iVar12 == 0;
          if (*(char *)(in_EAX + 0x7658) == '\0') {
            iVar12 = (**(code **)(*DAT_01720efc + 0x1a0))(DAT_01720efc,0);
            param_2._3_1_ = param_2._3_1_ & iVar12 == 0;
          }
        }
        iVar12 = *(int *)(param_1 + 4);
        local_10 = local_10 + 1;
      } while (local_10 < *(int *)(iVar12 + 8));
      if (bVar5) {
        param_2._3_1_ = param_2._3_1_ & 1;
      }
    }
    (**(code **)(*DAT_01720efc + 0x170))(DAT_01720efc,0);
    (**(code **)(*DAT_01720efc + 0x1ac))(DAT_01720efc,0);
    bVar7 = param_2._3_1_ & 1;
  }
  return bVar7;
}



============================================================
DISASSEMBLY
============================================================
00466c70 : PUSH EBP
00466c71 : MOV EBP,ESP
00466c73 : SUB ESP,0x30
00466c76 : PUSH EBX
00466c77 : PUSH ESI
00466c78 : MOV ESI,dword ptr [EBP + 0x8]
00466c7b : XOR BL,BL
00466c7d : CMP dword ptr [ESI + 0x4],0x0
00466c81 : PUSH EDI
00466c82 : MOV EDI,EAX
00466c84 : JZ 0x0046708a
00466c8a : CMP dword ptr [ESI + 0x10],0x0
00466c8e : JZ 0x0046708a
00466c94 : LEA EAX,[EDI + 0x1be0]
00466c9a : CALL 0x0046c730
00466c9f : TEST AL,AL
00466ca1 : JZ 0x0046707f
00466ca7 : MOV EAX,[0x01720efc]
00466cac : MOV ECX,dword ptr [EAX]
00466cae : MOV EDX,dword ptr [ECX + 0xe4]
00466cb4 : PUSH 0x1
00466cb6 : PUSH 0x16
00466cb8 : PUSH EAX
00466cb9 : CALL EDX
00466cbb : MOV EDX,dword ptr [EBP + 0xc]
00466cbe : LEA EAX,[EDI + 0x319c]
00466cc4 : ADD EDX,0x25c
00466cca : PUSH EAX
00466ccb : CALL 0x0046c290
00466cd0 : AND AL,0x1
00466cd2 : MOV byte ptr [EBP + 0xf],AL
00466cd5 : MOV EAX,dword ptr [ESI + 0x4]
00466cd8 : MOV byte ptr [EBP + -0x2],BL
00466cdb : XOR EBX,EBX
00466cdd : CMP dword ptr [EAX + 0x8],EBX
00466ce0 : MOV dword ptr [EBP + -0xc],EBX
00466ce3 : JLE 0x00467054
00466ce9 : LEA ESP,[ESP]
00466cf0 : MOV ECX,dword ptr [EAX + 0x4]
00466cf3 : MOV ESI,dword ptr [ECX + EBX*0x4]
00466cf6 : CMP byte ptr [ESI + 0x1f6],0x0
00466cfd : MOV dword ptr [EBP + -0x20],ESI
00466d00 : JZ 0x00467037
00466d06 : MOV EAX,dword ptr [EBP + 0x8]
00466d09 : PUSH EBX
00466d0a : CALL 0x0046c9c0
00466d0f : MOV dword ptr [EBP + -0x14],EAX
00466d12 : TEST EAX,EAX
00466d14 : JZ 0x00467037
00466d1a : MOV EAX,dword ptr [EAX + 0x8]
00466d1d : MOV dword ptr [EBP + -0x10],EAX
00466d20 : TEST EAX,EAX
00466d22 : JZ 0x00467037
00466d28 : CMP byte ptr [EBP + -0x2],0x0
00466d2c : LEA EBX,[ESI + 0xfa8]
00466d32 : JNZ 0x00466d42
00466d34 : MOV EDX,EBX
00466d36 : CALL 0x0046ab70
00466d3b : AND byte ptr [EBP + 0xf],AL
00466d3e : MOV byte ptr [EBP + -0x2],0x1
00466d42 : MOV ECX,EBX
00466d44 : CALL 0x0046ab90
00466d49 : AND byte ptr [EBP + 0xf],AL
00466d4c : CMP byte ptr [EDI + 0x7658],0x0
00466d53 : JNZ 0x00466d5f
00466d55 : MOV EDX,EBX
00466d57 : CALL 0x0046abe0
00466d5c : AND byte ptr [EBP + 0xf],AL
00466d5f : INC dword ptr [EDI + 0x74b8]
00466d65 : CALL 0x0046a440
00466d6a : MOV ECX,dword ptr [EBP + -0x10]
00466d6d : TEST ECX,ECX
00466d6f : JLE 0x00466d99
00466d71 : XOR EAX,EAX
00466d73 : MOV EDX,dword ptr [EBP + -0x14]
00466d76 : MOV EDX,dword ptr [EDX + 0x4]
00466d79 : MOVSX EDX,byte ptr [EAX + EDX*0x1 + 0x1e]
00466d7e : MOV EBX,dword ptr [ESI + 0xe68]
00466d84 : CMP byte ptr [EDX + EBX*0x1 + 0x1],0x0
00466d89 : JZ 0x00466d91
00466d8b : INC dword ptr [EDI + 0x74ac]
00466d91 : ADD EAX,0x20
00466d94 : SUB ECX,0x1
00466d97 : JNZ 0x00466d73
00466d99 : MOV EBX,dword ptr [ESI + 0xe7c]
00466d9f : MOV EAX,dword ptr [ESI + 0xe80]
00466da5 : LEA ECX,[EBX + EAX*0x4]
00466da8 : MOV dword ptr [EBP + -0x24],EBX
00466dab : CMP EBX,ECX
00466dad : JZ 0x00466ff1
00466db3 : MOV EAX,dword ptr [EBX]
00466db5 : MOV dword ptr [EBP + -0x28],EAX
00466db8 : IMUL EAX,EAX,0x1128
00466dbe : ADD EAX,dword ptr [ESI + 0xda8]
00466dc4 : PUSH 0x0
00466dc6 : PUSH EAX
00466dc7 : PUSH EDI
00466dc8 : CALL 0x0046a050
00466dcd : TEST EAX,EAX
00466dcf : JLE 0x00466ddb
00466dd1 : AND byte ptr [EBP + 0xf],0x1
00466dd5 : ADD dword ptr [EDI + 0x74b0],EAX
00466ddb : MOV EAX,dword ptr [EBP + -0x10]
00466dde : TEST EAX,EAX
00466de0 : JLE 0x00466fd4
00466de6 : MOV dword ptr [EBP + -0x8],0x0
00466ded : MOV dword ptr [EBP + -0x1c],EAX
00466df0 : MOV EDX,dword ptr [EBP + -0x14]
00466df3 : MOV EBX,dword ptr [EDX + 0x4]
00466df6 : ADD EBX,dword ptr [EBP + -0x8]
00466df9 : MOV CL,byte ptr [EBX + 0x1e]
00466dfc : CMP CL,0xff
00466dff : JLE 0x00466fc0
00466e05 : MOV AX,word ptr [EBP + 0x10]
00466e09 : MOV ESI,dword ptr [EBX]
00466e0b : CMP AX,0x1
00466e0f : JNZ 0x00466e20
00466e11 : CMP byte ptr [ESI + 0x12d],0x0
00466e18 : JNZ 0x00466fc0
00466e1e : JMP 0x00466e33
00466e20 : CMP AX,0x2
00466e24 : JNZ 0x00466e33
00466e26 : CMP byte ptr [ESI + 0x12d],0x0
00466e2d : JZ 0x00466fc0
00466e33 : MOV EDX,dword ptr [EBP + -0x20]
00466e36 : MOV EAX,dword ptr [EDX + 0xe48]
00466e3c : IMUL EAX,dword ptr [EBP + -0x28]
00466e40 : MOVSX ECX,CL
00466e43 : ADD EAX,ECX
00466e45 : MOV ECX,dword ptr [EDX + 0xe54]
00466e4b : LEA EAX,[EAX + EAX*0x4]
00466e4e : CMP dword ptr [ECX + EAX*0x4],-0x1
00466e52 : LEA EAX,[ECX + EAX*0x4]
00466e55 : MOV dword ptr [EBP + -0x18],EAX
00466e58 : JZ 0x00466fc0
00466e5e : MOV ECX,dword ptr [EDI + 0x32b8]
00466e64 : MOV byte ptr [EBP + -0x1],0x0
00466e68 : TEST ECX,ECX
00466e6a : JZ 0x00466e8c
00466e6c : MOV EDX,dword ptr [EDI + 0x32c0]
00466e72 : MOV EAX,dword ptr [EDX + 0xc]
00466e75 : MOV EDX,dword ptr [EAX]
00466e77 : MOV EDX,dword ptr [EDX + 0x4c]
00466e7a : PUSH ESI
00466e7b : PUSH ECX
00466e7c : MOV ECX,dword ptr [0x01720efc]
00466e82 : PUSH ECX
00466e83 : PUSH EAX
00466e84 : CALL EDX
00466e86 : TEST EAX,EAX
00466e88 : SETGE byte ptr [EBP + -0x1]
00466e8c : MOV ECX,dword ptr [EDI + 0x32bc]
00466e92 : TEST ECX,ECX
00466e94 : JZ 0x00466eb6
00466e96 : MOV EAX,dword ptr [EDI + 0x32c0]
00466e9c : MOV EAX,dword ptr [EAX + 0x10]
00466e9f : MOV EDX,dword ptr [EAX]
00466ea1 : MOV EDX,dword ptr [EDX + 0x4c]
00466ea4 : PUSH ESI
00466ea5 : PUSH ECX
00466ea6 : MOV ECX,dword ptr [0x01720efc]
00466eac : PUSH ECX
00466ead : PUSH EAX
00466eae : CALL EDX
00466eb0 : TEST EAX,EAX
00466eb2 : SETGE byte ptr [EBP + -0x1]
00466eb6 : MOVSX ECX,byte ptr [ESI + 0x21]
00466eba : MOVSX EAX,byte ptr [ESI + 0x20]
00466ebe : MOV dword ptr [EBP + -0x2c],ECX
00466ec1 : SUB ESP,0xc
00466ec4 : CVTSI2SS XMM0,EAX
00466ec8 : FILD dword ptr [EBP + -0x2c]
00466ecb : MULSS XMM0,dword ptr [0x00cdf310]
00466ed3 : LEA EAX,[EDI + 0x33cc]
00466ed9 : FMUL float ptr [0x00cdf310]
00466edf : FLD float ptr [EBX + 0x14]
00466ee2 : FLD float ptr [EBX + 0x8]
00466ee5 : FSTP float ptr [ESP + 0x8]
00466ee9 : FSTP float ptr [ESP + 0x4]
00466eed : FSTP float ptr [ESP]
00466ef0 : CALL 0x0046c3b0
00466ef5 : AND AL,byte ptr [EBP + -0x1]
00466ef8 : MOV BL,byte ptr [EBP + 0xf]
00466efb : AND BL,AL
00466efd : SUB ESP,0x8
00466f00 : CMP byte ptr [ESI + 0x12c],0x0
00466f07 : LEA EAX,[EDI + 0x6778]
00466f0d : JZ 0x00466f29
00466f0f : FLD float ptr [ESI + 0x134]
00466f15 : MOVSS XMM0,dword ptr [ESI + 0x130]
00466f1d : FLD float ptr [ESI + 0x138]
00466f23 : FSTP float ptr [ESP + 0x4]
00466f27 : JMP 0x00466f32
00466f29 : FLDZ
00466f2b : XORPS XMM0,XMM0
00466f2e : FST float ptr [ESP + 0x4]
00466f32 : FSTP float ptr [ESP]
00466f35 : CALL 0x0046c4d0
00466f3a : AND BL,AL
00466f3c : CMP byte ptr [ESI + 0x12d],0x0
00466f43 : PUSH ECX
00466f44 : LEA ESI,[EDI + 0x6890]
00466f4a : JZ 0x00466f54
00466f4c : FLD float ptr [0x00cdf0e8]
00466f52 : JMP 0x00466f56
00466f54 : FLD1
00466f56 : FSTP float ptr [ESP]
00466f59 : CALL 0x0046c5e0
00466f5e : AND BL,0x1
00466f61 : CMP byte ptr [EDI + 0x7658],0x0
00466f68 : MOV byte ptr [EBP + 0xf],BL
00466f6b : JZ 0x00466f83
00466f6d : PUSH 0xcd5e78
00466f72 : CALL 0x00807d70
00466f77 : MOV ESI,dword ptr [EBP + -0x18]
00466f7a : ADD ESP,0x4
00466f7d : MOV byte ptr [EBP + 0xf],0x0
00466f81 : JMP 0x00466faa
00466f83 : MOV ESI,dword ptr [EBP + -0x18]
00466f86 : MOV ECX,dword ptr [ESI + 0x8]
00466f89 : MOV EAX,dword ptr [ESI + 0x10]
00466f8c : MOV EDX,dword ptr [ESI + 0xc]
00466f8f : MOV EBX,dword ptr [ESI + 0x4]
00466f92 : TEST ECX,ECX
00466f94 : JBE 0x00466fa5
00466f96 : PUSH EAX
00466f97 : PUSH EDX
00466f98 : PUSH EBX
00466f99 : MOV EAX,0x6
00466f9e : CALL 0x0046c640
00466fa3 : JMP 0x00466fa7
00466fa5 : XOR AL,AL
00466fa7 : AND byte ptr [EBP + 0xf],AL
00466faa : INC dword ptr [EDI + 0x74b4]
00466fb0 : MOV EAX,0xaaaaaaab
00466fb5 : MUL dword ptr [ESI + 0x8]
00466fb8 : SHR EDX,0x1
00466fba : ADD dword ptr [EDI + 0x74bc],EDX
00466fc0 : ADD dword ptr [EBP + -0x8],0x20
00466fc4 : SUB dword ptr [EBP + -0x1c],0x1
00466fc8 : JNZ 0x00466df0
00466fce : MOV ESI,dword ptr [EBP + -0x20]
00466fd1 : MOV EBX,dword ptr [EBP + -0x24]
00466fd4 : MOV EDX,dword ptr [ESI + 0xe80]
00466fda : MOV EAX,dword ptr [ESI + 0xe7c]
00466fe0 : ADD EBX,0x4
00466fe3 : LEA ECX,[EAX + EDX*0x4]
00466fe6 : MOV dword ptr [EBP + -0x24],EBX
00466fe9 : CMP EBX,ECX
00466feb : JNZ 0x00466db3
00466ff1 : MOV EAX,[0x01720efc]
00466ff6 : MOV EDX,dword ptr [EAX]
00466ff8 : PUSH 0x0
00466ffa : PUSH 0x0
00466ffc : PUSH 0x0
00466ffe : PUSH 0x0
00467000 : PUSH EAX
00467001 : MOV EAX,dword ptr [EDX + 0x190]
00467007 : CALL EAX
00467009 : TEST EAX,EAX
0046700b : SETZ CL
0046700e : AND byte ptr [EBP + 0xf],CL
00467011 : CMP byte ptr [EDI + 0x7658],0x0
00467018 : JNZ 0x00467034
0046701a : MOV EAX,[0x01720efc]
0046701f : MOV EDX,dword ptr [EAX]
00467021 : PUSH 0x0
00467023 : PUSH EAX
00467024 : MOV EAX,dword ptr [EDX + 0x1a0]
0046702a : CALL EAX
0046702c : TEST EAX,EAX
0046702e : SETZ CL
00467031 : AND byte ptr [EBP + 0xf],CL
00467034 : MOV EBX,dword ptr [EBP + -0xc]
00467037 : MOV EDX,dword ptr [EBP + 0x8]
0046703a : MOV EAX,dword ptr [EDX + 0x4]
0046703d : INC EBX
0046703e : CMP EBX,dword ptr [EAX + 0x8]
00467041 : MOV dword ptr [EBP + -0xc],EBX
00467044 : JL 0x00466cf0
0046704a : CMP byte ptr [EBP + -0x2],0x0
0046704e : JZ 0x00467054
00467050 : AND byte ptr [EBP + 0xf],0x1
00467054 : MOV EAX,[0x01720efc]
00467059 : MOV ECX,dword ptr [EAX]
0046705b : MOV EDX,dword ptr [ECX + 0x170]
00467061 : PUSH 0x0
00467063 : PUSH EAX
00467064 : CALL EDX
00467066 : MOV EAX,[0x01720efc]
0046706b : MOV ECX,dword ptr [EAX]
0046706d : MOV EDX,dword ptr [ECX + 0x1ac]
00467073 : PUSH 0x0
00467075 : PUSH EAX
00467076 : CALL EDX
00467078 : AND byte ptr [EBP + 0xf],0x1
0046707c : MOV BL,byte ptr [EBP + 0xf]
0046707f : MOV AL,BL
00467081 : POP EDI
00467082 : POP ESI
00467083 : POP EBX
00467084 : MOV ESP,EBP
00467086 : POP EBP
00467087 : RET 0xc
0046708a : POP EDI
0046708b : POP ESI
0046708c : MOV AL,0x1
0046708e : POP EBX
0046708f : MOV ESP,EBP
00467091 : POP EBP
00467092 : RET 0xc
