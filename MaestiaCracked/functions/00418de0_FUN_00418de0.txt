PROGRAM  : Maestia.exe
FUNCTION : FUN_00418de0
ENTRY    : 00418de0
BODY     : [[00418de0, 00418edf]]

============================================================
DECOMPILED C CODE
============================================================

uint FUN_00418de0(int *param_1)

{
  ushort uVar1;
  uint in_EAX;
  int iVar2;
  ushort *puVar3;
  ushort *puVar4;
  int in_EDX;
  bool bVar5;
  
  iVar2 = *param_1;
  if (iVar2 == 1) {
    return (uint)(*(ushort *)(in_EAX + 2) < *(ushort *)(in_EDX + 2));
  }
  if (iVar2 == 2) {
    return (uint)(*(ushort *)(in_EDX + 2) < *(ushort *)(in_EAX + 2));
  }
  if (iVar2 != 3) {
    if (iVar2 != 4) {
      return in_EAX & 0xffffff00;
    }
    if (*(uint *)(in_EAX + 0x1c) < 8) {
      puVar4 = (ushort *)(in_EAX + 8);
    }
    else {
      puVar4 = *(ushort **)(in_EAX + 8);
    }
    if (*(uint *)(in_EDX + 0x1c) < 8) {
      puVar3 = (ushort *)(in_EDX + 8);
    }
    else {
      puVar3 = *(ushort **)(in_EDX + 8);
    }
    while( true ) {
      uVar1 = *puVar3;
      bVar5 = uVar1 < *puVar4;
      if (uVar1 != *puVar4) break;
      if (uVar1 == 0) {
        return 0;
      }
      uVar1 = puVar3[1];
      bVar5 = uVar1 < puVar4[1];
      if (uVar1 != puVar4[1]) break;
      puVar3 = puVar3 + 2;
      puVar4 = puVar4 + 2;
      if (uVar1 == 0) {
        return 0;
      }
    }
    iVar2 = (1 - (uint)bVar5) - (uint)(bVar5 != 0);
    return CONCAT31((int3)((uint)iVar2 >> 8),0 < iVar2);
  }
  if (*(uint *)(in_EAX + 0x1c) < 8) {
    puVar4 = (ushort *)(in_EAX + 8);
  }
  else {
    puVar4 = *(ushort **)(in_EAX + 8);
  }
  if (*(uint *)(in_EDX + 0x1c) < 8) {
    puVar3 = (ushort *)(in_EDX + 8);
  }
  else {
    puVar3 = *(ushort **)(in_EDX + 8);
  }
  while( true ) {
    uVar1 = *puVar3;
    bVar5 = uVar1 < *puVar4;
    if (uVar1 != *puVar4) break;
    if (uVar1 == 0) {
      return 0;
    }
    uVar1 = puVar3[1];
    bVar5 = uVar1 < puVar4[1];
    if (uVar1 != puVar4[1]) break;
    puVar3 = puVar3 + 2;
    puVar4 = puVar4 + 2;
    if (uVar1 == 0) {
      return 0;
    }
  }
  iVar2 = (1 - (uint)bVar5) - (uint)(bVar5 != 0);
  return CONCAT31((int3)((uint)iVar2 >> 8),iVar2 < 0);
}



============================================================
DISASSEMBLY
============================================================
00418de0 : PUSH EBP
00418de1 : MOV EBP,ESP
00418de3 : MOV ECX,dword ptr [EBP + 0x8]
00418de6 : MOV ECX,dword ptr [ECX]
00418de8 : CMP ECX,0x1
00418deb : JNZ 0x00418dfd
00418ded : MOV DX,word ptr [EDX + 0x2]
00418df1 : CMP word ptr [EAX + 0x2],DX
00418df5 : SBB EAX,EAX
00418df7 : NEG EAX
00418df9 : POP EBP
00418dfa : RET 0x4
00418dfd : CMP ECX,0x2
00418e00 : JNZ 0x00418e12
00418e02 : MOV CX,word ptr [EDX + 0x2]
00418e06 : CMP CX,word ptr [EAX + 0x2]
00418e0a : SBB EAX,EAX
00418e0c : NEG EAX
00418e0e : POP EBP
00418e0f : RET 0x4
00418e12 : CMP ECX,0x3
00418e15 : JNZ 0x00418e76
00418e17 : CMP dword ptr [EAX + 0x1c],0x8
00418e1b : JC 0x00418e22
00418e1d : MOV ECX,dword ptr [EAX + 0x8]
00418e20 : JMP 0x00418e25
00418e22 : LEA ECX,[EAX + 0x8]
00418e25 : CMP dword ptr [EDX + 0x1c],0x8
00418e29 : JC 0x00418e30
00418e2b : MOV EAX,dword ptr [EDX + 0x8]
00418e2e : JMP 0x00418e33
00418e30 : LEA EAX,[EDX + 0x8]
00418e33 : MOV DX,word ptr [EAX]
00418e36 : CMP DX,word ptr [ECX]
00418e39 : JNZ 0x00418e64
00418e3b : TEST DX,DX
00418e3e : JZ 0x00418e55
00418e40 : MOV DX,word ptr [EAX + 0x2]
00418e44 : CMP DX,word ptr [ECX + 0x2]
00418e48 : JNZ 0x00418e64
00418e4a : ADD EAX,0x4
00418e4d : ADD ECX,0x4
00418e50 : TEST DX,DX
00418e53 : JNZ 0x00418e33
00418e55 : XOR EAX,EAX
00418e57 : XOR EDX,EDX
00418e59 : TEST EAX,EAX
00418e5b : SETL DL
00418e5e : MOV AL,DL
00418e60 : POP EBP
00418e61 : RET 0x4
00418e64 : SBB EAX,EAX
00418e66 : SBB EAX,-0x1
00418e69 : XOR EDX,EDX
00418e6b : TEST EAX,EAX
00418e6d : SETL DL
00418e70 : MOV AL,DL
00418e72 : POP EBP
00418e73 : RET 0x4
00418e76 : CMP ECX,0x4
00418e79 : JNZ 0x00418eda
00418e7b : CMP dword ptr [EAX + 0x1c],0x8
00418e7f : JC 0x00418e86
00418e81 : MOV ECX,dword ptr [EAX + 0x8]
00418e84 : JMP 0x00418e89
00418e86 : LEA ECX,[EAX + 0x8]
00418e89 : CMP dword ptr [EDX + 0x1c],0x8
00418e8d : JC 0x00418e94
00418e8f : MOV EAX,dword ptr [EDX + 0x8]
00418e92 : JMP 0x00418e97
00418e94 : LEA EAX,[EDX + 0x8]
00418e97 : MOV DX,word ptr [EAX]
00418e9a : CMP DX,word ptr [ECX]
00418e9d : JNZ 0x00418ec8
00418e9f : TEST DX,DX
00418ea2 : JZ 0x00418eb9
00418ea4 : MOV DX,word ptr [EAX + 0x2]
00418ea8 : CMP DX,word ptr [ECX + 0x2]
00418eac : JNZ 0x00418ec8
00418eae : ADD EAX,0x4
00418eb1 : ADD ECX,0x4
00418eb4 : TEST DX,DX
00418eb7 : JNZ 0x00418e97
00418eb9 : XOR EAX,EAX
00418ebb : XOR ECX,ECX
00418ebd : TEST EAX,EAX
00418ebf : SETG CL
00418ec2 : MOV AL,CL
00418ec4 : POP EBP
00418ec5 : RET 0x4
00418ec8 : SBB EAX,EAX
00418eca : SBB EAX,-0x1
00418ecd : XOR ECX,ECX
00418ecf : TEST EAX,EAX
00418ed1 : SETG CL
00418ed4 : MOV AL,CL
00418ed6 : POP EBP
00418ed7 : RET 0x4
00418eda : XOR AL,AL
00418edc : POP EBP
00418edd : RET 0x4
