PROGRAM  : Maestia.exe
FUNCTION : FUN_00962300
ENTRY    : 00962300
BODY     : [[00962300, 00962458]]

============================================================
DECOMPILED C CODE
============================================================

undefined4 FUN_00962300(int param_1,uint param_2,uint param_3)

{
  uint uVar1;
  int *in_EAX;
  int iVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint local_8;
  
  local_8 = 0;
  uVar5 = 0xff;
  iVar2 = (**(code **)(*in_EAX + 0x20))();
  iVar3 = DAT_00d7c54c;
  if (iVar2 == 0) {
    if (((char)param_1 != '\0') &&
       (uVar5 = *(uint *)(*(int *)(DAT_0172491c + 0x17c) + 0xa0), uVar5 < param_3)) {
      param_3 = uVar5;
    }
    param_1 = in_EAX[4];
    FUN_004437f0(&param_1);
    if (local_8 == *(uint *)(iVar3 + 0x44)) {
      uVar6 = (uint)bRam00000040;
    }
    else {
      uVar6 = (uint)*(byte *)(*(int *)(local_8 + 0x10) + 0x40);
    }
  }
  else {
    iVar3 = (**(code **)(*in_EAX + 0x20))();
    uVar6 = 0;
    if (iVar3 == 1) {
      if (((char)param_1 != '\0') &&
         (uVar6 = *(uint *)(*(int *)(DAT_0172491c + 0x17c) + 0xa0), uVar6 < param_3)) {
        param_3 = uVar6;
      }
      iVar3 = in_EAX[4];
      FUN_009efbb0(&local_8);
      iVar3 = FUN_004049b0(iVar3);
      if (iVar3 == 0) {
        uVar4 = 0;
      }
      else {
        uVar4 = (uint)*(byte *)(iVar3 + 0x40);
        uVar5 = (uint)*(byte *)(iVar3 + 0x41);
      }
      if (local_8 == 0) {
        iVar3 = *(int *)(DAT_0172491c + 0x17c);
        iVar2 = FUN_004049b0(*(undefined4 *)(iVar3 + 0x16d8));
        if (iVar2 == 0) {
          return 0;
        }
        if (param_2 != 1) {
          return 0;
        }
        if (param_3 == *(uint *)(iVar2 + 0x1c0)) {
          return 1;
        }
        if (param_3 == *(uint *)(iVar3 + 0xa0)) {
          return 1;
        }
        return 0;
      }
      uVar6 = local_8;
      if ((uVar5 < 0xff) && ((char)param_1 != '\0')) {
        uVar1 = *(uint *)(*(int *)(DAT_0172491c + 0x17c) + 0xa0);
        if (uVar1 < uVar4) {
          return 0;
        }
        if (uVar5 < uVar1) {
          return 0;
        }
      }
    }
  }
  if ((param_2 <= uVar6) && (uVar6 <= param_3)) {
    return 1;
  }
  return 0;
}



============================================================
DISASSEMBLY
============================================================
00962300 : PUSH EBP
00962301 : MOV EBP,ESP
00962303 : SUB ESP,0x8
00962306 : PUSH EBX
00962307 : PUSH ESI
00962308 : MOV ESI,EAX
0096230a : MOV EAX,dword ptr [ESI]
0096230c : MOV EDX,dword ptr [EAX + 0x20]
0096230f : PUSH EDI
00962310 : XOR EDI,EDI
00962312 : MOV ECX,ESI
00962314 : MOV dword ptr [EBP + -0x4],EDI
00962317 : MOV EBX,0xff
0096231c : CALL EDX
0096231e : TEST EAX,EAX
00962320 : JNZ 0x0096237a
00962322 : CMP byte ptr [EBP + 0x8],AL
00962325 : JZ 0x00962340
00962327 : MOV EAX,[0x0172491c]
0096232c : MOV ECX,dword ptr [EAX + 0x17c]
00962332 : MOV EAX,dword ptr [ECX + 0xa0]
00962338 : CMP dword ptr [EBP + 0x10],EAX
0096233b : JBE 0x00962340
0096233d : MOV dword ptr [EBP + 0x10],EAX
00962340 : MOV EDX,dword ptr [ESI + 0x10]
00962343 : MOV ESI,dword ptr [0x00d7c54c]
00962349 : LEA EAX,[EBP + 0x8]
0096234c : PUSH EAX
0096234d : LEA ECX,[ESI + 0x40]
00962350 : LEA EAX,[EBP + -0x4]
00962353 : MOV dword ptr [EBP + 0x8],EDX
00962356 : CALL 0x004437f0
0096235b : MOV EAX,dword ptr [EBP + -0x4]
0096235e : CMP EAX,dword ptr [ESI + 0x44]
00962361 : JZ 0x0096236f
00962363 : MOV EAX,dword ptr [EAX + 0x10]
00962366 : MOVZX EDI,byte ptr [EAX + 0x40]
0096236a : JMP 0x00962444
0096236f : XOR EAX,EAX
00962371 : MOVZX EDI,byte ptr [EAX + 0x40]
00962375 : JMP 0x00962444
0096237a : MOV EDX,dword ptr [ESI]
0096237c : MOV EAX,dword ptr [EDX + 0x20]
0096237f : MOV ECX,ESI
00962381 : CALL EAX
00962383 : CMP EAX,0x1
00962386 : JNZ 0x00962444
0096238c : CMP byte ptr [EBP + 0x8],0x0
00962390 : JZ 0x009623ac
00962392 : MOV ECX,dword ptr [0x0172491c]
00962398 : MOV EDX,dword ptr [ECX + 0x17c]
0096239e : MOV EAX,dword ptr [EDX + 0xa0]
009623a4 : CMP dword ptr [EBP + 0x10],EAX
009623a7 : JBE 0x009623ac
009623a9 : MOV dword ptr [EBP + 0x10],EAX
009623ac : MOV ESI,dword ptr [ESI + 0x10]
009623af : LEA EAX,[EBP + -0x4]
009623b2 : PUSH EAX
009623b3 : MOV EAX,ESI
009623b5 : CALL 0x009efbb0
009623ba : PUSH ESI
009623bb : CALL 0x004049b0
009623c0 : ADD ESP,0x8
009623c3 : TEST EAX,EAX
009623c5 : JZ 0x009623d1
009623c7 : MOVZX ECX,byte ptr [EAX + 0x40]
009623cb : MOVZX EBX,byte ptr [EAX + 0x41]
009623cf : JMP 0x009623d3
009623d1 : MOV ECX,EDI
009623d3 : MOV EDI,dword ptr [EBP + -0x4]
009623d6 : TEST EDI,EDI
009623d8 : JNZ 0x0096241d
009623da : MOV ECX,dword ptr [0x0172491c]
009623e0 : MOV ESI,dword ptr [ECX + 0x17c]
009623e6 : MOV EDX,dword ptr [ESI + 0x16d8]
009623ec : PUSH EDX
009623ed : CALL 0x004049b0
009623f2 : ADD ESP,0x4
009623f5 : TEST EAX,EAX
009623f7 : JZ 0x00962412
009623f9 : CMP dword ptr [EBP + 0xc],0x1
009623fd : JNZ 0x00962412
009623ff : MOV ECX,dword ptr [EBP + 0x10]
00962402 : CMP ECX,dword ptr [EAX + 0x1c0]
00962408 : JZ 0x0096244e
0096240a : CMP ECX,dword ptr [ESI + 0xa0]
00962410 : JZ 0x0096244e
00962412 : POP EDI
00962413 : POP ESI
00962414 : XOR AL,AL
00962416 : POP EBX
00962417 : MOV ESP,EBP
00962419 : POP EBP
0096241a : RET 0xc
0096241d : CMP EBX,0xff
00962423 : JNC 0x00962444
00962425 : CMP byte ptr [EBP + 0x8],0x0
00962429 : JZ 0x00962444
0096242b : MOV EAX,[0x0172491c]
00962430 : MOV EDX,dword ptr [EAX + 0x17c]
00962436 : MOV EAX,dword ptr [EDX + 0xa0]
0096243c : CMP EAX,ECX
0096243e : JC 0x00962412
00962440 : CMP EAX,EBX
00962442 : JA 0x00962412
00962444 : CMP dword ptr [EBP + 0xc],EDI
00962447 : JA 0x00962412
00962449 : CMP dword ptr [EBP + 0x10],EDI
0096244c : JC 0x00962412
0096244e : POP EDI
0096244f : POP ESI
00962450 : MOV AL,0x1
00962452 : POP EBX
00962453 : MOV ESP,EBP
00962455 : POP EBP
00962456 : RET 0xc
