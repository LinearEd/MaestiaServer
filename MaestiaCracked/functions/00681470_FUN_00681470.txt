PROGRAM  : Maestia.exe
FUNCTION : FUN_00681470
ENTRY    : 00681470
BODY     : [[00681470, 00681897]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00681470(byte *param_1,byte *param_2)

{
  byte bVar1;
  HIMC pHVar2;
  byte *pbVar3;
  int iVar4;
  BOOL BVar5;
  int in_ECX;
  char *pcVar6;
  byte *pbVar7;
  bool bVar8;
  uint local_8;
  DWORD local_4;
  
  pHVar2 = ImmGetContext(*(HWND *)(*(int *)(in_ECX + 0x3c) + 0x18));
  ImmGetConversionStatus(pHVar2,&local_8,&local_4);
  if (pHVar2 != (HIMC)0x0) {
    pcVar6 = "StatusWindow_OnShape";
    pbVar3 = param_1;
    do {
      bVar1 = *pbVar3;
      bVar8 = bVar1 < (byte)*pcVar6;
      if (bVar1 != *pcVar6) {
LAB_006814d0:
        iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
        goto LAB_006814d5;
      }
      if (bVar1 == 0) break;
      bVar1 = pbVar3[1];
      bVar8 = bVar1 < ((byte *)pcVar6)[1];
      if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_006814d0;
      pbVar3 = pbVar3 + 2;
      pcVar6 = (char *)((byte *)pcVar6 + 2);
    } while (bVar1 != 0);
    iVar4 = 0;
LAB_006814d5:
    if (iVar4 == 0) {
      pcVar6 = "false";
      pbVar3 = param_2;
      do {
        bVar1 = *pbVar3;
        bVar8 = bVar1 < (byte)*pcVar6;
        if (bVar1 != *pcVar6) {
LAB_00681504:
          iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
          goto LAB_00681509;
        }
        if (bVar1 == 0) break;
        bVar1 = pbVar3[1];
        bVar8 = bVar1 < ((byte *)pcVar6)[1];
        if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681504;
        pbVar3 = pbVar3 + 2;
        pcVar6 = (char *)((byte *)pcVar6 + 2);
      } while (bVar1 != 0);
      iVar4 = 0;
LAB_00681509:
      if (iVar4 == 0) {
        local_8 = local_8 & 0xfffffff7;
      }
      pbVar3 = &DAT_00cd5b98;
      do {
        bVar1 = *param_2;
        bVar8 = bVar1 < *pbVar3;
        if (bVar1 != *pbVar3) {
LAB_00681537:
          iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
          goto LAB_0068153c;
        }
        if (bVar1 == 0) break;
        bVar1 = param_2[1];
        bVar8 = bVar1 < pbVar3[1];
        if (bVar1 != pbVar3[1]) goto LAB_00681537;
        param_2 = param_2 + 2;
        pbVar3 = pbVar3 + 2;
      } while (bVar1 != 0);
      iVar4 = 0;
LAB_0068153c:
      if (iVar4 == 0) {
        local_8 = local_8 | 8;
      }
    }
    else {
      pcVar6 = "StatusWindow_OnInputMode";
      pbVar3 = param_1;
      do {
        bVar1 = *pbVar3;
        bVar8 = bVar1 < (byte)*pcVar6;
        if (bVar1 != *pcVar6) {
LAB_00681575:
          iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
          goto LAB_0068157a;
        }
        if (bVar1 == 0) break;
        bVar1 = pbVar3[1];
        bVar8 = bVar1 < ((byte *)pcVar6)[1];
        if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681575;
        pbVar3 = pbVar3 + 2;
        pcVar6 = (char *)((byte *)pcVar6 + 2);
      } while (bVar1 != 0);
      iVar4 = 0;
LAB_0068157a:
      if (iVar4 == 0) {
        pcVar6 = "false";
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_006815b0:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_006815b5;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_006815b0;
          pbVar3 = pbVar3 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_006815b5:
        if (iVar4 == 0) {
          local_8 = local_8 & 0xfffffffe;
        }
        pbVar7 = &DAT_00cd5b98;
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < *pbVar7;
          if (bVar1 != *pbVar7) {
LAB_006815e5:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_006815ea;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < pbVar7[1];
          if (bVar1 != pbVar7[1]) goto LAB_006815e5;
          pbVar3 = pbVar3 + 2;
          pbVar7 = pbVar7 + 2;
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_006815ea:
        if (iVar4 == 0) {
          local_8 = local_8 | 1;
        }
        pcVar6 = "Hiragana";
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_00681620:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_00681625;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681620;
          pbVar3 = pbVar3 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_00681625:
        if (iVar4 == 0) {
          BVar5 = ImmGetOpenStatus(pHVar2);
          if (BVar5 == 0) {
            ImmSetOpenStatus(pHVar2,1);
          }
          local_8 = local_8 & 0xfffffffd | 1;
        }
        pcVar6 = "Full-Width Katakana";
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_00681670:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_00681675;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681670;
          pbVar3 = pbVar3 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_00681675:
        if (iVar4 == 0) {
          BVar5 = ImmGetOpenStatus(pHVar2);
          if (BVar5 == 0) {
            ImmSetOpenStatus(pHVar2,1);
          }
          local_8 = local_8 | 0xb;
        }
        pcVar6 = "Full-Width Alphanumeric";
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_006816b7:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_006816bc;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_006816b7;
          pbVar3 = pbVar3 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_006816bc:
        if (iVar4 == 0) {
          BVar5 = ImmGetOpenStatus(pHVar2);
          if (BVar5 == 0) {
            ImmSetOpenStatus(pHVar2,1);
          }
          local_8 = local_8 & 0xfffffffe | 8;
        }
        pcVar6 = "Half-Width Katakana";
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_00681707:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_0068170c;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681707;
          pbVar3 = pbVar3 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_0068170c:
        if (iVar4 == 0) {
          BVar5 = ImmGetOpenStatus(pHVar2);
          if (BVar5 == 0) {
            ImmSetOpenStatus(pHVar2,1);
          }
          local_8 = local_8 & 0xfffffff7 | 3;
        }
        pcVar6 = "Half-Width Alphanumeric";
        pbVar3 = param_2;
        do {
          bVar1 = *pbVar3;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_00681757:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_0068175c;
          }
          if (bVar1 == 0) break;
          bVar1 = pbVar3[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681757;
          pbVar3 = pbVar3 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_0068175c:
        if (iVar4 == 0) {
          BVar5 = ImmGetOpenStatus(pHVar2);
          if (BVar5 == 0) {
            ImmSetOpenStatus(pHVar2,1);
          }
          local_8 = local_8 & 0xfffffff6;
        }
        pcVar6 = "DirectInput";
        do {
          bVar1 = *param_2;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_006817a0:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_006817a5;
          }
          if (bVar1 == 0) break;
          bVar1 = param_2[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_006817a0;
          param_2 = param_2 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_006817a5:
        if (iVar4 == 0) {
          BVar5 = ImmGetOpenStatus(pHVar2);
          if (BVar5 != 0) {
            ImmSetOpenStatus(pHVar2,0);
          }
        }
      }
      else {
        pcVar6 = "StatusWindow_OnSymbol";
        do {
          bVar1 = *param_1;
          bVar8 = bVar1 < (byte)*pcVar6;
          if (bVar1 != *pcVar6) {
LAB_006817f0:
            iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
            goto LAB_006817f5;
          }
          if (bVar1 == 0) break;
          bVar1 = param_1[1];
          bVar8 = bVar1 < ((byte *)pcVar6)[1];
          if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_006817f0;
          param_1 = param_1 + 2;
          pcVar6 = (char *)((byte *)pcVar6 + 2);
        } while (bVar1 != 0);
        iVar4 = 0;
LAB_006817f5:
        if (iVar4 == 0) {
          pcVar6 = "false";
          pbVar3 = param_2;
          do {
            bVar1 = *pbVar3;
            bVar8 = bVar1 < (byte)*pcVar6;
            if (bVar1 != *pcVar6) {
LAB_00681828:
              iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
              goto LAB_0068182d;
            }
            if (bVar1 == 0) break;
            bVar1 = pbVar3[1];
            bVar8 = bVar1 < ((byte *)pcVar6)[1];
            if (bVar1 != ((byte *)pcVar6)[1]) goto LAB_00681828;
            pbVar3 = pbVar3 + 2;
            pcVar6 = (char *)((byte *)pcVar6 + 2);
          } while (bVar1 != 0);
          iVar4 = 0;
LAB_0068182d:
          if (iVar4 == 0) {
            local_8 = local_8 & 0xfffffbff;
          }
          pbVar3 = &DAT_00cd5b98;
          do {
            bVar1 = *param_2;
            bVar8 = bVar1 < *pbVar3;
            if (bVar1 != *pbVar3) {
LAB_00681860:
              iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
              goto LAB_00681865;
            }
            if (bVar1 == 0) break;
            bVar1 = param_2[1];
            bVar8 = bVar1 < pbVar3[1];
            if (bVar1 != pbVar3[1]) goto LAB_00681860;
            param_2 = param_2 + 2;
            pbVar3 = pbVar3 + 2;
          } while (bVar1 != 0);
          iVar4 = 0;
LAB_00681865:
          if (iVar4 == 0) {
            local_8 = local_8 | 0x400;
          }
        }
      }
    }
    ImmSetConversionStatus(pHVar2,local_8,local_4);
    ImmReleaseContext(*(HWND *)(*(int *)(in_ECX + 0x3c) + 0x18),pHVar2);
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00681470 : SUB ESP,0x8
00681473 : PUSH EBP
00681474 : MOV EBP,ECX
00681476 : MOV EAX,dword ptr [EBP + 0x3c]
00681479 : MOV ECX,dword ptr [EAX + 0x18]
0068147c : PUSH EDI
0068147d : PUSH ECX
0068147e : CALL 0x00611450
00681483 : MOV EDI,EAX
00681485 : LEA EDX,[ESP + 0xc]
00681489 : PUSH EDX
0068148a : LEA EAX,[ESP + 0xc]
0068148e : PUSH EAX
0068148f : PUSH EDI
00681490 : CALL 0x00685b6c
00681495 : TEST EDI,EDI
00681497 : JZ 0x00681890
0068149d : PUSH EBX
0068149e : PUSH ESI
0068149f : MOV ESI,dword ptr [ESP + 0x1c]
006814a3 : MOV ECX,0xbd7c14
006814a8 : MOV EAX,ESI
006814aa : LEA EBX,[EBX]
006814b0 : MOV DL,byte ptr [EAX]
006814b2 : CMP DL,byte ptr [ECX]
006814b4 : JNZ 0x006814d0
006814b6 : TEST DL,DL
006814b8 : JZ 0x006814cc
006814ba : MOV DL,byte ptr [EAX + 0x1]
006814bd : CMP DL,byte ptr [ECX + 0x1]
006814c0 : JNZ 0x006814d0
006814c2 : ADD EAX,0x2
006814c5 : ADD ECX,0x2
006814c8 : TEST DL,DL
006814ca : JNZ 0x006814b0
006814cc : XOR EAX,EAX
006814ce : JMP 0x006814d5
006814d0 : SBB EAX,EAX
006814d2 : SBB EAX,-0x1
006814d5 : TEST EAX,EAX
006814d7 : JNZ 0x0068154e
006814d9 : MOV EAX,dword ptr [ESP + 0x20]
006814dd : MOV EDX,0xcd5b90
006814e2 : MOV ECX,EAX
006814e4 : MOV BL,byte ptr [ECX]
006814e6 : CMP BL,byte ptr [EDX]
006814e8 : JNZ 0x00681504
006814ea : TEST BL,BL
006814ec : JZ 0x00681500
006814ee : MOV BL,byte ptr [ECX + 0x1]
006814f1 : CMP BL,byte ptr [EDX + 0x1]
006814f4 : JNZ 0x00681504
006814f6 : ADD ECX,0x2
006814f9 : ADD EDX,0x2
006814fc : TEST BL,BL
006814fe : JNZ 0x006814e4
00681500 : XOR ECX,ECX
00681502 : JMP 0x00681509
00681504 : SBB ECX,ECX
00681506 : SBB ECX,-0x1
00681509 : TEST ECX,ECX
0068150b : JNZ 0x00681512
0068150d : AND dword ptr [ESP + 0x10],0xfffffff7
00681512 : MOV ECX,0xcd5b98
00681517 : MOV DL,byte ptr [EAX]
00681519 : CMP DL,byte ptr [ECX]
0068151b : JNZ 0x00681537
0068151d : TEST DL,DL
0068151f : JZ 0x00681533
00681521 : MOV DL,byte ptr [EAX + 0x1]
00681524 : CMP DL,byte ptr [ECX + 0x1]
00681527 : JNZ 0x00681537
00681529 : ADD EAX,0x2
0068152c : ADD ECX,0x2
0068152f : TEST DL,DL
00681531 : JNZ 0x00681517
00681533 : XOR EAX,EAX
00681535 : JMP 0x0068153c
00681537 : SBB EAX,EAX
00681539 : SBB EAX,-0x1
0068153c : TEST EAX,EAX
0068153e : JNZ 0x00681871
00681544 : OR dword ptr [ESP + 0x10],0x8
00681549 : JMP 0x00681871
0068154e : MOV ECX,0xbd7bf8
00681553 : MOV EAX,ESI
00681555 : MOV DL,byte ptr [EAX]
00681557 : CMP DL,byte ptr [ECX]
00681559 : JNZ 0x00681575
0068155b : TEST DL,DL
0068155d : JZ 0x00681571
0068155f : MOV DL,byte ptr [EAX + 0x1]
00681562 : CMP DL,byte ptr [ECX + 0x1]
00681565 : JNZ 0x00681575
00681567 : ADD EAX,0x2
0068156a : ADD ECX,0x2
0068156d : TEST DL,DL
0068156f : JNZ 0x00681555
00681571 : XOR EAX,EAX
00681573 : JMP 0x0068157a
00681575 : SBB EAX,EAX
00681577 : SBB EAX,-0x1
0068157a : TEST EAX,EAX
0068157c : JNZ 0x006817c8
00681582 : MOV ESI,dword ptr [ESP + 0x20]
00681586 : MOV ECX,0xcd5b90
0068158b : MOV EAX,ESI
0068158d : LEA ECX,[ECX]
00681590 : MOV DL,byte ptr [EAX]
00681592 : CMP DL,byte ptr [ECX]
00681594 : JNZ 0x006815b0
00681596 : TEST DL,DL
00681598 : JZ 0x006815ac
0068159a : MOV DL,byte ptr [EAX + 0x1]
0068159d : CMP DL,byte ptr [ECX + 0x1]
006815a0 : JNZ 0x006815b0
006815a2 : ADD EAX,0x2
006815a5 : ADD ECX,0x2
006815a8 : TEST DL,DL
006815aa : JNZ 0x00681590
006815ac : XOR EAX,EAX
006815ae : JMP 0x006815b5
006815b0 : SBB EAX,EAX
006815b2 : SBB EAX,-0x1
006815b5 : TEST EAX,EAX
006815b7 : JNZ 0x006815be
006815b9 : AND dword ptr [ESP + 0x10],0xfffffffe
006815be : MOV ECX,0xcd5b98
006815c3 : MOV EAX,ESI
006815c5 : MOV DL,byte ptr [EAX]
006815c7 : CMP DL,byte ptr [ECX]
006815c9 : JNZ 0x006815e5
006815cb : TEST DL,DL
006815cd : JZ 0x006815e1
006815cf : MOV DL,byte ptr [EAX + 0x1]
006815d2 : CMP DL,byte ptr [ECX + 0x1]
006815d5 : JNZ 0x006815e5
006815d7 : ADD EAX,0x2
006815da : ADD ECX,0x2
006815dd : TEST DL,DL
006815df : JNZ 0x006815c5
006815e1 : XOR EAX,EAX
006815e3 : JMP 0x006815ea
006815e5 : SBB EAX,EAX
006815e7 : SBB EAX,-0x1
006815ea : TEST EAX,EAX
006815ec : JNZ 0x006815f3
006815ee : OR dword ptr [ESP + 0x10],0x1
006815f3 : MOV ECX,0xbd7bec
006815f8 : MOV EAX,ESI
006815fa : LEA EBX,[EBX]
00681600 : MOV DL,byte ptr [EAX]
00681602 : CMP DL,byte ptr [ECX]
00681604 : JNZ 0x00681620
00681606 : TEST DL,DL
00681608 : JZ 0x0068161c
0068160a : MOV DL,byte ptr [EAX + 0x1]
0068160d : CMP DL,byte ptr [ECX + 0x1]
00681610 : JNZ 0x00681620
00681612 : ADD EAX,0x2
00681615 : ADD ECX,0x2
00681618 : TEST DL,DL
0068161a : JNZ 0x00681600
0068161c : XOR EAX,EAX
0068161e : JMP 0x00681625
00681620 : SBB EAX,EAX
00681622 : SBB EAX,-0x1
00681625 : TEST EAX,EAX
00681627 : JNZ 0x00681649
00681629 : PUSH EDI
0068162a : CALL 0x00685b60
0068162f : TEST EAX,EAX
00681631 : JNZ 0x0068163b
00681633 : PUSH 0x1
00681635 : PUSH EDI
00681636 : CALL 0x00685b78
0068163b : MOV EAX,dword ptr [ESP + 0x10]
0068163f : AND EAX,0xfffffffd
00681642 : OR EAX,0x1
00681645 : MOV dword ptr [ESP + 0x10],EAX
00681649 : MOV ECX,0xbd7bd8
0068164e : MOV EAX,ESI
00681650 : MOV DL,byte ptr [EAX]
00681652 : CMP DL,byte ptr [ECX]
00681654 : JNZ 0x00681670
00681656 : TEST DL,DL
00681658 : JZ 0x0068166c
0068165a : MOV DL,byte ptr [EAX + 0x1]
0068165d : CMP DL,byte ptr [ECX + 0x1]
00681660 : JNZ 0x00681670
00681662 : ADD EAX,0x2
00681665 : ADD ECX,0x2
00681668 : TEST DL,DL
0068166a : JNZ 0x00681650
0068166c : XOR EAX,EAX
0068166e : JMP 0x00681675
00681670 : SBB EAX,EAX
00681672 : SBB EAX,-0x1
00681675 : TEST EAX,EAX
00681677 : JNZ 0x00681690
00681679 : PUSH EDI
0068167a : CALL 0x00685b60
0068167f : TEST EAX,EAX
00681681 : JNZ 0x0068168b
00681683 : PUSH 0x1
00681685 : PUSH EDI
00681686 : CALL 0x00685b78
0068168b : OR dword ptr [ESP + 0x10],0xb
00681690 : MOV ECX,0xbd7bc0
00681695 : MOV EAX,ESI
00681697 : MOV DL,byte ptr [EAX]
00681699 : CMP DL,byte ptr [ECX]
0068169b : JNZ 0x006816b7
0068169d : TEST DL,DL
0068169f : JZ 0x006816b3
006816a1 : MOV DL,byte ptr [EAX + 0x1]
006816a4 : CMP DL,byte ptr [ECX + 0x1]
006816a7 : JNZ 0x006816b7
006816a9 : ADD EAX,0x2
006816ac : ADD ECX,0x2
006816af : TEST DL,DL
006816b1 : JNZ 0x00681697
006816b3 : XOR EAX,EAX
006816b5 : JMP 0x006816bc
006816b7 : SBB EAX,EAX
006816b9 : SBB EAX,-0x1
006816bc : TEST EAX,EAX
006816be : JNZ 0x006816e0
006816c0 : PUSH EDI
006816c1 : CALL 0x00685b60
006816c6 : TEST EAX,EAX
006816c8 : JNZ 0x006816d2
006816ca : PUSH 0x1
006816cc : PUSH EDI
006816cd : CALL 0x00685b78
006816d2 : MOV EAX,dword ptr [ESP + 0x10]
006816d6 : AND EAX,0xfffffffe
006816d9 : OR EAX,0x8
006816dc : MOV dword ptr [ESP + 0x10],EAX
006816e0 : MOV ECX,0xbd7bac
006816e5 : MOV EAX,ESI
006816e7 : MOV DL,byte ptr [EAX]
006816e9 : CMP DL,byte ptr [ECX]
006816eb : JNZ 0x00681707
006816ed : TEST DL,DL
006816ef : JZ 0x00681703
006816f1 : MOV DL,byte ptr [EAX + 0x1]
006816f4 : CMP DL,byte ptr [ECX + 0x1]
006816f7 : JNZ 0x00681707
006816f9 : ADD EAX,0x2
006816fc : ADD ECX,0x2
006816ff : TEST DL,DL
00681701 : JNZ 0x006816e7
00681703 : XOR EAX,EAX
00681705 : JMP 0x0068170c
00681707 : SBB EAX,EAX
00681709 : SBB EAX,-0x1
0068170c : TEST EAX,EAX
0068170e : JNZ 0x00681730
00681710 : PUSH EDI
00681711 : CALL 0x00685b60
00681716 : TEST EAX,EAX
00681718 : JNZ 0x00681722
0068171a : PUSH 0x1
0068171c : PUSH EDI
0068171d : CALL 0x00685b78
00681722 : MOV EAX,dword ptr [ESP + 0x10]
00681726 : AND EAX,0xfffffff7
00681729 : OR EAX,0x3
0068172c : MOV dword ptr [ESP + 0x10],EAX
00681730 : MOV ECX,0xbd7b94
00681735 : MOV EAX,ESI
00681737 : MOV DL,byte ptr [EAX]
00681739 : CMP DL,byte ptr [ECX]
0068173b : JNZ 0x00681757
0068173d : TEST DL,DL
0068173f : JZ 0x00681753
00681741 : MOV DL,byte ptr [EAX + 0x1]
00681744 : CMP DL,byte ptr [ECX + 0x1]
00681747 : JNZ 0x00681757
00681749 : ADD EAX,0x2
0068174c : ADD ECX,0x2
0068174f : TEST DL,DL
00681751 : JNZ 0x00681737
00681753 : XOR EAX,EAX
00681755 : JMP 0x0068175c
00681757 : SBB EAX,EAX
00681759 : SBB EAX,-0x1
0068175c : TEST EAX,EAX
0068175e : JNZ 0x00681777
00681760 : PUSH EDI
00681761 : CALL 0x00685b60
00681766 : TEST EAX,EAX
00681768 : JNZ 0x00681772
0068176a : PUSH 0x1
0068176c : PUSH EDI
0068176d : CALL 0x00685b78
00681772 : AND dword ptr [ESP + 0x10],0xfffffff6
00681777 : MOV ECX,0xbd7988
0068177c : MOV EAX,ESI
0068177e : MOV EDI,EDI
00681780 : MOV DL,byte ptr [EAX]
00681782 : CMP DL,byte ptr [ECX]
00681784 : JNZ 0x006817a0
00681786 : TEST DL,DL
00681788 : JZ 0x0068179c
0068178a : MOV DL,byte ptr [EAX + 0x1]
0068178d : CMP DL,byte ptr [ECX + 0x1]
00681790 : JNZ 0x006817a0
00681792 : ADD EAX,0x2
00681795 : ADD ECX,0x2
00681798 : TEST DL,DL
0068179a : JNZ 0x00681780
0068179c : XOR EAX,EAX
0068179e : JMP 0x006817a5
006817a0 : SBB EAX,EAX
006817a2 : SBB EAX,-0x1
006817a5 : TEST EAX,EAX
006817a7 : JNZ 0x00681871
006817ad : PUSH EDI
006817ae : CALL 0x00685b60
006817b3 : TEST EAX,EAX
006817b5 : JZ 0x00681871
006817bb : PUSH 0x0
006817bd : PUSH EDI
006817be : CALL 0x00685b78
006817c3 : JMP 0x00681871
006817c8 : MOV ECX,0xbd7b7c
006817cd : MOV EAX,ESI
006817cf : NOP
006817d0 : MOV DL,byte ptr [EAX]
006817d2 : CMP DL,byte ptr [ECX]
006817d4 : JNZ 0x006817f0
006817d6 : TEST DL,DL
006817d8 : JZ 0x006817ec
006817da : MOV DL,byte ptr [EAX + 0x1]
006817dd : CMP DL,byte ptr [ECX + 0x1]
006817e0 : JNZ 0x006817f0
006817e2 : ADD EAX,0x2
006817e5 : ADD ECX,0x2
006817e8 : TEST DL,DL
006817ea : JNZ 0x006817d0
006817ec : XOR EAX,EAX
006817ee : JMP 0x006817f5
006817f0 : SBB EAX,EAX
006817f2 : SBB EAX,-0x1
006817f5 : TEST EAX,EAX
006817f7 : JNZ 0x00681871
006817fd : MOV EAX,dword ptr [ESP + 0x20]
00681801 : MOV EDX,0xcd5b90
00681806 : MOV ECX,EAX
00681808 : MOV BL,byte ptr [ECX]
0068180a : CMP BL,byte ptr [EDX]
0068180c : JNZ 0x00681828
0068180e : TEST BL,BL
00681810 : JZ 0x00681824
00681812 : MOV BL,byte ptr [ECX + 0x1]
00681815 : CMP BL,byte ptr [EDX + 0x1]
00681818 : JNZ 0x00681828
0068181a : ADD ECX,0x2
0068181d : ADD EDX,0x2
00681820 : TEST BL,BL
00681822 : JNZ 0x00681808
00681824 : XOR ECX,ECX
00681826 : JMP 0x0068182d
00681828 : SBB ECX,ECX
0068182a : SBB ECX,-0x1
0068182d : TEST ECX,ECX
0068182f : JNZ 0x00681839
00681831 : AND dword ptr [ESP + 0x10],0xfffffbff
00681839 : MOV ECX,0xcd5b98
0068183e : MOV EDI,EDI
00681840 : MOV DL,byte ptr [EAX]
00681842 : CMP DL,byte ptr [ECX]
00681844 : JNZ 0x00681860
00681846 : TEST DL,DL
00681848 : JZ 0x0068185c
0068184a : MOV DL,byte ptr [EAX + 0x1]
0068184d : CMP DL,byte ptr [ECX + 0x1]
00681850 : JNZ 0x00681860
00681852 : ADD EAX,0x2
00681855 : ADD ECX,0x2
00681858 : TEST DL,DL
0068185a : JNZ 0x00681840
0068185c : XOR EAX,EAX
0068185e : JMP 0x00681865
00681860 : SBB EAX,EAX
00681862 : SBB EAX,-0x1
00681865 : TEST EAX,EAX
00681867 : JNZ 0x00681871
00681869 : OR dword ptr [ESP + 0x10],0x400
00681871 : MOV ECX,dword ptr [ESP + 0x14]
00681875 : MOV EDX,dword ptr [ESP + 0x10]
00681879 : PUSH ECX
0068187a : PUSH EDX
0068187b : PUSH EDI
0068187c : CALL 0x00685b72
00681881 : MOV EAX,dword ptr [EBP + 0x3c]
00681884 : MOV ECX,dword ptr [EAX + 0x18]
00681887 : PUSH EDI
00681888 : PUSH ECX
00681889 : CALL 0x00611462
0068188e : POP ESI
0068188f : POP EBX
00681890 : POP EDI
00681891 : POP EBP
00681892 : ADD ESP,0x8
00681895 : RET 0x8
