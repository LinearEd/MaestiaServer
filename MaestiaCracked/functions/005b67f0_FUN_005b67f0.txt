PROGRAM  : Maestia.exe
FUNCTION : FUN_005b67f0
ENTRY    : 005b67f0
BODY     : [[005b67f0, 005b6c9e]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_005b67f0(void)

{
  code *pcVar1;
  int *piVar2;
  char cVar3;
  GRefCountNTSImpl *this;
  undefined4 uVar4;
  uint *puVar5;
  int *in_ECX;
  int iVar6;
  int unaff_EBX;
  int unaff_ESI;
  undefined4 *puVar7;
  int iVar8;
  GRefCountNTSImpl *pGVar9;
  uint uVar10;
  bool bVar11;
  undefined4 uVar12;
  int iStack_54;
  undefined4 *local_50;
  uint local_4c;
  int local_48;
  int local_44;
  int *local_40 [2];
  int iStack_38;
  int iStack_34;
  byte bStack_30;
  undefined4 uStack_2c;
  undefined4 *puStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined1 auStack_10 [4];
  int iStack_c;
  
  iVar6 = in_ECX[0x27];
  local_4c = 0;
  if (*(int *)(iVar6 + 0x1c) != 0) {
    local_48 = 0;
    do {
      iVar8 = local_48;
      uVar10 = local_4c;
      local_50 = (undefined4 *)(*(int *)(iVar6 + 0x18) + local_48);
      iVar6 = in_ECX[0x2e];
      if (*(int *)(local_4c * 4 + in_ECX[0x29]) == 0) {
        if (iVar6 == 0) {
          bVar11 = (*(byte *)(local_50 + 0x12) & 8) == 0;
LAB_005b685c:
          if (bVar11) goto LAB_005b685e;
        }
        else {
          if (iVar6 == 1) {
            bVar11 = (*(byte *)(local_50 + 0x12) & 2) == 0;
            goto LAB_005b685c;
          }
          if (iVar6 == 2) {
            bVar11 = (*(byte *)(local_50 + 0x12) & 4) == 0;
            goto LAB_005b685c;
          }
LAB_005b685e:
          if ((*(byte *)(local_50 + 0x12) & 1) == 0) goto LAB_005b6c7c;
        }
        FUN_00565f40(local_40,local_50[0xf]);
        if (local_40[0] != (int *)0x0) {
          iVar8 = iVar8 + *(int *)(in_ECX[0x27] + 0x18);
          local_44 = iVar8 + 0x1c;
          this = (GRefCountNTSImpl *)(**(code **)(*local_40[0] + 0x24))();
          iVar6 = in_ECX[0x29];
          if (this != (GRefCountNTSImpl *)0x0) {
            *(int *)(this + 4) = *(int *)(this + 4) + 1;
          }
          pGVar9 = *(GRefCountNTSImpl **)(iVar6 + unaff_ESI);
          if (pGVar9 != (GRefCountNTSImpl *)0x0) {
            GRefCountNTSImpl::Release(pGVar9);
          }
          *(GRefCountNTSImpl **)(iVar6 + unaff_ESI) = this;
          *(undefined4 *)(this + 0x44) = *(undefined4 *)(iVar8 + 4);
          *(undefined4 *)(this + 0x48) = *(undefined4 *)(iVar8 + 8);
          *(undefined4 *)(this + 0x4c) = *(undefined4 *)(iVar8 + 0xc);
          *(undefined4 *)(this + 0x50) = *(undefined4 *)(iVar8 + 0x10);
          *(undefined4 *)(this + 0x54) = *(undefined4 *)(iVar8 + 0x14);
          *(undefined4 *)(this + 0x58) = *(undefined4 *)(iVar8 + 0x18);
          pcVar1 = *(code **)(*(int *)this + 4);
          puVar7 = local_50;
          pGVar9 = this + 0x24;
          for (iVar6 = 8; iVar6 != 0; iVar6 = iVar6 + -1) {
            *(undefined4 *)pGVar9 = *puVar7;
            puVar7 = puVar7 + 1;
            pGVar9 = pGVar9 + 4;
          }
          (*pcVar1)();
          (**(code **)(*(int *)this + 0x18))(*(undefined4 *)(unaff_EBX + 0x44));
          piVar2 = *(int **)(this + 0x20);
          this[0x66] = (GRefCountNTSImpl)((byte)this[0x66] & 0xfe);
          for (; piVar2 != (int *)0x0; piVar2 = (int *)piVar2[8]) {
            iVar6 = (**(code **)(*piVar2 + 0x38))();
            if (iVar6 != 0) {
              pcVar1 = *(code **)(*(int *)this + 0x3c);
              this[0x66] = (GRefCountNTSImpl)((byte)this[0x66] | 1);
              (*pcVar1)();
              break;
            }
          }
          uVar10 = -(uint)(((byte)this[0x66] & 0x80) != 0) & (uint)this;
          if (uVar10 != 0) {
            uVar4 = (**(code **)(*in_ECX + 0x40))();
            iVar6 = (**(code **)(*(int *)(uVar10 + 0x68) + 8))();
            if (iVar6 == 2) {
              local_44 = (**(code **)(*in_ECX + 0xb0))();
              uVar12 = local_50[0xf];
              iStack_38 = 0;
              iStack_34 = 0;
              bStack_30 = 0;
              (**(code **)(*(int *)this + 0x48))(uVar12);
              puVar5 = (uint *)FUN_00564c70(uVar12);
              if (puVar5 != (uint *)0x0) {
                (**(code **)(*in_ECX + 0x5c))();
                iStack_54 = FUN_00525450((*puVar5 & 0xfffffffc) + 8,
                                         *(uint *)(*puVar5 & 0xfffffffc) & 0x7fffffff);
                *(int *)(iStack_54 + 8) = *(int *)(iStack_54 + 8) + 1;
                iVar6 = (**(code **)(*in_ECX + 0x5c))();
                cVar3 = FUN_005304f0(iVar6 + 0x78,&iStack_54,&iStack_38);
                if (cVar3 == '\0') {
                  uStack_2c = 0;
                  puStack_28 = (undefined4 *)0x0;
                  uStack_24 = 0;
                  auStack_10[0] = 5;
                  iStack_c = iStack_54;
                  *(int *)(iStack_54 + 8) = *(int *)(iStack_54 + 8) + 1;
                  FUN_00504f00(auStack_10);
                  FUN_00526bc0();
                  iVar6 = FUN_00571c40(3);
                  if (iVar6 != 0) {
                    *(undefined4 *)(iVar6 + 4) = 4;
                    *(int *)(uVar10 + 4) = *(int *)(uVar10 + 4) + 1;
                    if (*(GRefCountNTSImpl **)(iVar6 + 8) != (GRefCountNTSImpl *)0x0) {
                      GRefCountNTSImpl::Release(*(GRefCountNTSImpl **)(iVar6 + 8));
                    }
                    *(uint *)(iVar6 + 8) = uVar10;
                    if (*(GRefCountNTSImpl **)(iVar6 + 0xc) != (GRefCountNTSImpl *)0x0) {
                      GRefCountNTSImpl::Release(*(GRefCountNTSImpl **)(iVar6 + 0xc));
                    }
                    *(undefined4 *)(iVar6 + 0xc) = 0;
                    *(undefined1 **)(iVar6 + 0x2c) = &LAB_00592dd0;
                    FUN_00504fd0(&uStack_2c);
                  }
                  if (puStack_28 != (undefined4 *)0x0) {
                    local_50 = puStack_28;
                    do {
                      FUN_00526bc0();
                      local_50 = (undefined4 *)((int)local_50 + -1);
                    } while (local_50 != (undefined4 *)0x0);
                  }
                  FUN_00515cf0(uStack_2c);
                }
                else {
                  if (iStack_38 == 0) {
                    iVar6 = 0;
                  }
                  else {
                    iVar6 = iStack_38 + 0x10;
                  }
                  FUN_0051d250(iVar6);
                  iVar6 = FUN_00571c40(3);
                  if (iVar6 != 0) {
                    FUN_004ffe70(0x40000);
                    *(undefined4 *)(iVar6 + 4) = 2;
                    *(int *)(uVar10 + 4) = *(int *)(uVar10 + 4) + 1;
                    if (*(GRefCountNTSImpl **)(iVar6 + 8) != (GRefCountNTSImpl *)0x0) {
                      GRefCountNTSImpl::Release(*(GRefCountNTSImpl **)(iVar6 + 8));
                    }
                    *(uint *)(iVar6 + 8) = uVar10;
                    if (*(GRefCountNTSImpl **)(iVar6 + 0xc) != (GRefCountNTSImpl *)0x0) {
                      GRefCountNTSImpl::Release(*(GRefCountNTSImpl **)(iVar6 + 0xc));
                    }
                    *(undefined4 *)(iVar6 + 0xc) = 0;
                    *(undefined4 *)(iVar6 + 0x10) = uStack_20;
                    *(undefined4 *)(iVar6 + 0x14) = uStack_1c;
                    *(undefined4 *)(iVar6 + 0x18) = uStack_18;
                    *(undefined4 *)(iVar6 + 0x1c) = uStack_14;
                  }
                  iVar6 = FUN_00571c40(3);
                  if (iVar6 != 0) {
                    *(undefined4 *)(iVar6 + 4) = 3;
                    *(int *)(uVar10 + 4) = *(int *)(uVar10 + 4) + 1;
                    if (*(GRefCountNTSImpl **)(iVar6 + 8) != (GRefCountNTSImpl *)0x0) {
                      GRefCountNTSImpl::Release(*(GRefCountNTSImpl **)(iVar6 + 8));
                    }
                    *(uint *)(iVar6 + 8) = uVar10;
                    if (*(GRefCountNTSImpl **)(iVar6 + 0xc) != (GRefCountNTSImpl *)0x0) {
                      GRefCountNTSImpl::Release(*(GRefCountNTSImpl **)(iVar6 + 0xc));
                    }
                    *(undefined4 *)(iVar6 + 0xc) = 0;
                    FUN_00568a50(&iStack_38);
                  }
                }
                *(int *)(iStack_54 + 8) = *(int *)(iStack_54 + 8) + -1;
                if (*(int *)(iStack_54 + 8) == 0) {
                  FUN_00525340();
                }
              }
              if (((bStack_30 & 2) == 0) && (iStack_38 != 0)) {
                FUN_00503db0();
              }
              iStack_38 = 0;
              if (((bStack_30 & 1) == 0) && (iStack_34 != 0)) {
                FUN_00503db0();
              }
              iStack_34 = 0;
            }
            FUN_0051d570(uVar4);
            FUN_0051dcd0(uVar4);
            (**(code **)(*(int *)this + 0x70))();
          }
          GRefCountNTSImpl::Release(this);
          uVar10 = local_4c;
          iVar8 = local_48;
        }
      }
      else if (iVar6 == 0) {
        bVar11 = (*(byte *)(local_50 + 0x12) & 8) == 0;
LAB_005b6c6c:
        if (bVar11) goto LAB_005b6c6e;
      }
      else {
        if (iVar6 == 1) {
          bVar11 = (*(byte *)(local_50 + 0x12) & 2) == 0;
          goto LAB_005b6c6c;
        }
        if (iVar6 == 2) {
          bVar11 = (*(byte *)(local_50 + 0x12) & 4) == 0;
          goto LAB_005b6c6c;
        }
LAB_005b6c6e:
        if ((*(byte *)(local_50 + 0x12) & 1) == 0) {
          FUN_005b5a10(local_4c);
        }
      }
LAB_005b6c7c:
      iVar6 = in_ECX[0x27];
      local_4c = uVar10 + 1;
      local_48 = iVar8 + 0x4c;
    } while (local_4c < *(uint *)(iVar6 + 0x1c));
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
005b67f0 : SUB ESP,0x58
005b67f3 : PUSH EBX
005b67f4 : PUSH EBP
005b67f5 : MOV EBX,ECX
005b67f7 : MOV EAX,dword ptr [EBX + 0x9c]
005b67fd : XOR EBP,EBP
005b67ff : PUSH ESI
005b6800 : PUSH EDI
005b6801 : MOV dword ptr [ESP + 0x1c],EBP
005b6805 : CMP dword ptr [EAX + 0x1c],EBP
005b6808 : JBE 0x005b6c97
005b680e : XOR EDI,EDI
005b6810 : MOV dword ptr [ESP + 0x20],EDI
005b6814 : MOV ESI,dword ptr [EAX + 0x18]
005b6817 : MOV ECX,dword ptr [EBX + 0xa4]
005b681d : LEA EAX,[EBP*0x4 + 0x0]
005b6824 : ADD ESI,EDI
005b6826 : CMP dword ptr [EAX + ECX*0x1],0x0
005b682a : MOV dword ptr [ESP + 0x10],EAX
005b682e : MOV EAX,dword ptr [EBX + 0xb8]
005b6834 : MOV dword ptr [ESP + 0x18],ESI
005b6838 : JNZ 0x005b6c4e
005b683e : TEST EAX,EAX
005b6840 : JNZ 0x005b6848
005b6842 : TEST byte ptr [ESI + 0x48],0x8
005b6846 : JMP 0x005b685c
005b6848 : CMP EAX,0x1
005b684b : JNZ 0x005b6853
005b684d : TEST byte ptr [ESI + 0x48],0x2
005b6851 : JMP 0x005b685c
005b6853 : CMP EAX,0x2
005b6856 : JNZ 0x005b685e
005b6858 : TEST byte ptr [ESI + 0x48],0x4
005b685c : JNZ 0x005b6868
005b685e : TEST byte ptr [ESI + 0x48],0x1
005b6862 : JZ 0x005b6c7c
005b6868 : MOV EDX,dword ptr [ESI + 0x3c]
005b686b : PUSH ECX
005b686c : MOV EAX,ESP
005b686e : MOV dword ptr [EAX],EDX
005b6870 : MOV ECX,dword ptr [EBX + 0x7c]
005b6873 : LEA EAX,[ESP + 0x2c]
005b6877 : PUSH EAX
005b6878 : CALL 0x00565f40
005b687d : CMP dword ptr [ESP + 0x28],0x0
005b6882 : JZ 0x005b6c7c
005b6888 : MOV ECX,dword ptr [EBX + 0x9c]
005b688e : MOV EDX,dword ptr [ECX + 0x18]
005b6891 : MOV ECX,dword ptr [ESP + 0x2c]
005b6895 : ADD EDI,EDX
005b6897 : MOV EDX,dword ptr [ESI + 0x3c]
005b689a : PUSH ECX
005b689b : PUSH ECX
005b689c : LEA EAX,[EDI + 0x1c]
005b689f : MOV dword ptr [ESP + 0x2c],EAX
005b68a3 : MOV EAX,ESP
005b68a5 : MOV dword ptr [EAX],EDX
005b68a7 : MOV ECX,dword ptr [ESP + 0x30]
005b68ab : MOV EAX,dword ptr [ECX]
005b68ad : MOV EDX,dword ptr [EAX + 0x24]
005b68b0 : PUSH EBX
005b68b1 : CALL EDX
005b68b3 : MOV ESI,dword ptr [EBX + 0xa4]
005b68b9 : ADD ESI,dword ptr [ESP + 0x10]
005b68bd : MOV EBP,EAX
005b68bf : TEST EBP,EBP
005b68c1 : JZ 0x005b68c6
005b68c3 : INC dword ptr [EBP + 0x4]
005b68c6 : MOV ECX,dword ptr [ESI]
005b68c8 : TEST ECX,ECX
005b68ca : JZ 0x005b68d1
005b68cc : CALL 0x004ff7c0
005b68d1 : MOV dword ptr [ESI],EBP
005b68d3 : FLD float ptr [EDI + 0x4]
005b68d6 : MOV ESI,dword ptr [ESP + 0x24]
005b68da : FSTP float ptr [EBP + 0x44]
005b68dd : FLD float ptr [EDI + 0x8]
005b68e0 : MOV ECX,0x8
005b68e5 : FSTP float ptr [EBP + 0x48]
005b68e8 : FLD float ptr [EDI + 0xc]
005b68eb : FSTP float ptr [EBP + 0x4c]
005b68ee : FLD float ptr [EDI + 0x10]
005b68f1 : FSTP float ptr [EBP + 0x50]
005b68f4 : FLD float ptr [EDI + 0x14]
005b68f7 : FSTP float ptr [EBP + 0x54]
005b68fa : FLD float ptr [EDI + 0x18]
005b68fd : LEA EDI,[EBP + 0x24]
005b6900 : FSTP float ptr [EBP + 0x58]
005b6903 : MOV EAX,dword ptr [EBP]
005b6906 : MOV EDX,dword ptr [EAX + 0x4]
005b6909 : MOVSD.REP ES:EDI,ESI
005b690b : MOV ECX,EBP
005b690d : CALL EDX
005b690f : MOV ECX,dword ptr [ESP + 0x18]
005b6913 : MOV EDX,dword ptr [ECX + 0x44]
005b6916 : MOV EAX,dword ptr [EBP]
005b6919 : MOV EAX,dword ptr [EAX + 0x18]
005b691c : PUSH EDX
005b691d : MOV ECX,EBP
005b691f : CALL EAX
005b6921 : MOV EDI,dword ptr [EBP + 0x20]
005b6924 : AND byte ptr [EBP + 0x66],0xfe
005b6928 : TEST EDI,EDI
005b692a : JZ 0x005b6954
005b692c : LEA ESP,[ESP]
005b6930 : MOV EDX,dword ptr [EDI]
005b6932 : MOV EAX,dword ptr [EDX + 0x38]
005b6935 : MOV ECX,EDI
005b6937 : CALL EAX
005b6939 : TEST EAX,EAX
005b693b : JNZ 0x005b6946
005b693d : MOV EDI,dword ptr [EDI + 0x20]
005b6940 : TEST EDI,EDI
005b6942 : JNZ 0x005b6930
005b6944 : JMP 0x005b6954
005b6946 : MOV EDX,dword ptr [EBP]
005b6949 : MOV EAX,dword ptr [EDX + 0x3c]
005b694c : OR byte ptr [EBP + 0x66],0x1
005b6950 : MOV ECX,EBP
005b6952 : CALL EAX
005b6954 : MOV CL,byte ptr [EBP + 0x66]
005b6957 : AND CL,0x80
005b695a : MOVZX EDI,CL
005b695d : NEG EDI
005b695f : SBB EDI,EDI
005b6961 : AND EDI,EBP
005b6963 : JZ 0x005b6c3d
005b6969 : MOV EDX,dword ptr [EBX]
005b696b : MOV EAX,dword ptr [EDX + 0x40]
005b696e : MOV ECX,EBX
005b6970 : CALL EAX
005b6972 : MOV EDX,dword ptr [EDI + 0x68]
005b6975 : LEA ECX,[EDI + 0x68]
005b6978 : MOV ESI,EAX
005b697a : MOV EAX,dword ptr [EDX + 0x8]
005b697d : MOV dword ptr [ESP + 0x10],ESI
005b6981 : CALL EAX
005b6983 : CMP EAX,0x2
005b6986 : JNZ 0x005b6c23
005b698c : MOV EDX,dword ptr [EBX]
005b698e : MOV EAX,dword ptr [EDX + 0xb0]
005b6994 : MOV ECX,EBX
005b6996 : CALL EAX
005b6998 : MOV dword ptr [ESP + 0x24],EAX
005b699c : XOR EAX,EAX
005b699e : PUSH ECX
005b699f : MOV ECX,dword ptr [ESP + 0x1c]
005b69a3 : MOV EDX,dword ptr [ECX + 0x3c]
005b69a6 : MOV dword ptr [ESP + 0x34],EAX
005b69aa : MOV dword ptr [ESP + 0x38],EAX
005b69ae : MOV EAX,ESP
005b69b0 : MOV byte ptr [ESP + 0x3c],0x0
005b69b5 : MOV dword ptr [EAX],EDX
005b69b7 : MOV EAX,dword ptr [EBP]
005b69ba : MOV EDX,dword ptr [EAX + 0x48]
005b69bd : MOV ECX,EBP
005b69bf : CALL EDX
005b69c1 : MOV ECX,EAX
005b69c3 : CALL 0x00564c70
005b69c8 : MOV ESI,EAX
005b69ca : TEST ESI,ESI
005b69cc : JZ 0x005b6be7
005b69d2 : MOV EAX,dword ptr [EBX]
005b69d4 : MOV EDX,dword ptr [EAX + 0x5c]
005b69d7 : MOV ECX,EBX
005b69d9 : CALL EDX
005b69db : MOV EDX,dword ptr [EAX + 0x78]
005b69de : MOV EAX,dword ptr [ESI]
005b69e0 : MOV ECX,EAX
005b69e2 : AND ECX,0xfffffffc
005b69e5 : MOV ECX,dword ptr [ECX]
005b69e7 : AND ECX,0x7fffffff
005b69ed : AND EAX,0xfffffffc
005b69f0 : PUSH ECX
005b69f1 : ADD EAX,0x8
005b69f4 : PUSH EAX
005b69f5 : LEA ECX,[EDX + 0x254]
005b69fb : CALL 0x00525450
005b6a00 : MOV dword ptr [ESP + 0x14],EAX
005b6a04 : MOV ESI,0x1
005b6a09 : ADD dword ptr [EAX + 0x8],ESI
005b6a0c : MOV EDX,dword ptr [EBX]
005b6a0e : MOV EAX,dword ptr [EDX + 0x5c]
005b6a11 : MOV ECX,EBX
005b6a13 : CALL EAX
005b6a15 : LEA ECX,[ESP + 0x30]
005b6a19 : PUSH ECX
005b6a1a : MOV ECX,dword ptr [ESP + 0x28]
005b6a1e : LEA EDX,[ESP + 0x18]
005b6a22 : PUSH EDX
005b6a23 : ADD EAX,0x78
005b6a26 : PUSH EAX
005b6a27 : CALL 0x005304f0
005b6a2c : TEST AL,AL
005b6a2e : JZ 0x005b6b11
005b6a34 : MOV EAX,dword ptr [ESP + 0x30]
005b6a38 : TEST EAX,EAX
005b6a3a : JZ 0x005b6a41
005b6a3c : ADD EAX,0x10
005b6a3f : JMP 0x005b6a43
005b6a41 : XOR EAX,EAX
005b6a43 : PUSH EAX
005b6a44 : MOV ECX,EDI
005b6a46 : CALL 0x0051d250
005b6a4b : MOV ECX,dword ptr [ESP + 0x10]
005b6a4f : ADD ECX,0xa2c
005b6a55 : PUSH 0x3
005b6a57 : CALL 0x00571c40
005b6a5c : MOV ESI,EAX
005b6a5e : TEST ESI,ESI
005b6a60 : JZ 0x005b6ab8
005b6a62 : PUSH 0x40000
005b6a67 : LEA ECX,[ESP + 0x4c]
005b6a6b : CALL 0x004ffe70
005b6a70 : MOV dword ptr [ESI + 0x4],0x2
005b6a77 : INC dword ptr [EDI + 0x4]
005b6a7a : MOV ECX,dword ptr [ESI + 0x8]
005b6a7d : TEST ECX,ECX
005b6a7f : JZ 0x005b6a86
005b6a81 : CALL 0x004ff7c0
005b6a86 : MOV dword ptr [ESI + 0x8],EDI
005b6a89 : MOV ECX,dword ptr [ESI + 0xc]
005b6a8c : TEST ECX,ECX
005b6a8e : JZ 0x005b6a95
005b6a90 : CALL 0x004ff7c0
005b6a95 : MOV EAX,dword ptr [ESP + 0x48]
005b6a99 : MOV ECX,dword ptr [ESP + 0x4c]
005b6a9d : MOV EDX,dword ptr [ESP + 0x50]
005b6aa1 : MOV dword ptr [ESI + 0xc],0x0
005b6aa8 : MOV dword ptr [ESI + 0x10],EAX
005b6aab : MOV EAX,dword ptr [ESP + 0x54]
005b6aaf : MOV dword ptr [ESI + 0x14],ECX
005b6ab2 : MOV dword ptr [ESI + 0x18],EDX
005b6ab5 : MOV dword ptr [ESI + 0x1c],EAX
005b6ab8 : MOV ECX,dword ptr [ESP + 0x10]
005b6abc : PUSH 0x3
005b6abe : ADD ECX,0xa2c
005b6ac4 : CALL 0x00571c40
005b6ac9 : MOV ESI,EAX
005b6acb : TEST ESI,ESI
005b6acd : JZ 0x005b6bd1
005b6ad3 : MOV dword ptr [ESI + 0x4],0x3
005b6ada : INC dword ptr [EDI + 0x4]
005b6add : MOV ECX,dword ptr [ESI + 0x8]
005b6ae0 : TEST ECX,ECX
005b6ae2 : JZ 0x005b6ae9
005b6ae4 : CALL 0x004ff7c0
005b6ae9 : MOV dword ptr [ESI + 0x8],EDI
005b6aec : MOV ECX,dword ptr [ESI + 0xc]
005b6aef : TEST ECX,ECX
005b6af1 : JZ 0x005b6af8
005b6af3 : CALL 0x004ff7c0
005b6af8 : LEA ECX,[ESP + 0x30]
005b6afc : PUSH ECX
005b6afd : LEA ECX,[ESI + 0x20]
005b6b00 : MOV dword ptr [ESI + 0xc],0x0
005b6b07 : CALL 0x00568a50
005b6b0c : JMP 0x005b6bd1
005b6b11 : XOR EAX,EAX
005b6b13 : MOV dword ptr [ESP + 0x3c],EAX
005b6b17 : MOV dword ptr [ESP + 0x40],EAX
005b6b1b : MOV dword ptr [ESP + 0x44],EAX
005b6b1f : MOV EAX,dword ptr [ESP + 0x14]
005b6b23 : LEA EDX,[ESP + 0x58]
005b6b27 : MOV byte ptr [ESP + 0x58],0x5
005b6b2c : MOV dword ptr [ESP + 0x5c],EAX
005b6b30 : ADD dword ptr [EAX + 0x8],ESI
005b6b33 : PUSH EDX
005b6b34 : LEA ECX,[ESP + 0x40]
005b6b38 : CALL 0x00504f00
005b6b3d : LEA ECX,[ESP + 0x58]
005b6b41 : CALL 0x00526bc0
005b6b46 : MOV ECX,dword ptr [ESP + 0x10]
005b6b4a : PUSH 0x3
005b6b4c : ADD ECX,0xa2c
005b6b52 : CALL 0x00571c40
005b6b57 : MOV ESI,EAX
005b6b59 : TEST ESI,ESI
005b6b5b : JZ 0x005b6b9d
005b6b5d : MOV dword ptr [ESI + 0x4],0x4
005b6b64 : INC dword ptr [EDI + 0x4]
005b6b67 : MOV ECX,dword ptr [ESI + 0x8]
005b6b6a : TEST ECX,ECX
005b6b6c : JZ 0x005b6b73
005b6b6e : CALL 0x004ff7c0
005b6b73 : MOV dword ptr [ESI + 0x8],EDI
005b6b76 : MOV ECX,dword ptr [ESI + 0xc]
005b6b79 : TEST ECX,ECX
005b6b7b : JZ 0x005b6b82
005b6b7d : CALL 0x004ff7c0
005b6b82 : LEA EAX,[ESP + 0x3c]
005b6b86 : MOV dword ptr [ESI + 0xc],0x0
005b6b8d : PUSH EAX
005b6b8e : LEA ECX,[ESI + 0x30]
005b6b91 : MOV dword ptr [ESI + 0x2c],0x592dd0
005b6b98 : CALL 0x00504fd0
005b6b9d : MOV EAX,dword ptr [ESP + 0x40]
005b6ba1 : MOV EDX,dword ptr [ESP + 0x3c]
005b6ba5 : MOV ECX,EAX
005b6ba7 : SHL ECX,0x4
005b6baa : LEA ESI,[ECX + EDX*0x1 + -0x10]
005b6bae : TEST EAX,EAX
005b6bb0 : JBE 0x005b6bc7
005b6bb2 : MOV dword ptr [ESP + 0x18],EAX
005b6bb6 : MOV ECX,ESI
005b6bb8 : CALL 0x00526bc0
005b6bbd : SUB ESI,0x10
005b6bc0 : SUB dword ptr [ESP + 0x18],0x1
005b6bc5 : JNZ 0x005b6bb6
005b6bc7 : MOV EAX,dword ptr [ESP + 0x3c]
005b6bcb : PUSH EAX
005b6bcc : CALL 0x00515cf0
005b6bd1 : MOV EAX,dword ptr [ESP + 0x14]
005b6bd5 : DEC dword ptr [EAX + 0x8]
005b6bd8 : MOV ECX,EAX
005b6bda : ADD EAX,0x8
005b6bdd : CMP dword ptr [EAX],0x0
005b6be0 : JNZ 0x005b6be7
005b6be2 : CALL 0x00525340
005b6be7 : TEST byte ptr [ESP + 0x38],0x2
005b6bec : JNZ 0x005b6bfb
005b6bee : MOV ECX,dword ptr [ESP + 0x30]
005b6bf2 : TEST ECX,ECX
005b6bf4 : JZ 0x005b6bfb
005b6bf6 : CALL 0x00503db0
005b6bfb : TEST byte ptr [ESP + 0x38],0x1
005b6c00 : MOV dword ptr [ESP + 0x30],0x0
005b6c08 : JNZ 0x005b6c17
005b6c0a : MOV ECX,dword ptr [ESP + 0x34]
005b6c0e : TEST ECX,ECX
005b6c10 : JZ 0x005b6c17
005b6c12 : CALL 0x00503db0
005b6c17 : MOV ESI,dword ptr [ESP + 0x10]
005b6c1b : MOV dword ptr [ESP + 0x34],0x0
005b6c23 : PUSH ESI
005b6c24 : MOV ECX,EDI
005b6c26 : CALL 0x0051d570
005b6c2b : PUSH ESI
005b6c2c : MOV ECX,EDI
005b6c2e : CALL 0x0051dcd0
005b6c33 : MOV EDX,dword ptr [EBP]
005b6c36 : MOV EAX,dword ptr [EDX + 0x70]
005b6c39 : MOV ECX,EBP
005b6c3b : CALL EAX
005b6c3d : MOV ECX,EBP
005b6c3f : CALL 0x004ff7c0
005b6c44 : MOV EBP,dword ptr [ESP + 0x1c]
005b6c48 : MOV EDI,dword ptr [ESP + 0x20]
005b6c4c : JMP 0x005b6c7c
005b6c4e : TEST EAX,EAX
005b6c50 : JNZ 0x005b6c58
005b6c52 : TEST byte ptr [ESI + 0x48],0x8
005b6c56 : JMP 0x005b6c6c
005b6c58 : CMP EAX,0x1
005b6c5b : JNZ 0x005b6c63
005b6c5d : TEST byte ptr [ESI + 0x48],0x2
005b6c61 : JMP 0x005b6c6c
005b6c63 : CMP EAX,0x2
005b6c66 : JNZ 0x005b6c6e
005b6c68 : TEST byte ptr [ESI + 0x48],0x4
005b6c6c : JNZ 0x005b6c7c
005b6c6e : TEST byte ptr [ESI + 0x48],0x1
005b6c72 : JNZ 0x005b6c7c
005b6c74 : PUSH EBP
005b6c75 : MOV ECX,EBX
005b6c77 : CALL 0x005b5a10
005b6c7c : MOV EAX,dword ptr [EBX + 0x9c]
005b6c82 : INC EBP
005b6c83 : ADD EDI,0x4c
005b6c86 : MOV dword ptr [ESP + 0x1c],EBP
005b6c8a : MOV dword ptr [ESP + 0x20],EDI
005b6c8e : CMP EBP,dword ptr [EAX + 0x1c]
005b6c91 : JC 0x005b6814
005b6c97 : POP EDI
005b6c98 : POP ESI
005b6c99 : POP EBP
005b6c9a : POP EBX
005b6c9b : ADD ESP,0x58
005b6c9e : RET
