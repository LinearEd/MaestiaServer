PROGRAM  : Maestia.exe
FUNCTION : FUN_00856950
ENTRY    : 00856950
BODY     : [[00856950, 00856a76]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00856950(void)

{
  int iVar1;
  short sVar2;
  char cVar3;
  int *in_ECX;
  int iVar4;
  int *piVar5;
  undefined4 uVar6;
  
  piVar5 = in_ECX + 0x5fc;
  iVar4 = 0x21;
  do {
    if (*piVar5 != 0) {
      (**(code **)(*(int *)*piVar5 + 0x10))(*(undefined1 *)((int)in_ECX + 0x3ad));
    }
    piVar5 = piVar5 + 1;
    iVar4 = iVar4 + -1;
  } while (iVar4 != 0);
  iVar4 = in_ECX[0x62a];
  if (iVar4 != 0) {
    cVar3 = *(char *)((int)in_ECX + 0x3ad);
    *(char *)(iVar4 + 0x22) = cVar3;
    if (*(int **)(iVar4 + 0x30) != (int *)0x0) {
      if (cVar3 == '\0') {
        uVar6 = 0x80;
      }
      else {
        uVar6 = 0xff;
      }
      (**(code **)(**(int **)(iVar4 + 0x30) + 0x114))(cVar3 == '\0',uVar6);
    }
  }
  if (in_ECX[0xfe] != 0) {
    iVar4 = *DAT_00da9894;
    if ((((iVar4 == 0) || (iVar1 = *(int *)(iVar4 + 0x164), iVar1 == 0)) ||
        (*(int *)(iVar1 + 0x38) == 0)) || (*(char *)(iVar1 + 0x32) == '\0')) {
      cVar3 = *(char *)(DAT_017248cc + 0xd);
    }
    else {
      cVar3 = *(char *)(*(int *)(iVar1 + 0x38) + 0x41);
    }
    if (((in_ECX == *(int **)(DAT_0172491c + 0x17c)) || (in_ECX == *(int **)(DAT_0172491c + 0x174)))
       || (in_ECX == *(int **)(DAT_0172491c + 0x178))) {
      if (((iVar4 == 0) || (iVar4 = *(int *)(iVar4 + 0x164), iVar4 == 0)) ||
         ((*(int *)(iVar4 + 0x38) == 0 || (*(char *)(iVar4 + 0x32) == '\0')))) {
        cVar3 = *(char *)(DAT_017248cc + 0xc);
      }
      else {
        cVar3 = *(char *)(*(int *)(iVar4 + 0x38) + 0x40);
      }
    }
    if (((char)in_ECX[0x533] == '\0') || (cVar3 == '\0')) {
      uVar6 = 0;
    }
    else {
      uVar6 = 1;
    }
    (**(code **)(*in_ECX + 0x2d0))(uVar6);
    sVar2 = (short)in_ECX[0x20];
    if (sVar2 == 0) {
      sVar2 = (short)in_ECX[0x1f];
    }
    (**(code **)(*in_ECX + 1000))(sVar2);
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00856950 : PUSH EBX
00856951 : PUSH ESI
00856952 : PUSH EDI
00856953 : MOV EDI,ECX
00856955 : LEA ESI,[EDI + 0x17f0]
0085695b : MOV EBX,0x21
00856960 : CMP dword ptr [ESI],0x0
00856963 : JZ 0x00856976
00856965 : MOV ECX,dword ptr [ESI]
00856967 : MOVZX EDX,byte ptr [EDI + 0x3ad]
0085696e : MOV EAX,dword ptr [ECX]
00856970 : MOV EAX,dword ptr [EAX + 0x10]
00856973 : PUSH EDX
00856974 : CALL EAX
00856976 : ADD ESI,0x4
00856979 : SUB EBX,0x1
0085697c : JNZ 0x00856960
0085697e : MOV EAX,dword ptr [EDI + 0x18a8]
00856984 : TEST EAX,EAX
00856986 : JZ 0x008569b5
00856988 : MOV ECX,dword ptr [EAX + 0x30]
0085698b : MOV DL,byte ptr [EDI + 0x3ad]
00856991 : MOV byte ptr [EAX + 0x22],DL
00856994 : TEST ECX,ECX
00856996 : JZ 0x008569b5
00856998 : TEST DL,DL
0085699a : MOV EDX,dword ptr [ECX]
0085699c : MOV EAX,dword ptr [EDX + 0x114]
008569a2 : JZ 0x008569ac
008569a4 : PUSH 0xff
008569a9 : PUSH EBX
008569aa : JMP 0x008569b3
008569ac : PUSH 0x80
008569b1 : PUSH 0x1
008569b3 : CALL EAX
008569b5 : CMP dword ptr [EDI + 0x3f8],0x0
008569bc : JZ 0x00856a73
008569c2 : MOV ECX,dword ptr [0x00da9894]
008569c8 : MOV EDX,dword ptr [ECX]
008569ca : MOV ESI,dword ptr [0x017248cc]
008569d0 : TEST EDX,EDX
008569d2 : JZ 0x008569f0
008569d4 : MOV EAX,dword ptr [EDX + 0x164]
008569da : TEST EAX,EAX
008569dc : JZ 0x008569f0
008569de : MOV ECX,dword ptr [EAX + 0x38]
008569e1 : TEST ECX,ECX
008569e3 : JZ 0x008569f0
008569e5 : CMP byte ptr [EAX + 0x32],0x0
008569e9 : JZ 0x008569f0
008569eb : MOV CL,byte ptr [ECX + 0x41]
008569ee : JMP 0x008569f3
008569f0 : MOV CL,byte ptr [ESI + 0xd]
008569f3 : MOV EAX,[0x0172491c]
008569f8 : CMP EDI,dword ptr [EAX + 0x17c]
008569fe : JZ 0x00856a10
00856a00 : CMP EDI,dword ptr [EAX + 0x174]
00856a06 : JZ 0x00856a10
00856a08 : CMP EDI,dword ptr [EAX + 0x178]
00856a0e : JNZ 0x00856a33
00856a10 : TEST EDX,EDX
00856a12 : JZ 0x00856a30
00856a14 : MOV EAX,dword ptr [EDX + 0x164]
00856a1a : TEST EAX,EAX
00856a1c : JZ 0x00856a30
00856a1e : MOV ECX,dword ptr [EAX + 0x38]
00856a21 : TEST ECX,ECX
00856a23 : JZ 0x00856a30
00856a25 : CMP byte ptr [EAX + 0x32],0x0
00856a29 : JZ 0x00856a30
00856a2b : MOV CL,byte ptr [ECX + 0x40]
00856a2e : JMP 0x00856a33
00856a30 : MOV CL,byte ptr [ESI + 0xc]
00856a33 : CMP byte ptr [EDI + 0x14cc],0x0
00856a3a : JZ 0x00856a44
00856a3c : TEST CL,CL
00856a3e : JZ 0x00856a44
00856a40 : MOV AL,0x1
00856a42 : JMP 0x00856a46
00856a44 : XOR AL,AL
00856a46 : MOV EDX,dword ptr [EDI]
00856a48 : PUSH EAX
00856a49 : MOV EAX,dword ptr [EDX + 0x2d0]
00856a4f : MOV ECX,EDI
00856a51 : CALL EAX
00856a53 : MOVZX EAX,word ptr [EDI + 0x80]
00856a5a : TEST AX,AX
00856a5d : MOVZX EAX,AX
00856a60 : JNZ 0x00856a66
00856a62 : MOVZX EAX,word ptr [EDI + 0x7c]
00856a66 : MOV EDX,dword ptr [EDI]
00856a68 : PUSH EAX
00856a69 : MOV EAX,dword ptr [EDX + 0x3e8]
00856a6f : MOV ECX,EDI
00856a71 : CALL EAX
00856a73 : POP EDI
00856a74 : POP ESI
00856a75 : POP EBX
00856a76 : RET
