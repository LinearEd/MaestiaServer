PROGRAM  : Maestia.exe
FUNCTION : do_put
ENTRY    : 006309d8
BODY     : [[006309d8, 00630ac5]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Function: __EH_prolog3_GS replaced with injection: EH_prolog3 */
/* Library Function - Single Match
    protected: virtual class std::ostreambuf_iterator<char,struct std::char_traits<char> >
   __thiscall std::time_put<char,class std::ostreambuf_iterator<char,struct std::char_traits<char> >
   >::do_put(class std::ostreambuf_iterator<char,struct std::char_traits<char> >,class std::ios_base
   &,char,struct tm const *,char,char)const 
   
   Library: Visual Studio 2008 Release */

void __thiscall
std::time_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_>_>::do_put
          (time_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_>_> *this
          ,undefined4 *param_2,undefined4 param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6,tm *param_7,undefined1 param_8,char param_9)

{
  void *pvVar1;
  char *pcVar2;
  size_t sVar3;
  undefined4 *puVar4;
  undefined1 *puVar5;
  int iVar6;
  undefined1 local_50 [8];
  undefined4 *local_48;
  undefined4 local_44;
  size_t local_40;
  tm *local_3c;
  size_t local_24;
  char local_1c [20];
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x40;
  local_8 = 0x6309e4;
  builtin_strncpy(local_1c,"!%x",4);
  local_48 = param_2;
  local_3c = param_7;
  local_1c[4] = 0;
  FUN_0040eea0();
  local_8 = 0;
  if (param_9 == '\0') {
    local_1c[2] = param_8;
  }
  else {
    local_1c[2] = param_9;
    local_1c[3] = param_8;
  }
  iVar6 = 0x10;
  while( true ) {
    FUN_004d12b0(iVar6,0);
    pvVar1 = *(void **)(this + 8);
    local_40 = local_24;
    FUN_00438b10(local_50);
    pcVar2 = (char *)FUN_00412cf0();
    sVar3 = __Strftime(pcVar2,local_40,local_1c,local_3c,pvVar1);
    if (sVar3 != 0) break;
    iVar6 = iVar6 * 2;
  }
  puVar4 = (undefined4 *)FUN_00438b10(local_50);
  local_44 = *puVar4;
  local_40 = puVar4[1];
  while (sVar3 = sVar3 - 1, sVar3 != 0) {
    _String_const_iterator<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
    operator++((_String_const_iterator<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                *)&local_44);
    puVar5 = (undefined1 *)FUN_00412cf0();
    local_3c = (tm *)CONCAT31(local_3c._1_3_,*puVar5);
    FUN_004d3bf0(local_3c);
  }
  *local_48 = param_3;
  local_48[1] = param_4;
  FUN_00405260(1,0);
  FUN_00640ed0();
  return;
}



============================================================
DISASSEMBLY
============================================================
006309d8 : PUSH 0x40
006309da : MOV EAX,0xb0c159
006309df : CALL 0x00640e86
006309e4 : MOV EAX,dword ptr [EBP + 0x8]
006309e7 : MOV ESI,0xb95e5c
006309ec : LEA EDI,[EBP + -0x18]
006309ef : MOVSD ES:EDI,ESI
006309f0 : MOV dword ptr [EBP + -0x44],EAX
006309f3 : MOV EAX,dword ptr [EBP + 0x1c]
006309f6 : MOV EBX,ECX
006309f8 : LEA ECX,[EBP + -0x34]
006309fb : MOV dword ptr [EBP + -0x38],EAX
006309fe : MOVSB ES:EDI,ESI
006309ff : CALL 0x0040eea0
00630a04 : MOV AL,byte ptr [EBP + 0x24]
00630a07 : AND dword ptr [EBP + -0x4],0x0
00630a0b : TEST AL,AL
00630a0d : JNZ 0x00630a17
00630a0f : MOV AL,byte ptr [EBP + 0x20]
00630a12 : MOV byte ptr [EBP + -0x16],AL
00630a15 : JMP 0x00630a20
00630a17 : MOV byte ptr [EBP + -0x16],AL
00630a1a : MOV AL,byte ptr [EBP + 0x20]
00630a1d : MOV byte ptr [EBP + -0x15],AL
00630a20 : PUSH 0x10
00630a22 : POP ESI
00630a23 : JMP 0x00630a27
00630a25 : ADD ESI,ESI
00630a27 : PUSH 0x0
00630a29 : PUSH ESI
00630a2a : LEA ECX,[EBP + -0x34]
00630a2d : CALL 0x004d12b0
00630a32 : MOV EAX,dword ptr [EBP + -0x20]
00630a35 : MOV EDI,dword ptr [EBX + 0x8]
00630a38 : MOV dword ptr [EBP + -0x3c],EAX
00630a3b : LEA EAX,[EBP + -0x4c]
00630a3e : PUSH EAX
00630a3f : LEA ECX,[EBP + -0x34]
00630a42 : CALL 0x00438b10
00630a47 : MOV ECX,EAX
00630a49 : CALL 0x00412cf0
00630a4e : PUSH EDI
00630a4f : PUSH dword ptr [EBP + -0x38]
00630a52 : LEA ECX,[EBP + -0x18]
00630a55 : PUSH ECX
00630a56 : PUSH dword ptr [EBP + -0x3c]
00630a59 : PUSH EAX
00630a5a : CALL 0x00644baf
00630a5f : MOV EDI,EAX
00630a61 : ADD ESP,0x14
00630a64 : TEST EDI,EDI
00630a66 : JBE 0x00630a25
00630a68 : LEA EAX,[EBP + -0x4c]
00630a6b : PUSH EAX
00630a6c : LEA ECX,[EBP + -0x34]
00630a6f : CALL 0x00438b10
00630a74 : MOV ECX,dword ptr [EAX]
00630a76 : MOV dword ptr [EBP + -0x40],ECX
00630a79 : MOV EAX,dword ptr [EAX + 0x4]
00630a7c : MOV dword ptr [EBP + -0x3c],EAX
00630a7f : JMP 0x00630aa0
00630a81 : LEA ECX,[EBP + -0x40]
00630a84 : CALL 0x0063066c
00630a89 : MOV ECX,EAX
00630a8b : CALL 0x00412cf0
00630a90 : MOV AL,byte ptr [EAX]
00630a92 : MOV byte ptr [EBP + -0x38],AL
00630a95 : PUSH dword ptr [EBP + -0x38]
00630a98 : LEA ECX,[EBP + 0xc]
00630a9b : CALL 0x004d3bf0
00630aa0 : DEC EDI
00630aa1 : JNZ 0x00630a81
00630aa3 : MOV EAX,dword ptr [EBP + 0xc]
00630aa6 : MOV ESI,dword ptr [EBP + -0x44]
00630aa9 : MOV dword ptr [ESI],EAX
00630aab : MOV EAX,dword ptr [EBP + 0x10]
00630aae : PUSH EDI
00630aaf : PUSH 0x1
00630ab1 : LEA ECX,[EBP + -0x34]
00630ab4 : MOV dword ptr [ESI + 0x4],EAX
00630ab7 : CALL 0x00405260
00630abc : MOV EAX,ESI
00630abe : CALL 0x00640ed0
00630ac3 : RET 0x20
