PROGRAM  : Maestia.exe
FUNCTION : FUN_005aae10
ENTRY    : 005aae10
BODY     : [[005aae10, 005ab0bd]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_005aae10(int param_1,uint param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  byte bVar10;
  int in_ECX;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  int iVar14;
  uint local_20;
  uint local_18;
  int local_14;
  uint local_10;
  
  piVar1 = (int *)(in_ECX + 0x1c + param_1 * 0xc);
  iVar9 = piVar1[1];
  iVar2 = *piVar1;
  bVar4 = (byte)*(undefined4 *)(in_ECX + 0xc);
  bVar10 = bVar4 + 3;
  iVar3 = *(int *)(in_ECX + 8);
  local_14 = 0;
  uVar13 = param_2 >> (bVar4 & 0x1f);
  iVar14 = (iVar2 - ((((uint)(iVar9 + -1 + iVar3 * 8) >> (bVar10 & 0x1f)) - 1) + iVar3 &
                    ~(iVar3 - 1U))) + iVar9;
  uVar6 = iVar9 - ((((uint)(iVar9 + -1 + iVar3 * 8) >> (bVar10 & 0x1f)) - 1) + iVar3 & ~(iVar3 - 1U)
                  ) >> ((byte)*(undefined4 *)(in_ECX + 0xc) & 0x1f);
  local_20 = 0;
  local_10 = 0xffffffff;
  local_18 = 0xffffffff;
  if (uVar6 != 0) {
    do {
      uVar7 = local_20 >> 5;
      uVar11 = local_20 & 0x1f;
      if ((*(uint *)(iVar14 + uVar7 * 4) >> (sbyte)uVar11 & 1) == 0) {
        uVar12 = *(uint *)(iVar14 + uVar7 * 4) | *(uint *)(&DAT_00b952c8 + uVar11 * 4);
        if (uVar12 == *(uint *)(&DAT_00b952c8 + uVar11 * 4)) {
          iVar8 = uVar7 + 1;
          iVar5 = -uVar11;
          iVar9 = *(int *)(iVar14 + iVar8 * 4);
          while (iVar5 = iVar5 + 0x20, iVar9 == 0) {
            iVar8 = iVar8 + 1;
            iVar9 = *(int *)(iVar14 + iVar8 * 4);
          }
          uVar7 = *(uint *)(iVar14 + iVar8 * 4);
          if ((uVar7 & 0xffff) == 0) {
            if ((uVar7 & 0xff0000) == 0) {
              uVar7 = (byte)(&DAT_00b953c8)[uVar7 >> 0x18] + 0x18;
            }
            else {
              uVar7 = (byte)(&DAT_00b953c8)[uVar7 >> 0x10 & 0xff] + 0x10;
            }
          }
          else if ((uVar7 & 0xff) == 0) {
            uVar7 = (byte)(&DAT_00b953c8)[uVar7 >> 8 & 0xff] + 8;
          }
          else {
            uVar7 = (uint)(byte)(&DAT_00b953c8)[uVar7 & 0xff];
          }
          uVar7 = iVar5 + uVar7;
        }
        else {
          uVar12 = uVar12 >> (sbyte)uVar11;
          if ((uVar12 & 0xffff) == 0) {
            if ((uVar12 & 0xff0000) == 0) {
              uVar7 = (byte)(&DAT_00b953c8)[uVar12 >> 0x18] + 0x18;
            }
            else {
              uVar7 = (byte)(&DAT_00b953c8)[uVar12 >> 0x10 & 0xff] + 0x10;
            }
          }
          else if ((uVar12 & 0xff) == 0) {
            uVar7 = (byte)(&DAT_00b953c8)[uVar12 >> 8 & 0xff] + 8;
          }
          else {
            uVar7 = (uint)(byte)(&DAT_00b953c8)[uVar12 & 0xff];
          }
        }
        iVar9 = iVar3 * local_20 + iVar2;
        if ((((iVar9 + -1 + param_3 & ~(param_3 - 1U)) + param_2 <= iVar3 * uVar7 + iVar9) &&
            (uVar7 - uVar13 < local_10)) &&
           (local_18 = local_20, local_10 = uVar7 - uVar13, *(char *)(in_ECX + 0x1a4) == '\0'))
        break;
      }
      else {
        uVar7 = FUN_005aa8b0(iVar14,local_20,uVar6);
      }
      local_20 = local_20 + uVar7;
    } while (local_20 < uVar6);
    if (local_18 != 0xffffffff) {
      iVar9 = ((int)(((iVar3 * local_18 + iVar2 + -1 + param_3 & ~(param_3 - 1U)) - iVar3 * local_18
                     ) - iVar2) >> ((byte)*(undefined4 *)(in_ECX + 0xc) & 0x1f)) + local_18;
      local_14 = (**(code **)(**(int **)(in_ECX + 4) + 0xc))(iVar9 * iVar3 + iVar2,param_2);
      if (local_14 != 0) {
        FUN_005aa720(iVar14,iVar9,uVar13);
        piVar1[2] = piVar1[2] + uVar13;
        *(int *)(in_ECX + 0x18) =
             *(int *)(in_ECX + 0x18) + (uVar13 << ((byte)*(undefined4 *)(in_ECX + 0xc) & 0x1f));
        goto LAB_005ab0a1;
      }
    }
  }
  param_1 = -1;
LAB_005ab0a1:
  *(int *)(in_ECX + 0x1a0) = param_1;
  *(uint *)(in_ECX + 0x1a8) = local_14 + param_2;
  return;
}



============================================================
DISASSEMBLY
============================================================
005aae10 : SUB ESP,0x20
005aae13 : MOV EAX,dword ptr [ESP + 0x24]
005aae17 : PUSH EBX
005aae18 : PUSH EBP
005aae19 : MOV EBP,ECX
005aae1b : MOV EBX,dword ptr [EBP + 0xc]
005aae1e : LEA EAX,[EAX + EAX*0x2]
005aae21 : LEA ECX,[EBP + EAX*0x4 + 0x1c]
005aae25 : MOV EAX,dword ptr [ECX + 0x4]
005aae28 : MOV dword ptr [ESP + 0x24],ECX
005aae2c : MOV ECX,dword ptr [ECX]
005aae2e : MOV dword ptr [ESP + 0xc],ECX
005aae32 : LEA EDX,[EBX + 0x3]
005aae35 : PUSH ESI
005aae36 : MOV ESI,dword ptr [EBP + 0x8]
005aae39 : PUSH EDI
005aae3a : MOV ECX,EDX
005aae3c : LEA EDI,[EAX + ESI*0x8 + -0x1]
005aae40 : SHR EDI,CL
005aae42 : MOV dword ptr [ESP + 0x1c],0x0
005aae4a : LEA ECX,[EDI + ESI*0x1 + -0x1]
005aae4e : LEA EDI,[ESI + -0x1]
005aae51 : NOT EDI
005aae53 : AND ECX,EDI
005aae55 : MOV EDI,dword ptr [ESP + 0x14]
005aae59 : SUB EDI,ECX
005aae5b : MOV ECX,EBX
005aae5d : MOV EBX,dword ptr [ESP + 0x38]
005aae61 : SHR EBX,CL
005aae63 : MOV ECX,EDX
005aae65 : ADD EDI,EAX
005aae67 : MOV dword ptr [ESP + 0x28],EBX
005aae6b : LEA EBX,[EAX + ESI*0x8 + -0x1]
005aae6f : SHR EBX,CL
005aae71 : LEA ECX,[ESI + -0x1]
005aae74 : NOT ECX
005aae76 : LEA EDX,[EBX + ESI*0x1 + -0x1]
005aae7a : AND EDX,ECX
005aae7c : MOV ECX,dword ptr [EBP + 0xc]
005aae7f : SUB EAX,EDX
005aae81 : SHR EAX,CL
005aae83 : OR ECX,0xffffffff
005aae86 : XOR EBX,EBX
005aae88 : MOV dword ptr [ESP + 0x10],EBX
005aae8c : MOV dword ptr [ESP + 0x24],EAX
005aae90 : MOV dword ptr [ESP + 0x20],ECX
005aae94 : MOV dword ptr [ESP + 0x18],ECX
005aae98 : TEST EAX,EAX
005aae9a : JBE 0x005ab09a
005aaea0 : MOV EAX,EBX
005aaea2 : SHR EAX,0x5
005aaea5 : MOV EDX,dword ptr [EDI + EAX*0x4]
005aaea8 : MOV ECX,EBX
005aaeaa : AND ECX,0x1f
005aaead : SHR EDX,CL
005aaeaf : TEST DL,0x1
005aaeb2 : JZ 0x005aaece
005aaeb4 : MOV EAX,dword ptr [ESP + 0x24]
005aaeb8 : PUSH EAX
005aaeb9 : PUSH EBX
005aaeba : PUSH EDI
005aaebb : CALL 0x005aa8b0
005aaec0 : ADD ESP,0xc
005aaec3 : ADD EBX,EAX
005aaec5 : MOV dword ptr [ESP + 0x10],EBX
005aaec9 : JMP 0x005ab015
005aaece : MOV EBX,dword ptr [ECX*0x4 + 0xb952c8]
005aaed5 : MOV EDX,dword ptr [EDI + EAX*0x4]
005aaed8 : OR EDX,EBX
005aaeda : CMP EDX,EBX
005aaedc : JZ 0x005aaf4b
005aaede : SHR EDX,CL
005aaee0 : MOV EAX,EDX
005aaee2 : MOVZX ECX,AX
005aaee5 : TEST ECX,ECX
005aaee7 : JZ 0x005aaf1a
005aaee9 : MOV ECX,EAX
005aaeeb : AND ECX,0xff
005aaef1 : JZ 0x005aaf01
005aaef3 : MOVZX EAX,byte ptr [ECX + 0xb953c8]
005aaefa : MOV EDX,EAX
005aaefc : JMP 0x005aafc5
005aaf01 : SHR EAX,0x8
005aaf04 : AND EAX,0xff
005aaf09 : MOVZX EAX,byte ptr [EAX + 0xb953c8]
005aaf10 : ADD EAX,0x8
005aaf13 : MOV EDX,EAX
005aaf15 : JMP 0x005aafc5
005aaf1a : TEST EAX,0xff0000
005aaf1f : JZ 0x005aaf3a
005aaf21 : SHR EAX,0x10
005aaf24 : AND EAX,0xff
005aaf29 : MOVZX EAX,byte ptr [EAX + 0xb953c8]
005aaf30 : ADD EAX,0x10
005aaf33 : MOV EDX,EAX
005aaf35 : JMP 0x005aafc5
005aaf3a : SHR EAX,0x18
005aaf3d : MOVZX EAX,byte ptr [EAX + 0xb953c8]
005aaf44 : ADD EAX,0x18
005aaf47 : MOV EDX,EAX
005aaf49 : JMP 0x005aafc5
005aaf4b : MOV EDX,0x20
005aaf50 : INC EAX
005aaf51 : SUB EDX,ECX
005aaf53 : CMP dword ptr [EDI + EAX*0x4],0x0
005aaf57 : JNZ 0x005aaf6a
005aaf59 : LEA ESP,[ESP]
005aaf60 : INC EAX
005aaf61 : ADD EDX,0x20
005aaf64 : CMP dword ptr [EDI + EAX*0x4],0x0
005aaf68 : JZ 0x005aaf60
005aaf6a : MOV EAX,dword ptr [EDI + EAX*0x4]
005aaf6d : MOVZX ECX,AX
005aaf70 : TEST ECX,ECX
005aaf72 : JZ 0x005aaf9b
005aaf74 : MOV ECX,EAX
005aaf76 : AND ECX,0xff
005aaf7c : JZ 0x005aaf87
005aaf7e : MOVZX EAX,byte ptr [ECX + 0xb953c8]
005aaf85 : JMP 0x005aafc3
005aaf87 : SHR EAX,0x8
005aaf8a : AND EAX,0xff
005aaf8f : MOVZX EAX,byte ptr [EAX + 0xb953c8]
005aaf96 : ADD EAX,0x8
005aaf99 : JMP 0x005aafc3
005aaf9b : TEST EAX,0xff0000
005aafa0 : JZ 0x005aafb6
005aafa2 : SHR EAX,0x10
005aafa5 : AND EAX,0xff
005aafaa : MOVZX EAX,byte ptr [EAX + 0xb953c8]
005aafb1 : ADD EAX,0x10
005aafb4 : JMP 0x005aafc3
005aafb6 : SHR EAX,0x18
005aafb9 : MOVZX EAX,byte ptr [EAX + 0xb953c8]
005aafc0 : ADD EAX,0x18
005aafc3 : ADD EDX,EAX
005aafc5 : MOV ECX,dword ptr [ESP + 0x3c]
005aafc9 : MOV EAX,ESI
005aafcb : IMUL EAX,dword ptr [ESP + 0x10]
005aafd0 : ADD EAX,dword ptr [ESP + 0x14]
005aafd4 : LEA EBX,[EAX + ECX*0x1 + -0x1]
005aafd8 : DEC ECX
005aafd9 : NOT ECX
005aafdb : AND EBX,ECX
005aafdd : ADD EBX,dword ptr [ESP + 0x38]
005aafe1 : MOV ECX,ESI
005aafe3 : IMUL ECX,EDX
005aafe6 : ADD ECX,EAX
005aafe8 : CMP EBX,ECX
005aafea : JA 0x005ab00d
005aafec : MOV EAX,EDX
005aafee : SUB EAX,dword ptr [ESP + 0x28]
005aaff2 : CMP EAX,dword ptr [ESP + 0x20]
005aaff6 : JNC 0x005ab00d
005aaff8 : CMP byte ptr [EBP + 0x1a4],0x0
005aafff : MOV ECX,dword ptr [ESP + 0x10]
005ab003 : MOV dword ptr [ESP + 0x18],ECX
005ab007 : MOV dword ptr [ESP + 0x20],EAX
005ab00b : JZ 0x005ab01f
005ab00d : ADD dword ptr [ESP + 0x10],EDX
005ab011 : MOV EBX,dword ptr [ESP + 0x10]
005ab015 : CMP EBX,dword ptr [ESP + 0x24]
005ab019 : JC 0x005aaea0
005ab01f : MOV EAX,dword ptr [ESP + 0x18]
005ab023 : CMP EAX,-0x1
005ab026 : JZ 0x005ab09a
005ab028 : MOV EBX,dword ptr [ESP + 0x14]
005ab02c : MOV EDX,dword ptr [ESP + 0x3c]
005ab030 : MOV ECX,ESI
005ab032 : IMUL ECX,EAX
005ab035 : LEA EAX,[ECX + EBX*0x1]
005ab038 : LEA EAX,[EAX + EDX*0x1 + -0x1]
005ab03c : DEC EDX
005ab03d : NOT EDX
005ab03f : AND EAX,EDX
005ab041 : SUB EAX,ECX
005ab043 : MOV ECX,dword ptr [EBP + 0xc]
005ab046 : SUB EAX,EBX
005ab048 : SAR EAX,CL
005ab04a : MOV ECX,dword ptr [ESP + 0x18]
005ab04e : LEA EBX,[EAX + ECX*0x1]
005ab051 : MOV EAX,dword ptr [ESP + 0x38]
005ab055 : MOV ECX,dword ptr [EBP + 0x4]
005ab058 : MOV EDX,dword ptr [ECX]
005ab05a : MOV EDX,dword ptr [EDX + 0xc]
005ab05d : PUSH EAX
005ab05e : MOV EAX,EBX
005ab060 : IMUL EAX,ESI
005ab063 : ADD EAX,dword ptr [ESP + 0x18]
005ab067 : PUSH EAX
005ab068 : CALL EDX
005ab06a : MOV dword ptr [ESP + 0x1c],EAX
005ab06e : TEST EAX,EAX
005ab070 : JZ 0x005ab09e
005ab072 : MOV ESI,dword ptr [ESP + 0x28]
005ab076 : PUSH ESI
005ab077 : PUSH EBX
005ab078 : PUSH EDI
005ab079 : CALL 0x005aa720
005ab07e : MOV EAX,dword ptr [ESP + 0x38]
005ab082 : ADD dword ptr [EAX + 0x8],ESI
005ab085 : MOV ECX,dword ptr [EBP + 0xc]
005ab088 : MOV EAX,dword ptr [ESP + 0x28]
005ab08c : SHL ESI,CL
005ab08e : MOV ECX,dword ptr [ESP + 0x40]
005ab092 : ADD ESP,0xc
005ab095 : ADD dword ptr [EBP + 0x18],ESI
005ab098 : JMP 0x005ab0a1
005ab09a : MOV EAX,dword ptr [ESP + 0x1c]
005ab09e : OR ECX,0xffffffff
005ab0a1 : MOV dword ptr [EBP + 0x1a0],ECX
005ab0a7 : MOV ECX,dword ptr [ESP + 0x38]
005ab0ab : POP EDI
005ab0ac : LEA EDX,[EAX + ECX*0x1]
005ab0af : POP ESI
005ab0b0 : MOV dword ptr [EBP + 0x1a8],EDX
005ab0b6 : POP EBP
005ab0b7 : POP EBX
005ab0b8 : ADD ESP,0x20
005ab0bb : RET 0xc
