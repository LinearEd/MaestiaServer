PROGRAM  : Maestia.exe
FUNCTION : _memcpy
ENTRY    : 0063ae40
BODY     : [[0063ae40, 0063aea2] [0063aea4, 0063aec2] [0063aec4, 0063aeca] [0063aed8, 0063af00] [0063af04, 0063af26] [0063af28, 0063af44] [0063af68, 0063afb1] [0063afc4, 0063afca] [0063afcc, 0063afd6] [0063afd8, 0063afe8] [0063afec, 0063b002] [0063b004, 0063b029] [0063b02c, 0063b034] [0063b038, 0063b056] [0063b064, 0063b084] [0063b088, 0063b0ae] [0063b0b0, 0063b0e0] [0063b104, 0063b14d] [0063b160, 0063b166] [0063b168, 0063b174] [0063b178, 0063b18a] [0063b18c, 0063b1a4]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    _memcpy
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
   Studio 2008 Release */

void * __cdecl _memcpy(void *_Dst,void *_Src,size_t _Size)

{
  void *pvVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar4 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar5 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar5 & 3) == 0) {
      uVar2 = _Size >> 2;
      uVar3 = _Size & 3;
      if (7 < uVar2) {
        for (; uVar2 != 0; uVar2 = uVar2 - 1) {
          *puVar5 = *puVar4;
          puVar4 = puVar4 + -1;
          puVar5 = puVar5 + -1;
        }
        switch(uVar3) {
        case 0:
          return _Dst;
        case 2:
          goto switchD_0063b023_caseD_2;
        case 3:
          goto switchD_0063b023_caseD_3;
        }
        goto switchD_0063b023_caseD_1;
      }
    }
    else {
      switch(_Size) {
      case 0:
        goto switchD_0063b023_caseD_0;
      case 1:
        goto switchD_0063b023_caseD_1;
      case 2:
        goto switchD_0063b023_caseD_2;
      case 3:
        goto switchD_0063b023_caseD_3;
      default:
        uVar2 = _Size - ((uint)puVar5 & 3);
        switch((uint)puVar5 & 3) {
        case 1:
          uVar3 = uVar2 & 3;
          *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
          puVar4 = (undefined4 *)((int)puVar4 + -1);
          uVar2 = uVar2 >> 2;
          puVar5 = (undefined4 *)((int)puVar5 - 1);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar5 = *puVar4;
              puVar4 = puVar4 + -1;
              puVar5 = puVar5 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_0063b023_caseD_2;
            case 3:
              goto switchD_0063b023_caseD_3;
            }
            goto switchD_0063b023_caseD_1;
          }
          break;
        case 2:
          uVar3 = uVar2 & 3;
          *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
          uVar2 = uVar2 >> 2;
          *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
          puVar4 = (undefined4 *)((int)puVar4 + -2);
          puVar5 = (undefined4 *)((int)puVar5 - 2);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar5 = *puVar4;
              puVar4 = puVar4 + -1;
              puVar5 = puVar5 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_0063b023_caseD_2;
            case 3:
              goto switchD_0063b023_caseD_3;
            }
            goto switchD_0063b023_caseD_1;
          }
          break;
        case 3:
          uVar3 = uVar2 & 3;
          *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
          *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
          uVar2 = uVar2 >> 2;
          *(undefined1 *)((int)puVar5 + 1) = *(undefined1 *)((int)puVar4 + 1);
          puVar4 = (undefined4 *)((int)puVar4 + -3);
          puVar5 = (undefined4 *)((int)puVar5 - 3);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar5 = *puVar4;
              puVar4 = puVar4 + -1;
              puVar5 = puVar5 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_0063b023_caseD_2;
            case 3:
              goto switchD_0063b023_caseD_3;
            }
            goto switchD_0063b023_caseD_1;
          }
        }
      }
    }
    switch(uVar2) {
    case 7:
      puVar5[7 - uVar2] = puVar4[7 - uVar2];
    case 6:
      puVar5[6 - uVar2] = puVar4[6 - uVar2];
    case 5:
      puVar5[5 - uVar2] = puVar4[5 - uVar2];
    case 4:
      puVar5[4 - uVar2] = puVar4[4 - uVar2];
    case 3:
      puVar5[3 - uVar2] = puVar4[3 - uVar2];
    case 2:
      puVar5[2 - uVar2] = puVar4[2 - uVar2];
    case 1:
      puVar5[1 - uVar2] = puVar4[1 - uVar2];
      puVar4 = puVar4 + -uVar2;
      puVar5 = puVar5 + -uVar2;
    }
    switch(uVar3) {
    case 1:
switchD_0063b023_caseD_1:
      *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
      return _Dst;
    case 2:
switchD_0063b023_caseD_2:
      *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
      *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
      return _Dst;
    case 3:
switchD_0063b023_caseD_3:
      *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
      *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
      *(undefined1 *)((int)puVar5 + 1) = *(undefined1 *)((int)puVar4 + 1);
      return _Dst;
    }
switchD_0063b023_caseD_0:
    return _Dst;
  }
  if (((0xff < _Size) && (DAT_01728c2c != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {
    pvVar1 = (void *)__VEC_memcpy();
    return pvVar1;
  }
  puVar4 = _Dst;
  if (((uint)_Dst & 3) == 0) {
    uVar2 = _Size >> 2;
    uVar3 = _Size & 3;
    if (7 < uVar2) {
      for (; uVar2 != 0; uVar2 = uVar2 - 1) {
        *puVar4 = *(undefined4 *)_Src;
        _Src = (undefined4 *)((int)_Src + 4);
        puVar4 = puVar4 + 1;
      }
      switch(uVar3) {
      case 0:
        return _Dst;
      case 2:
        goto switchD_0063ae9c_caseD_2;
      case 3:
        goto switchD_0063ae9c_caseD_3;
      }
      goto switchD_0063ae9c_caseD_1;
    }
  }
  else {
    switch(_Size) {
    case 0:
      goto switchD_0063ae9c_caseD_0;
    case 1:
      goto switchD_0063ae9c_caseD_1;
    case 2:
      goto switchD_0063ae9c_caseD_2;
    case 3:
      goto switchD_0063ae9c_caseD_3;
    default:
      uVar2 = (_Size - 4) + ((uint)_Dst & 3);
      switch((uint)_Dst & 3) {
      case 1:
        uVar3 = uVar2 & 3;
        *(undefined1 *)_Dst = *(undefined1 *)_Src;
        *(undefined1 *)((int)_Dst + 1) = *(undefined1 *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        *(undefined1 *)((int)_Dst + 2) = *(undefined1 *)((int)_Src + 2);
        _Src = (void *)((int)_Src + 3);
        puVar4 = (undefined4 *)((int)_Dst + 3);
        if (7 < uVar2) {
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar4 = *(undefined4 *)_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar4 = puVar4 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_0063ae9c_caseD_2;
          case 3:
            goto switchD_0063ae9c_caseD_3;
          }
          goto switchD_0063ae9c_caseD_1;
        }
        break;
      case 2:
        uVar3 = uVar2 & 3;
        *(undefined1 *)_Dst = *(undefined1 *)_Src;
        uVar2 = uVar2 >> 2;
        *(undefined1 *)((int)_Dst + 1) = *(undefined1 *)((int)_Src + 1);
        _Src = (void *)((int)_Src + 2);
        puVar4 = (undefined4 *)((int)_Dst + 2);
        if (7 < uVar2) {
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar4 = *(undefined4 *)_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar4 = puVar4 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_0063ae9c_caseD_2;
          case 3:
            goto switchD_0063ae9c_caseD_3;
          }
          goto switchD_0063ae9c_caseD_1;
        }
        break;
      case 3:
        uVar3 = uVar2 & 3;
        *(undefined1 *)_Dst = *(undefined1 *)_Src;
        _Src = (void *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        puVar4 = (undefined4 *)((int)_Dst + 1);
        if (7 < uVar2) {
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar4 = *(undefined4 *)_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar4 = puVar4 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_0063ae9c_caseD_2;
          case 3:
            goto switchD_0063ae9c_caseD_3;
          }
          goto switchD_0063ae9c_caseD_1;
        }
      }
    }
  }
  switch(uVar2) {
  case 7:
    puVar4[uVar2 - 7] = *(undefined4 *)((int)_Src + (uVar2 - 7) * 4);
  case 6:
    puVar4[uVar2 - 6] = *(undefined4 *)((int)_Src + (uVar2 - 6) * 4);
  case 5:
    puVar4[uVar2 - 5] = *(undefined4 *)((int)_Src + (uVar2 - 5) * 4);
  case 4:
    puVar4[uVar2 - 4] = *(undefined4 *)((int)_Src + (uVar2 - 4) * 4);
  case 3:
    puVar4[uVar2 - 3] = *(undefined4 *)((int)_Src + (uVar2 - 3) * 4);
  case 2:
    puVar4[uVar2 - 2] = *(undefined4 *)((int)_Src + (uVar2 - 2) * 4);
  case 1:
    puVar4[uVar2 - 1] = *(undefined4 *)((int)_Src + (uVar2 - 1) * 4);
    _Src = (void *)((int)_Src + uVar2 * 4);
    puVar4 = puVar4 + uVar2;
  }
  switch(uVar3) {
  case 1:
switchD_0063ae9c_caseD_1:
    *(undefined1 *)puVar4 = *(undefined1 *)_Src;
    return _Dst;
  case 2:
switchD_0063ae9c_caseD_2:
    *(undefined1 *)puVar4 = *(undefined1 *)_Src;
    *(undefined1 *)((int)puVar4 + 1) = *(undefined1 *)((int)_Src + 1);
    return _Dst;
  case 3:
switchD_0063ae9c_caseD_3:
    *(undefined1 *)puVar4 = *(undefined1 *)_Src;
    *(undefined1 *)((int)puVar4 + 1) = *(undefined1 *)((int)_Src + 1);
    *(undefined1 *)((int)puVar4 + 2) = *(undefined1 *)((int)_Src + 2);
    return _Dst;
  }
switchD_0063ae9c_caseD_0:
  return _Dst;
}



============================================================
DISASSEMBLY
============================================================
0063ae40 : PUSH EBP
0063ae41 : MOV EBP,ESP
0063ae43 : PUSH EDI
0063ae44 : PUSH ESI
0063ae45 : MOV ESI,dword ptr [EBP + 0xc]
0063ae48 : MOV ECX,dword ptr [EBP + 0x10]
0063ae4b : MOV EDI,dword ptr [EBP + 0x8]
0063ae4e : MOV EAX,ECX
0063ae50 : MOV EDX,ECX
0063ae52 : ADD EAX,ESI
0063ae54 : CMP EDI,ESI
0063ae56 : JBE 0x0063ae60
0063ae58 : CMP EDI,EAX
0063ae5a : JC 0x0063b004
0063ae60 : CMP ECX,0x100
0063ae66 : JC 0x0063ae87
0063ae68 : CMP dword ptr [0x01728c2c],0x0
0063ae6f : JZ 0x0063ae87
0063ae71 : PUSH EDI
0063ae72 : PUSH ESI
0063ae73 : AND EDI,0xf
0063ae76 : AND ESI,0xf
0063ae79 : CMP EDI,ESI
0063ae7b : POP ESI
0063ae7c : POP EDI
0063ae7d : JNZ 0x0063ae87
0063ae7f : POP ESI
0063ae80 : POP EDI
0063ae81 : POP EBP
0063ae82 : JMP 0x0065032b
0063ae87 : TEST EDI,0x3
0063ae8d : JNZ 0x0063aea4
0063ae8f : SHR ECX,0x2
0063ae92 : AND EDX,0x3
0063ae95 : CMP ECX,0x8
0063ae98 : JC 0x0063aec4
0063ae9a : MOVSD.REP ES:EDI,ESI
0063ae9c : JMP dword ptr [EDX*0x4 + 0x63afb4]
0063aea4 : MOV EAX,EDI
0063aea6 : MOV EDX,0x3
0063aeab : SUB ECX,0x4
0063aeae : JC 0x0063aebc
0063aeb0 : AND EAX,0x3
0063aeb3 : ADD ECX,EAX
0063aeb5 : JMP dword ptr [EAX*0x4 + 0x63aec8]
0063aebc : JMP dword ptr [ECX*0x4 + 0x63afc4]
0063aec4 : JMP dword ptr [ECX*0x4 + 0x63af48]
0063aed8 : AND EDX,ECX
0063aeda : MOV AL,byte ptr [ESI]
0063aedc : MOV byte ptr [EDI],AL
0063aede : MOV AL,byte ptr [ESI + 0x1]
0063aee1 : MOV byte ptr [EDI + 0x1],AL
0063aee4 : MOV AL,byte ptr [ESI + 0x2]
0063aee7 : SHR ECX,0x2
0063aeea : MOV byte ptr [EDI + 0x2],AL
0063aeed : ADD ESI,0x3
0063aef0 : ADD EDI,0x3
0063aef3 : CMP ECX,0x8
0063aef6 : JC 0x0063aec4
0063aef8 : MOVSD.REP ES:EDI,ESI
0063aefa : JMP dword ptr [EDX*0x4 + 0x63afb4]
0063af04 : AND EDX,ECX
0063af06 : MOV AL,byte ptr [ESI]
0063af08 : MOV byte ptr [EDI],AL
0063af0a : MOV AL,byte ptr [ESI + 0x1]
0063af0d : SHR ECX,0x2
0063af10 : MOV byte ptr [EDI + 0x1],AL
0063af13 : ADD ESI,0x2
0063af16 : ADD EDI,0x2
0063af19 : CMP ECX,0x8
0063af1c : JC 0x0063aec4
0063af1e : MOVSD.REP ES:EDI,ESI
0063af20 : JMP dword ptr [EDX*0x4 + 0x63afb4]
0063af28 : AND EDX,ECX
0063af2a : MOV AL,byte ptr [ESI]
0063af2c : MOV byte ptr [EDI],AL
0063af2e : ADD ESI,0x1
0063af31 : SHR ECX,0x2
0063af34 : ADD EDI,0x1
0063af37 : CMP ECX,0x8
0063af3a : JC 0x0063aec4
0063af3c : MOVSD.REP ES:EDI,ESI
0063af3e : JMP dword ptr [EDX*0x4 + 0x63afb4]
0063af68 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x1c]
0063af6c : MOV dword ptr [EDI + ECX*0x4 + -0x1c],EAX
0063af70 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x18]
0063af74 : MOV dword ptr [EDI + ECX*0x4 + -0x18],EAX
0063af78 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x14]
0063af7c : MOV dword ptr [EDI + ECX*0x4 + -0x14],EAX
0063af80 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x10]
0063af84 : MOV dword ptr [EDI + ECX*0x4 + -0x10],EAX
0063af88 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0xc]
0063af8c : MOV dword ptr [EDI + ECX*0x4 + -0xc],EAX
0063af90 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x8]
0063af94 : MOV dword ptr [EDI + ECX*0x4 + -0x8],EAX
0063af98 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x4]
0063af9c : MOV dword ptr [EDI + ECX*0x4 + -0x4],EAX
0063afa0 : LEA EAX,[ECX*0x4 + 0x0]
0063afa7 : ADD ESI,EAX
0063afa9 : ADD EDI,EAX
0063afab : JMP dword ptr [EDX*0x4 + 0x63afb4]
0063afc4 : MOV EAX,dword ptr [EBP + 0x8]
0063afc7 : POP ESI
0063afc8 : POP EDI
0063afc9 : LEAVE
0063afca : RET
0063afcc : MOV AL,byte ptr [ESI]
0063afce : MOV byte ptr [EDI],AL
0063afd0 : MOV EAX,dword ptr [EBP + 0x8]
0063afd3 : POP ESI
0063afd4 : POP EDI
0063afd5 : LEAVE
0063afd6 : RET
0063afd8 : MOV AL,byte ptr [ESI]
0063afda : MOV byte ptr [EDI],AL
0063afdc : MOV AL,byte ptr [ESI + 0x1]
0063afdf : MOV byte ptr [EDI + 0x1],AL
0063afe2 : MOV EAX,dword ptr [EBP + 0x8]
0063afe5 : POP ESI
0063afe6 : POP EDI
0063afe7 : LEAVE
0063afe8 : RET
0063afec : MOV AL,byte ptr [ESI]
0063afee : MOV byte ptr [EDI],AL
0063aff0 : MOV AL,byte ptr [ESI + 0x1]
0063aff3 : MOV byte ptr [EDI + 0x1],AL
0063aff6 : MOV AL,byte ptr [ESI + 0x2]
0063aff9 : MOV byte ptr [EDI + 0x2],AL
0063affc : MOV EAX,dword ptr [EBP + 0x8]
0063afff : POP ESI
0063b000 : POP EDI
0063b001 : LEAVE
0063b002 : RET
0063b004 : LEA ESI,[ECX + ESI*0x1 + -0x4]
0063b008 : LEA EDI,[ECX + EDI*0x1 + -0x4]
0063b00c : TEST EDI,0x3
0063b012 : JNZ 0x0063b038
0063b014 : SHR ECX,0x2
0063b017 : AND EDX,0x3
0063b01a : CMP ECX,0x8
0063b01d : JC 0x0063b02c
0063b01f : STD
0063b020 : MOVSD.REP ES:EDI,ESI
0063b022 : CLD
0063b023 : JMP dword ptr [EDX*0x4 + 0x63b150]
0063b02c : NEG ECX
0063b02e : JMP dword ptr [ECX*0x4 + 0x63b100]
0063b038 : MOV EAX,EDI
0063b03a : MOV EDX,0x3
0063b03f : CMP ECX,0x4
0063b042 : JC 0x0063b050
0063b044 : AND EAX,0x3
0063b047 : SUB ECX,EAX
0063b049 : JMP dword ptr [EAX*0x4 + 0x63b054]
0063b050 : JMP dword ptr [ECX*0x4 + 0x63b150]
0063b064 : MOV AL,byte ptr [ESI + 0x3]
0063b067 : AND EDX,ECX
0063b069 : MOV byte ptr [EDI + 0x3],AL
0063b06c : SUB ESI,0x1
0063b06f : SHR ECX,0x2
0063b072 : SUB EDI,0x1
0063b075 : CMP ECX,0x8
0063b078 : JC 0x0063b02c
0063b07a : STD
0063b07b : MOVSD.REP ES:EDI,ESI
0063b07d : CLD
0063b07e : JMP dword ptr [EDX*0x4 + 0x63b150]
0063b088 : MOV AL,byte ptr [ESI + 0x3]
0063b08b : AND EDX,ECX
0063b08d : MOV byte ptr [EDI + 0x3],AL
0063b090 : MOV AL,byte ptr [ESI + 0x2]
0063b093 : SHR ECX,0x2
0063b096 : MOV byte ptr [EDI + 0x2],AL
0063b099 : SUB ESI,0x2
0063b09c : SUB EDI,0x2
0063b09f : CMP ECX,0x8
0063b0a2 : JC 0x0063b02c
0063b0a4 : STD
0063b0a5 : MOVSD.REP ES:EDI,ESI
0063b0a7 : CLD
0063b0a8 : JMP dword ptr [EDX*0x4 + 0x63b150]
0063b0b0 : MOV AL,byte ptr [ESI + 0x3]
0063b0b3 : AND EDX,ECX
0063b0b5 : MOV byte ptr [EDI + 0x3],AL
0063b0b8 : MOV AL,byte ptr [ESI + 0x2]
0063b0bb : MOV byte ptr [EDI + 0x2],AL
0063b0be : MOV AL,byte ptr [ESI + 0x1]
0063b0c1 : SHR ECX,0x2
0063b0c4 : MOV byte ptr [EDI + 0x1],AL
0063b0c7 : SUB ESI,0x3
0063b0ca : SUB EDI,0x3
0063b0cd : CMP ECX,0x8
0063b0d0 : JC 0x0063b02c
0063b0d6 : STD
0063b0d7 : MOVSD.REP ES:EDI,ESI
0063b0d9 : CLD
0063b0da : JMP dword ptr [EDX*0x4 + 0x63b150]
0063b104 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x1c]
0063b108 : MOV dword ptr [EDI + ECX*0x4 + 0x1c],EAX
0063b10c : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x18]
0063b110 : MOV dword ptr [EDI + ECX*0x4 + 0x18],EAX
0063b114 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x14]
0063b118 : MOV dword ptr [EDI + ECX*0x4 + 0x14],EAX
0063b11c : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x10]
0063b120 : MOV dword ptr [EDI + ECX*0x4 + 0x10],EAX
0063b124 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0xc]
0063b128 : MOV dword ptr [EDI + ECX*0x4 + 0xc],EAX
0063b12c : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x8]
0063b130 : MOV dword ptr [EDI + ECX*0x4 + 0x8],EAX
0063b134 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x4]
0063b138 : MOV dword ptr [EDI + ECX*0x4 + 0x4],EAX
0063b13c : LEA EAX,[ECX*0x4 + 0x0]
0063b143 : ADD ESI,EAX
0063b145 : ADD EDI,EAX
0063b147 : JMP dword ptr [EDX*0x4 + 0x63b150]
0063b160 : MOV EAX,dword ptr [EBP + 0x8]
0063b163 : POP ESI
0063b164 : POP EDI
0063b165 : LEAVE
0063b166 : RET
0063b168 : MOV AL,byte ptr [ESI + 0x3]
0063b16b : MOV byte ptr [EDI + 0x3],AL
0063b16e : MOV EAX,dword ptr [EBP + 0x8]
0063b171 : POP ESI
0063b172 : POP EDI
0063b173 : LEAVE
0063b174 : RET
0063b178 : MOV AL,byte ptr [ESI + 0x3]
0063b17b : MOV byte ptr [EDI + 0x3],AL
0063b17e : MOV AL,byte ptr [ESI + 0x2]
0063b181 : MOV byte ptr [EDI + 0x2],AL
0063b184 : MOV EAX,dword ptr [EBP + 0x8]
0063b187 : POP ESI
0063b188 : POP EDI
0063b189 : LEAVE
0063b18a : RET
0063b18c : MOV AL,byte ptr [ESI + 0x3]
0063b18f : MOV byte ptr [EDI + 0x3],AL
0063b192 : MOV AL,byte ptr [ESI + 0x2]
0063b195 : MOV byte ptr [EDI + 0x2],AL
0063b198 : MOV AL,byte ptr [ESI + 0x1]
0063b19b : MOV byte ptr [EDI + 0x1],AL
0063b19e : MOV EAX,dword ptr [EBP + 0x8]
0063b1a1 : POP ESI
0063b1a2 : POP EDI
0063b1a3 : LEAVE
0063b1a4 : RET
