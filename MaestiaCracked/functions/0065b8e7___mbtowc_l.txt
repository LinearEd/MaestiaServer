PROGRAM  : Maestia.exe
FUNCTION : __mbtowc_l
ENTRY    : 0065b8e7
BODY     : [[0065b8e7, 0065b9fd]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    __mbtowc_l
   
   Library: Visual Studio 2008 Release */

int __cdecl __mbtowc_l(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale)

{
  wchar_t *pwVar1;
  int iVar2;
  int *piVar3;
  localeinfo_struct local_14;
  int local_c;
  char local_8;
  
  if ((_SrcCh != (char *)0x0) && (_SrcSizeInBytes != 0)) {
    if (*_SrcCh != '\0') {
      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14,_Locale);
      if ((local_14.locinfo)->lc_category[0].wlocale != (wchar_t *)0x0) {
        iVar2 = __isleadbyte_l((uint)(byte)*_SrcCh,&local_14);
        if (iVar2 == 0) {
          iVar2 = MultiByteToWideChar((local_14.locinfo)->lc_codepage,9,_SrcCh,1,_DstCh,
                                      (uint)(_DstCh != (wchar_t *)0x0));
          if (iVar2 != 0) goto LAB_0065b936;
        }
        else {
          pwVar1 = (local_14.locinfo)->locale_name[3];
          if ((((1 < (int)pwVar1) && ((int)pwVar1 <= (int)_SrcSizeInBytes)) &&
              (iVar2 = MultiByteToWideChar((local_14.locinfo)->lc_codepage,9,_SrcCh,(int)pwVar1,
                                           _DstCh,(uint)(_DstCh != (wchar_t *)0x0)), iVar2 != 0)) ||
             (((local_14.locinfo)->locale_name[3] <= _SrcSizeInBytes && (_SrcCh[1] != '\0')))) {
            pwVar1 = (local_14.locinfo)->locale_name[3];
            if (local_8 == '\0') {
              return (int)pwVar1;
            }
            *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
            return (int)pwVar1;
          }
        }
        piVar3 = __errno();
        *piVar3 = 0x2a;
        if (local_8 != '\0') {
          *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
        }
        return -1;
      }
      if (_DstCh != (wchar_t *)0x0) {
        *_DstCh = (ushort)(byte)*_SrcCh;
      }
LAB_0065b936:
      if (local_8 != '\0') {
        *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
      }
      return 1;
    }
    if (_DstCh != (wchar_t *)0x0) {
      *_DstCh = L'\0';
    }
  }
  return 0;
}



============================================================
DISASSEMBLY
============================================================
0065b8e7 : MOV EDI,EDI
0065b8e9 : PUSH EBP
0065b8ea : MOV EBP,ESP
0065b8ec : SUB ESP,0x10
0065b8ef : PUSH EBX
0065b8f0 : PUSH ESI
0065b8f1 : MOV ESI,dword ptr [EBP + 0xc]
0065b8f4 : XOR EBX,EBX
0065b8f6 : CMP ESI,EBX
0065b8f8 : JZ 0x0065b90f
0065b8fa : CMP dword ptr [EBP + 0x10],EBX
0065b8fd : JZ 0x0065b90f
0065b8ff : CMP byte ptr [ESI],BL
0065b901 : JNZ 0x0065b915
0065b903 : MOV EAX,dword ptr [EBP + 0x8]
0065b906 : CMP EAX,EBX
0065b908 : JZ 0x0065b90f
0065b90a : XOR ECX,ECX
0065b90c : MOV word ptr [EAX],CX
0065b90f : XOR EAX,EAX
0065b911 : POP ESI
0065b912 : POP EBX
0065b913 : LEAVE
0065b914 : RET
0065b915 : PUSH dword ptr [EBP + 0x14]
0065b918 : LEA ECX,[EBP + -0x10]
0065b91b : CALL 0x00637880
0065b920 : MOV EAX,dword ptr [EBP + -0x10]
0065b923 : CMP dword ptr [EAX + 0x14],EBX
0065b926 : JNZ 0x0065b947
0065b928 : MOV EAX,dword ptr [EBP + 0x8]
0065b92b : CMP EAX,EBX
0065b92d : JZ 0x0065b936
0065b92f : MOVZX CX,byte ptr [ESI]
0065b933 : MOV word ptr [EAX],CX
0065b936 : CMP byte ptr [EBP + -0x4],BL
0065b939 : JZ 0x0065b942
0065b93b : MOV EAX,dword ptr [EBP + -0x8]
0065b93e : AND dword ptr [EAX + 0x70],0xfffffffd
0065b942 : XOR EAX,EAX
0065b944 : INC EAX
0065b945 : JMP 0x0065b911
0065b947 : LEA EAX,[EBP + -0x10]
0065b94a : PUSH EAX
0065b94b : MOVZX EAX,byte ptr [ESI]
0065b94e : PUSH EAX
0065b94f : CALL 0x006390f8
0065b954 : POP ECX
0065b955 : POP ECX
0065b956 : TEST EAX,EAX
0065b958 : JZ 0x0065b9d7
0065b95a : MOV EAX,dword ptr [EBP + -0x10]
0065b95d : MOV ECX,dword ptr [EAX + 0xac]
0065b963 : CMP ECX,0x1
0065b966 : JLE 0x0065b98d
0065b968 : CMP dword ptr [EBP + 0x10],ECX
0065b96b : JL 0x0065b98d
0065b96d : XOR EDX,EDX
0065b96f : CMP dword ptr [EBP + 0x8],EBX
0065b972 : SETNZ DL
0065b975 : PUSH EDX
0065b976 : PUSH dword ptr [EBP + 0x8]
0065b979 : PUSH ECX
0065b97a : PUSH ESI
0065b97b : PUSH 0x9
0065b97d : PUSH dword ptr [EAX + 0x4]
0065b980 : CALL dword ptr [0x00b850e0]
0065b986 : TEST EAX,EAX
0065b988 : MOV EAX,dword ptr [EBP + -0x10]
0065b98b : JNZ 0x0065b99d
0065b98d : MOV ECX,dword ptr [EBP + 0x10]
0065b990 : CMP ECX,dword ptr [EAX + 0xac]
0065b996 : JC 0x0065b9b8
0065b998 : CMP byte ptr [ESI + 0x1],BL
0065b99b : JZ 0x0065b9b8
0065b99d : MOV EAX,dword ptr [EAX + 0xac]
0065b9a3 : CMP byte ptr [EBP + -0x4],BL
0065b9a6 : JZ 0x0065b911
0065b9ac : MOV ECX,dword ptr [EBP + -0x8]
0065b9af : AND dword ptr [ECX + 0x70],0xfffffffd
0065b9b3 : JMP 0x0065b911
0065b9b8 : CALL 0x0063ab82
0065b9bd : MOV dword ptr [EAX],0x2a
0065b9c3 : CMP byte ptr [EBP + -0x4],BL
0065b9c6 : JZ 0x0065b9cf
0065b9c8 : MOV EAX,dword ptr [EBP + -0x8]
0065b9cb : AND dword ptr [EAX + 0x70],0xfffffffd
0065b9cf : OR EAX,0xffffffff
0065b9d2 : JMP 0x0065b911
0065b9d7 : XOR EAX,EAX
0065b9d9 : CMP dword ptr [EBP + 0x8],EBX
0065b9dc : SETNZ AL
0065b9df : PUSH EAX
0065b9e0 : PUSH dword ptr [EBP + 0x8]
0065b9e3 : MOV EAX,dword ptr [EBP + -0x10]
0065b9e6 : PUSH 0x1
0065b9e8 : PUSH ESI
0065b9e9 : PUSH 0x9
0065b9eb : PUSH dword ptr [EAX + 0x4]
0065b9ee : CALL dword ptr [0x00b850e0]
0065b9f4 : TEST EAX,EAX
0065b9f6 : JNZ 0x0065b936
0065b9fc : JMP 0x0065b9b8
