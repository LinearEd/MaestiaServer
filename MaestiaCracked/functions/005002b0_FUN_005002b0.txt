PROGRAM  : Maestia.exe
FUNCTION : FUN_005002b0
ENTRY    : 005002b0
BODY     : [[005002b0, 00500392]]

============================================================
DECOMPILED C CODE
============================================================

undefined4 FUN_005002b0(void)

{
  byte bVar1;
  char cVar2;
  byte *pbVar3;
  int iVar4;
  byte *pbVar5;
  undefined4 uVar6;
  char *pcVar7;
  undefined4 *unaff_EDI;
  bool bVar8;
  
  pbVar5 = *(byte **)*unaff_EDI;
  pcVar7 = "compositionSegment";
  pbVar3 = pbVar5;
  do {
    bVar1 = *pbVar3;
    bVar8 = bVar1 < (byte)*pcVar7;
    if (bVar1 != *pcVar7) {
LAB_005002e2:
      iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
      goto LAB_005002e7;
    }
    if (bVar1 == 0) break;
    bVar1 = pbVar3[1];
    bVar8 = bVar1 < ((byte *)pcVar7)[1];
    if (bVar1 != ((byte *)pcVar7)[1]) goto LAB_005002e2;
    pbVar3 = pbVar3 + 2;
    pcVar7 = (char *)((byte *)pcVar7 + 2);
  } while (bVar1 != 0);
  iVar4 = 0;
LAB_005002e7:
  if (iVar4 == 0) {
    return 0;
  }
  pcVar7 = "clauseSegment";
  pbVar3 = pbVar5;
  do {
    bVar1 = *pbVar3;
    bVar8 = bVar1 < (byte)*pcVar7;
    if (bVar1 != *pcVar7) {
LAB_00500315:
      iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
      goto LAB_0050031a;
    }
    if (bVar1 == 0) break;
    bVar1 = pbVar3[1];
    bVar8 = bVar1 < ((byte *)pcVar7)[1];
    if (bVar1 != ((byte *)pcVar7)[1]) goto LAB_00500315;
    pbVar3 = pbVar3 + 2;
    pcVar7 = (char *)((byte *)pcVar7 + 2);
  } while (bVar1 != 0);
  iVar4 = 0;
LAB_0050031a:
  if (iVar4 == 0) {
    return 1;
  }
  pcVar7 = "convertedSegment";
  do {
    bVar1 = *pbVar5;
    bVar8 = bVar1 < (byte)*pcVar7;
    if (bVar1 != *pcVar7) {
LAB_00500350:
      iVar4 = (1 - (uint)bVar8) - (uint)(bVar8 != 0);
      goto LAB_00500355;
    }
    if (bVar1 == 0) break;
    bVar1 = pbVar5[1];
    bVar8 = bVar1 < ((byte *)pcVar7)[1];
    if (bVar1 != ((byte *)pcVar7)[1]) goto LAB_00500350;
    pbVar5 = pbVar5 + 2;
    pcVar7 = (char *)((byte *)pcVar7 + 2);
  } while (bVar1 != 0);
  iVar4 = 0;
LAB_00500355:
  if (iVar4 == 0) {
    return 2;
  }
  cVar2 = FUN_004ffc90("phraseLengthAdj");
  if (cVar2 != '\0') {
    return 3;
  }
  cVar2 = FUN_004ffc90("lowConfSegment");
  uVar6 = 4;
  if (cVar2 == '\0') {
    uVar6 = 5;
  }
  return uVar6;
}



============================================================
DISASSEMBLY
============================================================
005002b0 : MOV EAX,dword ptr [EDI]
005002b2 : PUSH EBX
005002b3 : PUSH ESI
005002b4 : MOV ESI,dword ptr [EAX]
005002b6 : MOV EBX,0x5
005002bb : MOV ECX,0xb86044
005002c0 : MOV EAX,ESI
005002c2 : MOV DL,byte ptr [EAX]
005002c4 : CMP DL,byte ptr [ECX]
005002c6 : JNZ 0x005002e2
005002c8 : TEST DL,DL
005002ca : JZ 0x005002de
005002cc : MOV DL,byte ptr [EAX + 0x1]
005002cf : CMP DL,byte ptr [ECX + 0x1]
005002d2 : JNZ 0x005002e2
005002d4 : ADD EAX,0x2
005002d7 : ADD ECX,0x2
005002da : TEST DL,DL
005002dc : JNZ 0x005002c2
005002de : XOR EAX,EAX
005002e0 : JMP 0x005002e7
005002e2 : SBB EAX,EAX
005002e4 : SBB EAX,-0x1
005002e7 : TEST EAX,EAX
005002e9 : JNZ 0x005002ee
005002eb : POP ESI
005002ec : POP EBX
005002ed : RET
005002ee : MOV ECX,0xb86034
005002f3 : MOV EAX,ESI
005002f5 : MOV DL,byte ptr [EAX]
005002f7 : CMP DL,byte ptr [ECX]
005002f9 : JNZ 0x00500315
005002fb : TEST DL,DL
005002fd : JZ 0x00500311
005002ff : MOV DL,byte ptr [EAX + 0x1]
00500302 : CMP DL,byte ptr [ECX + 0x1]
00500305 : JNZ 0x00500315
00500307 : ADD EAX,0x2
0050030a : ADD ECX,0x2
0050030d : TEST DL,DL
0050030f : JNZ 0x005002f5
00500311 : XOR EAX,EAX
00500313 : JMP 0x0050031a
00500315 : SBB EAX,EAX
00500317 : SBB EAX,-0x1
0050031a : TEST EAX,EAX
0050031c : JNZ 0x00500326
0050031e : POP ESI
0050031f : MOV EAX,0x1
00500324 : POP EBX
00500325 : RET
00500326 : MOV ECX,0xb86020
0050032b : MOV EAX,ESI
0050032d : LEA ECX,[ECX]
00500330 : MOV DL,byte ptr [EAX]
00500332 : CMP DL,byte ptr [ECX]
00500334 : JNZ 0x00500350
00500336 : TEST DL,DL
00500338 : JZ 0x0050034c
0050033a : MOV DL,byte ptr [EAX + 0x1]
0050033d : CMP DL,byte ptr [ECX + 0x1]
00500340 : JNZ 0x00500350
00500342 : ADD EAX,0x2
00500345 : ADD ECX,0x2
00500348 : TEST DL,DL
0050034a : JNZ 0x00500330
0050034c : XOR EAX,EAX
0050034e : JMP 0x00500355
00500350 : SBB EAX,EAX
00500352 : SBB EAX,-0x1
00500355 : TEST EAX,EAX
00500357 : JNZ 0x00500361
00500359 : POP ESI
0050035a : MOV EAX,0x2
0050035f : POP EBX
00500360 : RET
00500361 : PUSH 0xb86010
00500366 : MOV ECX,EDI
00500368 : CALL 0x004ffc90
0050036d : TEST AL,AL
0050036f : JZ 0x00500379
00500371 : POP ESI
00500372 : MOV EAX,0x3
00500377 : POP EBX
00500378 : RET
00500379 : PUSH 0xb86000
0050037e : MOV ECX,EDI
00500380 : CALL 0x004ffc90
00500385 : TEST AL,AL
00500387 : MOV EAX,0x4
0050038c : JNZ 0x00500390
0050038e : MOV EAX,EBX
00500390 : POP ESI
00500391 : POP EBX
00500392 : RET
