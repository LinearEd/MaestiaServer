PROGRAM  : Maestia.exe
FUNCTION : FUN_00600e90
ENTRY    : 00600e90
BODY     : [[00600e90, 00600f34] [00600f40, 00601015]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00600e90(int param_1,int param_2,int param_3,undefined4 param_4,undefined4 param_5,
                 uint param_6)

{
  undefined4 *puVar1;
  uint uVar2;
  int iVar3;
  int in_ECX;
  uint uVar4;
  uint uVar5;
  
  FUN_00607850();
  *(uint *)(in_ECX + 0x8c) = param_6;
  *(int *)(in_ECX + 0x80) = param_2;
  *(int *)(in_ECX + 0x84) = param_3;
  if ((param_2 != 0) && (param_3 == 0)) {
    *(undefined4 *)(in_ECX + 0x80) = 0;
  }
  *(undefined1 *)(in_ECX + 0x88) = 0;
  uVar4 = 0;
  if (*(int *)(param_1 + 0x104) != 0) {
    do {
      FUN_00607ad0(*(int *)(*(int *)(param_1 + 0x110) + (uVar4 >> 10) * 4) + (uVar4 & 0x3ff) * 8);
      uVar4 = uVar4 + 1;
    } while (uVar4 < *(uint *)(param_1 + 0x104));
  }
  if (*(int *)(in_ECX + 0x80) == 0) {
    param_2 = 0;
  }
  else {
    param_2 = *(int *)(in_ECX + 0x84);
  }
  param_6 = 0;
  if (*(int *)(param_1 + 0x154) != 0) {
    do {
      uVar4 = *(int *)(*(int *)(*(int *)(param_1 + 0x160) + (param_6 >> 6) * 4) + 0x10 +
                      (param_6 & 0x3f) * 0x18) - 1;
      if (((int)uVar4 < param_2) && (*(char *)(*(int *)(in_ECX + 0x80) + uVar4 * 0x28) != '\0')) {
        uVar4 = uVar4 | 0x40000000;
        *(undefined1 *)(in_ECX + 0x88) = 1;
      }
      FUN_005ffd00(param_6);
      uVar2 = *(uint *)(param_1 + 0x184);
      uVar5 = 0;
      if (uVar2 != 0) {
        do {
          iVar3 = *(int *)(*(int *)(param_1 + 400) + (uVar5 >> 10) * 4);
          puVar1 = (undefined4 *)(iVar3 + (uVar5 & 0x3ff) * 0xc);
          FUN_00607b30(*puVar1,puVar1[1],*(undefined4 *)(iVar3 + 8 + (uVar5 & 0x3ff) * 0xc),uVar4);
          uVar5 = uVar5 + 1;
        } while (uVar5 < uVar2);
      }
      param_6 = param_6 + 1;
    } while (param_6 < *(uint *)(param_1 + 0x154));
  }
  FUN_00608120(param_4,param_5);
  if (*(char *)(in_ECX + 0x88) != '\0') {
    FUN_00607960();
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00600e90 : PUSH EBX
00600e91 : PUSH EDI
00600e92 : MOV EBX,ECX
00600e94 : CALL 0x00607850
00600e99 : MOV EAX,dword ptr [ESP + 0x20]
00600e9d : MOV ECX,dword ptr [ESP + 0x14]
00600ea1 : MOV dword ptr [EBX + 0x8c],EAX
00600ea7 : MOV EAX,dword ptr [ESP + 0x10]
00600eab : XOR EDI,EDI
00600ead : MOV dword ptr [EBX + 0x80],EAX
00600eb3 : MOV dword ptr [EBX + 0x84],ECX
00600eb9 : CMP EAX,EDI
00600ebb : JZ 0x00600ec7
00600ebd : CMP ECX,EDI
00600ebf : JNZ 0x00600ec7
00600ec1 : MOV dword ptr [EBX + 0x80],EDI
00600ec7 : PUSH EBP
00600ec8 : MOV EBP,dword ptr [ESP + 0x10]
00600ecc : PUSH ESI
00600ecd : MOV byte ptr [EBX + 0x88],0x0
00600ed4 : XOR ESI,ESI
00600ed6 : CMP dword ptr [EBP + 0x104],EDI
00600edc : JBE 0x00600f09
00600ede : MOV EDI,EDI
00600ee0 : MOV EDX,dword ptr [EBP + 0x110]
00600ee6 : MOV ECX,ESI
00600ee8 : SHR ECX,0xa
00600eeb : MOV ECX,dword ptr [EDX + ECX*0x4]
00600eee : MOV EAX,ESI
00600ef0 : AND EAX,0x3ff
00600ef5 : LEA EDX,[ECX + EAX*0x8]
00600ef8 : PUSH EDX
00600ef9 : MOV ECX,EBX
00600efb : CALL 0x00607ad0
00600f00 : INC ESI
00600f01 : CMP ESI,dword ptr [EBP + 0x104]
00600f07 : JC 0x00600ee0
00600f09 : CMP dword ptr [EBX + 0x80],EDI
00600f0f : JZ 0x00600f1d
00600f11 : MOV EAX,dword ptr [EBX + 0x84]
00600f17 : MOV dword ptr [ESP + 0x18],EAX
00600f1b : JMP 0x00600f21
00600f1d : MOV dword ptr [ESP + 0x18],EDI
00600f21 : XOR ECX,ECX
00600f23 : MOV dword ptr [ESP + 0x28],ECX
00600f27 : CMP dword ptr [EBP + 0x154],EDI
00600f2d : JBE 0x00600feb
00600f33 : JMP 0x00600f44
00600f40 : MOV ECX,dword ptr [ESP + 0x28]
00600f44 : MOV ESI,dword ptr [EBP + 0x160]
00600f4a : MOV EDX,ECX
00600f4c : MOV EAX,ECX
00600f4e : SHR EDX,0x6
00600f51 : MOV EDX,dword ptr [ESI + EDX*0x4]
00600f54 : AND EAX,0x3f
00600f57 : LEA EAX,[EAX + EAX*0x2]
00600f5a : MOV EDI,dword ptr [EDX + EAX*0x8 + 0x10]
00600f5e : DEC EDI
00600f5f : CMP EDI,dword ptr [ESP + 0x18]
00600f63 : JGE 0x00600f81
00600f65 : MOV EDX,dword ptr [EBX + 0x80]
00600f6b : LEA EAX,[EDI + EDI*0x4]
00600f6e : CMP byte ptr [EDX + EAX*0x8],0x0
00600f72 : JZ 0x00600f81
00600f74 : OR EDI,0x40000000
00600f7a : MOV byte ptr [EBX + 0x88],0x1
00600f81 : PUSH ECX
00600f82 : MOV ECX,EBP
00600f84 : CALL 0x005ffd00
00600f89 : MOV EAX,dword ptr [EBP + 0x184]
00600f8f : XOR ESI,ESI
00600f91 : MOV dword ptr [ESP + 0x1c],EAX
00600f95 : TEST EAX,EAX
00600f97 : JBE 0x00600fd6
00600f99 : LEA ESP,[ESP]
00600fa0 : MOV EDX,dword ptr [EBP + 0x190]
00600fa6 : MOV ECX,ESI
00600fa8 : SHR ECX,0xa
00600fab : MOV ECX,dword ptr [EDX + ECX*0x4]
00600fae : MOV EAX,ESI
00600fb0 : AND EAX,0x3ff
00600fb5 : LEA EAX,[EAX + EAX*0x2]
00600fb8 : MOV EDX,dword ptr [ECX + EAX*0x4 + 0x8]
00600fbc : LEA EAX,[ECX + EAX*0x4]
00600fbf : MOV ECX,dword ptr [EAX + 0x4]
00600fc2 : PUSH EDI
00600fc3 : PUSH EDX
00600fc4 : MOV EDX,dword ptr [EAX]
00600fc6 : PUSH ECX
00600fc7 : PUSH EDX
00600fc8 : MOV ECX,EBX
00600fca : CALL 0x00607b30
00600fcf : INC ESI
00600fd0 : CMP ESI,dword ptr [ESP + 0x1c]
00600fd4 : JC 0x00600fa0
00600fd6 : MOV EAX,dword ptr [ESP + 0x28]
00600fda : INC EAX
00600fdb : MOV dword ptr [ESP + 0x28],EAX
00600fdf : CMP EAX,dword ptr [EBP + 0x154]
00600fe5 : JC 0x00600f40
00600feb : MOV EAX,dword ptr [ESP + 0x24]
00600fef : FLD float ptr [ESP + 0x20]
00600ff3 : PUSH EAX
00600ff4 : PUSH ECX
00600ff5 : MOV ECX,EBX
00600ff7 : FSTP float ptr [ESP]
00600ffa : CALL 0x00608120
00600fff : CMP byte ptr [EBX + 0x88],0x0
00601006 : POP ESI
00601007 : POP EBP
00601008 : JZ 0x00601011
0060100a : MOV ECX,EBX
0060100c : CALL 0x00607960
00601011 : POP EDI
00601012 : POP EBX
00601013 : RET 0x18
