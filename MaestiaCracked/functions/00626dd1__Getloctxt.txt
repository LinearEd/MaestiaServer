PROGRAM  : Maestia.exe
FUNCTION : _Getloctxt<>
ENTRY    : 00626dd1
BODY     : [[00626dd1, 00626f31]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Function: __EH_prolog3_GS replaced with injection: EH_prolog3 */
/* Library Function - Multiple Matches With Same Base Name
    int __cdecl std::_Getloctxt<unsigned short,class std::istreambuf_iterator<unsigned short,struct
   std::char_traits<unsigned short> > >(class std::istreambuf_iterator<unsigned short,struct
   std::char_traits<unsigned short> > &,class std::istreambuf_iterator<unsigned short,struct
   std::char_traits<unsigned short> > &,unsigned int,unsigned short const *)
    int __cdecl std::_Getloctxt<wchar_t,class std::istreambuf_iterator<wchar_t,struct
   std::char_traits<wchar_t> > >(class std::istreambuf_iterator<wchar_t,struct
   std::char_traits<wchar_t> > &,class std::istreambuf_iterator<wchar_t,struct
   std::char_traits<wchar_t> > &,unsigned int,wchar_t const *)
   
   Library: Visual Studio 2008 Release */

void _Getloctxt<>(undefined4 param_1,undefined4 param_2,uint param_3,short *param_4)

{
  bool bVar1;
  char cVar2;
  short sVar3;
  char *pcVar4;
  undefined1 *puVar5;
  int iVar6;
  uint uVar7;
  uint local_3c;
  uint local_38;
  
  iVar6 = 0;
  sVar3 = *param_4;
  while (sVar3 != 0) {
    if (sVar3 == *param_4) {
      param_3 = param_3 + 1;
    }
    iVar6 = iVar6 + 1;
    sVar3 = param_4[iVar6];
  }
  FUN_004d1280(param_3,0);
  local_3c = 1;
  while( true ) {
    iVar6 = 0;
    bVar1 = false;
    local_38 = 0;
    if (param_3 == 0) break;
    do {
      sVar3 = param_4[iVar6];
      if (sVar3 != 0) {
        do {
          if (sVar3 == *param_4) break;
          iVar6 = iVar6 + 1;
          sVar3 = param_4[iVar6];
        } while (sVar3 != 0);
      }
      pcVar4 = (char *)FUN_004d3b30(local_38);
      if (*pcVar4 == '\0') {
        iVar6 = iVar6 + local_3c;
        if ((param_4[iVar6] == *param_4) || (param_4[iVar6] == 0)) {
          uVar7 = 0x7f;
          if (local_3c < 0x7f) {
            uVar7 = local_3c;
          }
          puVar5 = (undefined1 *)FUN_004d3b30(local_38);
          *puVar5 = (char)uVar7;
        }
        else {
          cVar2 = equal(param_2);
          if ((cVar2 == '\0') && (sVar3 = FID_conflict_operator_(), param_4[iVar6] == sVar3)) {
            bVar1 = true;
          }
          else {
            uVar7 = 0x7f;
            if (local_3c < 0x7f) {
              uVar7 = local_3c;
            }
            puVar5 = (undefined1 *)FUN_004d3b30(local_38);
            *puVar5 = (char)uVar7;
          }
        }
      }
      else {
        pcVar4 = (char *)FUN_004d3b30(local_38);
        iVar6 = iVar6 + *pcVar4;
      }
      local_38 = local_38 + 1;
    } while (local_38 < param_3);
    if ((!bVar1) || (cVar2 = equal(param_2), cVar2 != '\0')) break;
    local_3c = local_3c + 1;
    Inc();
  }
  FUN_00405260(1,0);
  FUN_00640ed0();
  return;
}



============================================================
DISASSEMBLY
============================================================
00626dd1 : PUSH 0x38
00626dd3 : MOV EAX,0xb0b7f6
00626dd8 : CALL 0x00640e86
00626ddd : MOV ESI,dword ptr [EBP + 0x14]
00626de0 : MOV EAX,dword ptr [EBP + 0x8]
00626de3 : MOVZX ECX,word ptr [ESI]
00626de6 : MOV dword ptr [EBP + -0x3c],EAX
00626de9 : MOV EAX,dword ptr [EBP + 0xc]
00626dec : XOR EDX,EDX
00626dee : MOV dword ptr [EBP + -0x44],EAX
00626df1 : TEST CX,CX
00626df4 : JZ 0x00626e0b
00626df6 : MOVZX EAX,CX
00626df9 : CMP AX,CX
00626dfc : JNZ 0x00626e01
00626dfe : INC dword ptr [EBP + 0x10]
00626e01 : INC EDX
00626e02 : MOVZX EAX,word ptr [ESI + EDX*0x2]
00626e06 : TEST AX,AX
00626e09 : JNZ 0x00626df9
00626e0b : PUSH 0x0
00626e0d : PUSH dword ptr [EBP + 0x10]
00626e10 : LEA ECX,[EBP + -0x2c]
00626e13 : CALL 0x004d1280
00626e18 : AND dword ptr [EBP + -0x4],0x0
00626e1c : MOV dword ptr [EBP + -0x40],0xfffffffe
00626e23 : MOV dword ptr [EBP + -0x38],0x1
00626e2a : XOR EDI,EDI
00626e2c : MOV byte ptr [EBP + -0x2d],0x0
00626e30 : MOV dword ptr [EBP + -0x34],EDI
00626e33 : CMP dword ptr [EBP + 0x10],EDI
00626e36 : JBE 0x00626f1d
00626e3c : MOVZX EAX,word ptr [ESI + EDI*0x2]
00626e40 : TEST AX,AX
00626e43 : JZ 0x00626e57
00626e45 : MOVZX ECX,word ptr [ESI]
00626e48 : CMP AX,CX
00626e4b : JZ 0x00626e57
00626e4d : INC EDI
00626e4e : MOVZX EAX,word ptr [ESI + EDI*0x2]
00626e52 : TEST AX,AX
00626e55 : JNZ 0x00626e48
00626e57 : PUSH dword ptr [EBP + -0x34]
00626e5a : LEA ECX,[EBP + -0x2c]
00626e5d : CALL 0x004d3b30
00626e62 : CMP byte ptr [EAX],0x0
00626e65 : JZ 0x00626e79
00626e67 : PUSH dword ptr [EBP + -0x34]
00626e6a : LEA ECX,[EBP + -0x2c]
00626e6d : CALL 0x004d3b30
00626e72 : MOVSX EAX,byte ptr [EAX]
00626e75 : ADD EDI,EAX
00626e77 : JMP 0x00626ee5
00626e79 : ADD EDI,dword ptr [EBP + -0x38]
00626e7c : MOVZX EAX,word ptr [ESI + EDI*0x2]
00626e80 : CMP AX,word ptr [ESI]
00626e83 : JZ 0x00626ec7
00626e85 : TEST AX,AX
00626e88 : JZ 0x00626ec7
00626e8a : PUSH dword ptr [EBP + -0x44]
00626e8d : MOV ECX,dword ptr [EBP + -0x3c]
00626e90 : CALL 0x0062638a
00626e95 : TEST AL,AL
00626e97 : JNZ 0x00626ead
00626e99 : MOV ECX,dword ptr [EBP + -0x3c]
00626e9c : CALL 0x00626573
00626ea1 : CMP word ptr [ESI + EDI*0x2],AX
00626ea5 : JNZ 0x00626ead
00626ea7 : MOV byte ptr [EBP + -0x2d],0x1
00626eab : JMP 0x00626ee5
00626ead : PUSH 0x7f
00626eaf : POP EBX
00626eb0 : CMP dword ptr [EBP + -0x38],EBX
00626eb3 : JNC 0x00626eb8
00626eb5 : MOV EBX,dword ptr [EBP + -0x38]
00626eb8 : PUSH dword ptr [EBP + -0x34]
00626ebb : LEA ECX,[EBP + -0x2c]
00626ebe : CALL 0x004d3b30
00626ec3 : MOV byte ptr [EAX],BL
00626ec5 : JMP 0x00626ee5
00626ec7 : PUSH 0x7f
00626ec9 : POP EBX
00626eca : CMP dword ptr [EBP + -0x38],EBX
00626ecd : JNC 0x00626ed2
00626ecf : MOV EBX,dword ptr [EBP + -0x38]
00626ed2 : PUSH dword ptr [EBP + -0x34]
00626ed5 : LEA ECX,[EBP + -0x2c]
00626ed8 : CALL 0x004d3b30
00626edd : MOV byte ptr [EAX],BL
00626edf : MOV EAX,dword ptr [EBP + -0x34]
00626ee2 : MOV dword ptr [EBP + -0x40],EAX
00626ee5 : INC dword ptr [EBP + -0x34]
00626ee8 : MOV EAX,dword ptr [EBP + -0x34]
00626eeb : CMP EAX,dword ptr [EBP + 0x10]
00626eee : JC 0x00626e3c
00626ef4 : CMP byte ptr [EBP + -0x2d],0x0
00626ef8 : JZ 0x00626f1d
00626efa : PUSH dword ptr [EBP + -0x44]
00626efd : MOV ECX,dword ptr [EBP + -0x3c]
00626f00 : CALL 0x0062638a
00626f05 : TEST AL,AL
00626f07 : JNZ 0x00626f1d
00626f09 : MOV ECX,dword ptr [EBP + -0x3c]
00626f0c : INC dword ptr [EBP + -0x38]
00626f0f : CALL 0x006262d9
00626f14 : OR dword ptr [EBP + -0x40],0xffffffff
00626f18 : JMP 0x00626e2a
00626f1d : PUSH 0x0
00626f1f : PUSH 0x1
00626f21 : LEA ECX,[EBP + -0x2c]
00626f24 : CALL 0x00405260
00626f29 : MOV EAX,dword ptr [EBP + -0x40]
00626f2c : CALL 0x00640ed0
00626f31 : RET
