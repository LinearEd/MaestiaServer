PROGRAM  : Maestia.exe
FUNCTION : FUN_0054ad70
ENTRY    : 0054ad70
BODY     : [[0054ad70, 0054af43]]

============================================================
DECOMPILED C CODE
============================================================

int FUN_0054ad70(float param_1,float param_2)

{
  float fVar1;
  float fVar2;
  int *piVar3;
  float fVar4;
  int iVar5;
  uint uVar6;
  int in_ECX;
  int iVar7;
  uint local_78;
  int *local_70 [2];
  uint local_68;
  uint local_5c;
  uint local_58;
  int *local_10;
  GRefCountNTSImpl *local_c;
  
  if ((*(byte *)(in_ECX + 0x143) & 3) != 0) {
    FUN_00549ad0();
    *(byte *)(in_ECX + 0x143) = *(byte *)(in_ECX + 0x143) & 0xfc;
  }
  param_1 = param_1 - (*(float *)(in_ECX + 0x40) - *(float *)(in_ECX + 0xf4));
  fVar1 = *(float *)(in_ECX + 0x44);
  fVar2 = *(float *)(in_ECX + 0xf8);
  iVar5 = FUN_005993d0();
  fVar4 = (float)iVar5;
  if (iVar5 < 0) {
    fVar4 = fVar4 + 4.2949673e+09;
  }
  FUN_00599ff0(local_70,fVar4 + (param_2 - (fVar1 - fVar2)));
  if (((local_70[0] != (int *)0x0) && (local_68 < (uint)local_70[0][1])) && (-1 < (int)local_68)) {
    piVar3 = *(int **)(*local_70[0] + local_68 * 4);
    if (*piVar3 < 0) {
      local_78 = piVar3[3];
    }
    else {
      local_78 = piVar3[3];
    }
    fVar1 = (float)(int)local_78;
    if (fVar1 < param_1 != (fVar1 == param_1)) {
      if (*piVar3 < 0) {
        local_78 = (uint)*(ushort *)(piVar3 + 5);
      }
      else {
        local_78 = piVar3[5];
      }
      if (param_1 <= (float)(int)local_78 + fVar1) {
        iVar7 = 0;
        FUN_005461c0(&local_5c);
        iVar5 = 0;
        while ((local_5c != 0 && (local_5c < local_58))) {
          uVar6 = (uint)*(ushort *)(local_5c + 2);
          if ((*(byte *)(local_5c + 6) >> 6 & 1) != 0) {
            uVar6 = -uVar6;
          }
          iVar7 = iVar7 + uVar6;
          if (param_1 - fVar1 < (float)iVar7) break;
          iVar5 = iVar5 + (uint)(*(ushort *)(local_5c + 4) >> 0xc);
          FUN_005443b0();
        }
        uVar6 = piVar3[2];
        if ((*piVar3 < 0) && (uVar6 = uVar6 & 0xffffff, uVar6 == 0xffffff)) {
          uVar6 = 0xffffffff;
        }
        if (local_c != (GRefCountNTSImpl *)0x0) {
          GRefCountNTSImpl::Release(local_c);
        }
        if ((local_10 != (int *)0x0) && (*local_10 = *local_10 + -1, *local_10 == 0)) {
          FUN_00500860();
          FUN_00515cf0(local_10);
        }
        return uVar6 + iVar5;
      }
    }
  }
  return -1;
}



============================================================
DISASSEMBLY
============================================================
0054ad70 : SUB ESP,0x78
0054ad73 : PUSH ESI
0054ad74 : MOV ESI,ECX
0054ad76 : TEST byte ptr [ESI + 0x143],0x3
0054ad7d : JZ 0x0054ad8b
0054ad7f : CALL 0x00549ad0
0054ad84 : AND byte ptr [ESI + 0x143],0xfc
0054ad8b : FLD float ptr [ESP + 0x80]
0054ad92 : ADD ESI,0x28
0054ad95 : FLD float ptr [ESI + 0x18]
0054ad98 : MOV ECX,ESI
0054ad9a : FSUB float ptr [ESI + 0xcc]
0054ada0 : FSUBP
0054ada2 : FSTP float ptr [ESP + 0x80]
0054ada9 : FLD float ptr [ESP + 0x84]
0054adb0 : FLD float ptr [ESI + 0x1c]
0054adb3 : FSUB float ptr [ESI + 0xd0]
0054adb9 : FSUBP
0054adbb : FSTP float ptr [ESP + 0x84]
0054adc2 : CALL 0x005993d0
0054adc7 : MOV dword ptr [ESP + 0x8],EAX
0054adcb : FILD dword ptr [ESP + 0x8]
0054adcf : TEST EAX,EAX
0054add1 : JGE 0x0054add9
0054add3 : FADD float ptr [0x00cdf0e0]
0054add9 : FADD float ptr [ESP + 0x84]
0054ade0 : PUSH ECX
0054ade1 : LEA EAX,[ESP + 0x10]
0054ade5 : MOV ECX,ESI
0054ade7 : FSTP float ptr [ESP + 0x8]
0054adeb : FLD float ptr [ESP + 0x8]
0054adef : FSTP float ptr [ESP]
0054adf2 : PUSH EAX
0054adf3 : CALL 0x00599ff0
0054adf8 : MOV EAX,dword ptr [ESP + 0xc]
0054adfc : TEST EAX,EAX
0054adfe : JZ 0x0054af3a
0054ae04 : MOV ECX,dword ptr [ESP + 0x14]
0054ae08 : CMP ECX,dword ptr [EAX + 0x4]
0054ae0b : JNC 0x0054af3a
0054ae11 : TEST ECX,ECX
0054ae13 : JL 0x0054af3a
0054ae19 : MOV EDX,dword ptr [EAX]
0054ae1b : MOV ESI,dword ptr [EDX + ECX*0x4]
0054ae1e : MOV ECX,dword ptr [ESI]
0054ae20 : SHR ECX,0x1f
0054ae23 : AND CL,0x1
0054ae26 : JZ 0x0054ae31
0054ae28 : MOV EAX,dword ptr [ESI + 0xc]
0054ae2b : MOV dword ptr [ESP + 0x4],EAX
0054ae2f : JMP 0x0054ae38
0054ae31 : MOV EDX,dword ptr [ESI + 0xc]
0054ae34 : MOV dword ptr [ESP + 0x4],EDX
0054ae38 : FILD dword ptr [ESP + 0x4]
0054ae3c : FSTP float ptr [ESP + 0x4]
0054ae40 : FLD float ptr [ESP + 0x80]
0054ae47 : FLD float ptr [ESP + 0x4]
0054ae4b : FCOM
0054ae4d : FNSTSW AX
0054ae4f : TEST AH,0x41
0054ae52 : JP 0x0054af36
0054ae58 : TEST CL,CL
0054ae5a : JZ 0x0054ae66
0054ae5c : MOVZX EAX,word ptr [ESI + 0x14]
0054ae60 : MOV dword ptr [ESP + 0x4],EAX
0054ae64 : JMP 0x0054ae6d
0054ae66 : MOV ECX,dword ptr [ESI + 0x14]
0054ae69 : MOV dword ptr [ESP + 0x4],ECX
0054ae6d : FILD dword ptr [ESP + 0x4]
0054ae71 : FADD ST0,ST1
0054ae73 : FCOMP ST2
0054ae75 : FNSTSW AX
0054ae77 : TEST AH,0x1
0054ae7a : JNZ 0x0054af36
0054ae80 : PUSH EBX
0054ae81 : FSUBP
0054ae83 : PUSH EDI
0054ae84 : LEA EDX,[ESP + 0x28]
0054ae88 : PUSH EDX
0054ae89 : FSTP float ptr [ESP + 0x14]
0054ae8d : MOV ECX,ESI
0054ae8f : XOR EDI,EDI
0054ae91 : CALL 0x005461c0
0054ae96 : XOR EBX,EBX
0054ae98 : MOV ECX,dword ptr [ESP + 0x28]
0054ae9c : TEST ECX,ECX
0054ae9e : JZ 0x0054aee1
0054aea0 : CMP ECX,dword ptr [ESP + 0x2c]
0054aea4 : JNC 0x0054aee1
0054aea6 : MOV AL,byte ptr [ECX + 0x6]
0054aea9 : SHR AL,0x6
0054aeac : TEST AL,0x1
0054aeae : MOVZX EAX,word ptr [ECX + 0x2]
0054aeb2 : JZ 0x0054aeb6
0054aeb4 : NEG EAX
0054aeb6 : ADD EDI,EAX
0054aeb8 : MOV dword ptr [ESP + 0xc],EDI
0054aebc : FILD dword ptr [ESP + 0xc]
0054aec0 : FLD float ptr [ESP + 0x10]
0054aec4 : FCOMPP
0054aec6 : FNSTSW AX
0054aec8 : TEST AH,0x5
0054aecb : JNP 0x0054aee1
0054aecd : MOVZX ECX,word ptr [ECX + 0x4]
0054aed1 : SHR ECX,0xc
0054aed4 : ADD EBX,ECX
0054aed6 : LEA ECX,[ESP + 0x28]
0054aeda : CALL 0x005443b0
0054aedf : JMP 0x0054ae98
0054aee1 : MOV EDX,dword ptr [ESI]
0054aee3 : MOV EAX,dword ptr [ESI + 0x8]
0054aee6 : SHR EDX,0x1f
0054aee9 : TEST DL,0x1
0054aeec : JZ 0x0054aefd
0054aeee : AND EAX,0xffffff
0054aef3 : CMP EAX,0xffffff
0054aef8 : JNZ 0x0054aefd
0054aefa : OR EAX,0xffffffff
0054aefd : MOV ECX,dword ptr [ESP + 0x78]
0054af01 : LEA EDI,[EAX + EBX*0x1]
0054af04 : TEST ECX,ECX
0054af06 : JZ 0x0054af0d
0054af08 : CALL 0x004ff7c0
0054af0d : MOV EAX,dword ptr [ESP + 0x74]
0054af11 : TEST EAX,EAX
0054af13 : JZ 0x0054af2b
0054af15 : DEC dword ptr [EAX]
0054af17 : MOV ESI,EAX
0054af19 : CMP dword ptr [ESI],0x0
0054af1c : JNZ 0x0054af2b
0054af1e : MOV ECX,ESI
0054af20 : CALL 0x00500860
0054af25 : PUSH ESI
0054af26 : CALL 0x00515cf0
0054af2b : MOV EAX,EDI
0054af2d : POP EDI
0054af2e : POP EBX
0054af2f : POP ESI
0054af30 : ADD ESP,0x78
0054af33 : RET 0x8
0054af36 : FSTP ST1
0054af38 : FSTP ST0
0054af3a : OR EAX,0xffffffff
0054af3d : POP ESI
0054af3e : ADD ESP,0x78
0054af41 : RET 0x8
