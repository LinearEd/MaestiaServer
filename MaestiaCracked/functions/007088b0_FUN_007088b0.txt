PROGRAM  : Maestia.exe
FUNCTION : FUN_007088b0
ENTRY    : 007088b0
BODY     : [[007088b0, 007088c9] [007088d0, 0070892c] [00708930, 007089d1]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Removing unreachable block (ram,0x00708983) */

void FUN_007088b0(undefined4 param_1)

{
  byte *pbVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  int *in_ECX;
  uint uVar5;
  
  FUN_00707fd0(param_1);
  uVar5 = 0;
  *(undefined2 *)(in_ECX + 0xc) = 0;
  iVar3 = 0;
  do {
    pbVar1 = (byte *)(iVar3 + in_ECX[3]);
    bVar4 = (byte)uVar5;
    uVar5 = uVar5 + 8;
    iVar3 = iVar3 + 1;
    *(ushort *)(in_ECX + 0xc) = *(ushort *)(in_ECX + 0xc) | (ushort)*pbVar1 << (bVar4 & 0x1f);
  } while (uVar5 < 0x10);
  iVar3 = 0;
  *(undefined2 *)((int)in_ECX + 0x32) = 0;
  uVar5 = 0;
  do {
    iVar2 = iVar3 + 2;
    bVar4 = (byte)uVar5;
    uVar5 = uVar5 + 8;
    iVar3 = iVar3 + 1;
    *(ushort *)((int)in_ECX + 0x32) =
         *(ushort *)((int)in_ECX + 0x32) | (ushort)*(byte *)(iVar2 + in_ECX[3]) << (bVar4 & 0x1f);
  } while (uVar5 < 0x10);
  *(undefined1 *)(in_ECX + 0xd) = 0;
  *(undefined1 *)(in_ECX + 0xd) = *(undefined1 *)(in_ECX[3] + 4);
  *(undefined1 *)((int)in_ECX + 0x35) = 0;
  uVar5 = 0;
  *(undefined1 *)((int)in_ECX + 0x35) = *(undefined1 *)(in_ECX[3] + 5);
  *(undefined2 *)((int)in_ECX + 0x36) = 0;
  iVar3 = 0;
  do {
    iVar2 = iVar3 + 6;
    bVar4 = (byte)uVar5;
    uVar5 = uVar5 + 8;
    iVar3 = iVar3 + 1;
    *(ushort *)((int)in_ECX + 0x36) =
         *(ushort *)((int)in_ECX + 0x36) | (ushort)*(byte *)(iVar2 + in_ECX[3]) << (bVar4 & 0x1f);
  } while (uVar5 < 0x10);
  iVar3 = 0;
  in_ECX[0xe] = 0;
  uVar5 = 0;
  do {
    iVar2 = iVar3 + 8;
    bVar4 = (byte)uVar5;
    uVar5 = uVar5 + 8;
    iVar3 = iVar3 + 1;
    in_ECX[0xe] = in_ECX[0xe] | (uint)*(byte *)(iVar2 + in_ECX[3]) << (bVar4 & 0x1f);
  } while (uVar5 < 0x20);
  if (in_ECX[0x10] != in_ECX[0x11]) {
    in_ECX[0x11] = in_ECX[0x10];
  }
  FUN_004d0ff0();
  iVar3 = in_ECX[6];
  iVar2 = in_ECX[0x10];
  uVar5 = 0;
  if (iVar3 != 0xc) {
    do {
      *(undefined1 *)(uVar5 + iVar2) = 0;
      *(undefined1 *)(uVar5 + iVar2) = *(undefined1 *)(uVar5 + 0xc + in_ECX[3]);
      uVar5 = uVar5 + 1;
    } while (uVar5 < iVar3 - 0xcU);
  }
  (**(code **)(*in_ECX + 0x10))();
  return;
}



============================================================
DISASSEMBLY
============================================================
007088b0 : PUSH EBP
007088b1 : MOV EBP,ESP
007088b3 : MOV EAX,dword ptr [EBP + 0x8]
007088b6 : PUSH ESI
007088b7 : PUSH EDI
007088b8 : PUSH EAX
007088b9 : MOV ESI,ECX
007088bb : CALL 0x00707fd0
007088c0 : XOR ECX,ECX
007088c2 : MOV word ptr [ESI + 0x30],CX
007088c6 : XOR EAX,EAX
007088c8 : JMP 0x007088d0
007088d0 : MOV EDX,dword ptr [ESI + 0xc]
007088d3 : MOVZX DX,byte ptr [EAX + EDX*0x1]
007088d8 : SHL DX,CL
007088db : ADD ECX,0x8
007088de : INC EAX
007088df : OR word ptr [ESI + 0x30],DX
007088e3 : CMP ECX,0x10
007088e6 : JC 0x007088d0
007088e8 : XOR EAX,EAX
007088ea : MOV word ptr [ESI + 0x32],AX
007088ee : XOR ECX,ECX
007088f0 : MOV EDX,dword ptr [ESI + 0xc]
007088f3 : MOVZX DX,byte ptr [EAX + EDX*0x1 + 0x2]
007088f9 : SHL DX,CL
007088fc : ADD ECX,0x8
007088ff : INC EAX
00708900 : OR word ptr [ESI + 0x32],DX
00708904 : CMP ECX,0x10
00708907 : JC 0x007088f0
00708909 : MOV byte ptr [ESI + 0x34],0x0
0070890d : MOV EAX,dword ptr [ESI + 0xc]
00708910 : MOV CL,byte ptr [EAX + 0x4]
00708913 : MOV byte ptr [ESI + 0x34],CL
00708916 : MOV byte ptr [ESI + 0x35],0x0
0070891a : MOV EDX,dword ptr [ESI + 0xc]
0070891d : MOV AL,byte ptr [EDX + 0x5]
00708920 : XOR ECX,ECX
00708922 : MOV byte ptr [ESI + 0x35],AL
00708925 : MOV word ptr [ESI + 0x36],CX
00708929 : XOR EAX,EAX
0070892b : JMP 0x00708930
00708930 : MOV EDX,dword ptr [ESI + 0xc]
00708933 : MOVZX DX,byte ptr [EAX + EDX*0x1 + 0x6]
00708939 : SHL DX,CL
0070893c : ADD ECX,0x8
0070893f : INC EAX
00708940 : OR word ptr [ESI + 0x36],DX
00708944 : CMP ECX,0x10
00708947 : JC 0x00708930
00708949 : XOR EAX,EAX
0070894b : MOV dword ptr [ESI + 0x38],0x0
00708952 : XOR ECX,ECX
00708954 : MOV EDX,dword ptr [ESI + 0xc]
00708957 : MOVZX EDX,byte ptr [EAX + EDX*0x1 + 0x8]
0070895c : SHL EDX,CL
0070895e : ADD ECX,0x8
00708961 : INC EAX
00708962 : OR dword ptr [ESI + 0x38],EDX
00708965 : CMP ECX,0x20
00708968 : JC 0x00708954
0070896a : MOV EDX,dword ptr [ESI + 0x40]
0070896d : MOV ECX,dword ptr [ESI + 0x44]
00708970 : LEA EDI,[ESI + 0x3c]
00708973 : CMP EDX,ECX
00708975 : JZ 0x00708993
00708977 : MOV EAX,ECX
00708979 : SUB EAX,ECX
0070897b : PUSH EBX
0070897c : LEA EBX,[EAX + EDX*0x1]
0070897f : TEST EAX,EAX
00708981 : JLE 0x0070898f
00708983 : PUSH EAX
00708984 : PUSH ECX
00708985 : PUSH EAX
00708986 : PUSH EDX
00708987 : CALL 0x00634101
0070898c : ADD ESP,0x10
0070898f : MOV dword ptr [EDI + 0x8],EBX
00708992 : POP EBX
00708993 : MOV EAX,dword ptr [ESI + 0x18]
00708996 : SUB EAX,0xc
00708999 : CALL 0x004d0ff0
0070899e : MOV ECX,dword ptr [ESI + 0x18]
007089a1 : SUB ECX,0xc
007089a4 : MOV EDI,dword ptr [ESI + 0x40]
007089a7 : MOV EAX,0x0
007089ac : JZ 0x007089c3
007089ae : MOV EDI,EDI
007089b0 : MOV byte ptr [EAX + EDI*0x1],0x0
007089b4 : MOV EDX,dword ptr [ESI + 0xc]
007089b7 : MOV DL,byte ptr [EAX + EDX*0x1 + 0xc]
007089bb : MOV byte ptr [EAX + EDI*0x1],DL
007089be : INC EAX
007089bf : CMP EAX,ECX
007089c1 : JC 0x007089b0
007089c3 : MOV EAX,dword ptr [ESI]
007089c5 : MOV EDX,dword ptr [EAX + 0x10]
007089c8 : MOV ECX,ESI
007089ca : CALL EDX
007089cc : POP EDI
007089cd : POP ESI
007089ce : POP EBP
007089cf : RET 0x4
