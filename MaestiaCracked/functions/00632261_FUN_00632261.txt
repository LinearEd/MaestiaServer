PROGRAM  : Maestia.exe
FUNCTION : FUN_00632261
ENTRY    : 00632261
BODY     : [[00632261, 00632382]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Function: __EH_prolog3_GS replaced with injection: EH_prolog3 */

void FUN_00632261(undefined4 *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,ios_base *param_6,undefined4 param_7,uint *param_8,
                 double *param_9)

{
  uint *puVar1;
  double *pdVar2;
  bool bVar3;
  char *pcVar4;
  undefined1 *puVar5;
  money_get<char,class_std::istreambuf_iterator<char,struct_std::char_traits<char>_>_> *in_ECX;
  uint uVar6;
  undefined4 ***pppuVar7;
  float10 fVar8;
  undefined4 **local_54;
  int local_50 [2];
  undefined4 **local_48 [5];
  uint local_34;
  istreambuf_iterator<char,struct_std::char_traits<char>_> local_30 [20];
  uint local_1c;
  undefined4 local_8;
  undefined4 uStack_4;
  
  pdVar2 = param_9;
  puVar1 = param_8;
  uStack_4 = 0x4c;
  local_8 = 0x63226d;
  std::money_get<char,class_std::istreambuf_iterator<char,struct_std::char_traits<char>_>_>::
  _Getmfld(in_ECX,local_30,(istreambuf_iterator<char,struct_std::char_traits<char>_> *)&param_2,
           SUB41(&param_4,0),param_6);
  uVar6 = 0;
  local_8 = 0;
  bVar3 = std::istreambuf_iterator<char,struct_std::char_traits<char>_>::equal
                    ((istreambuf_iterator<char,struct_std::char_traits<char>_> *)&param_2,
                     (istreambuf_iterator<char,struct_std::char_traits<char>_> *)&param_4);
  if (bVar3) {
    *puVar1 = *puVar1 | 1;
  }
  if (local_1c == 0) {
    *puVar1 = *puVar1 | 2;
    goto LAB_00632362;
  }
  FUN_0040eea0();
  local_8 = CONCAT31(local_8._1_3_,1);
  FUN_00435560(local_1c);
  pcVar4 = (char *)FUN_004d3b30(0);
  if (*pcVar4 < '0') {
LAB_006322eb:
    uVar6 = 1;
    FUN_004d12b0(1,0x2d);
  }
  else {
    pcVar4 = (char *)FUN_004d3b30(0);
    if ('9' < *pcVar4) goto LAB_006322eb;
  }
  for (; uVar6 < local_1c; uVar6 = uVar6 + 1) {
    puVar5 = (undefined1 *)FUN_004d3b30(uVar6);
    FUN_004d12b0(1,*puVar5);
  }
  pppuVar7 = (undefined4 ***)local_48[0];
  if (local_34 < 0x10) {
    pppuVar7 = local_48;
  }
  local_50[0] = 0;
  fVar8 = (float10)FUN_00633714(pppuVar7,&local_54,0,local_50);
  if (((undefined4 ***)local_54 == pppuVar7) || (local_50[0] != 0)) {
    *puVar1 = *puVar1 | 2;
  }
  else {
    *pdVar2 = (double)fVar8;
  }
  FUN_00405260(1,0);
LAB_00632362:
  *param_1 = param_2;
  param_1[1] = param_3;
  FUN_00405260(1,0);
  FUN_00640ed0();
  return;
}



============================================================
DISASSEMBLY
============================================================
00632261 : PUSH 0x4c
00632263 : MOV EAX,0xb0c3c1
00632268 : CALL 0x00640e86
0063226d : MOV EAX,dword ptr [EBP + 0x20]
00632270 : MOV EDX,dword ptr [EBP + 0x28]
00632273 : MOV EBX,dword ptr [EBP + 0x8]
00632276 : MOV ESI,dword ptr [EBP + 0x24]
00632279 : PUSH EAX
0063227a : PUSH dword ptr [EBP + 0x1c]
0063227d : LEA EAX,[EBP + 0x14]
00632280 : PUSH EAX
00632281 : LEA EAX,[EBP + 0xc]
00632284 : PUSH EAX
00632285 : LEA EAX,[EBP + -0x2c]
00632288 : PUSH EAX
00632289 : MOV dword ptr [EBP + -0x58],EDX
0063228c : CALL 0x006314a7
00632291 : LEA EAX,[EBP + 0x14]
00632294 : XOR EDI,EDI
00632296 : PUSH EAX
00632297 : LEA ECX,[EBP + 0xc]
0063229a : MOV dword ptr [EBP + -0x4],EDI
0063229d : CALL 0x00623123
006322a2 : TEST AL,AL
006322a4 : JZ 0x006322a9
006322a6 : OR dword ptr [ESI],0x1
006322a9 : CMP dword ptr [EBP + -0x18],EDI
006322ac : JNZ 0x006322b6
006322ae : OR dword ptr [ESI],0x2
006322b1 : JMP 0x00632362
006322b6 : LEA ECX,[EBP + -0x48]
006322b9 : CALL 0x0040eea0
006322be : PUSH dword ptr [EBP + -0x18]
006322c1 : LEA ECX,[EBP + -0x48]
006322c4 : MOV byte ptr [EBP + -0x4],0x1
006322c8 : CALL 0x00435560
006322cd : PUSH 0x0
006322cf : LEA ECX,[EBP + -0x2c]
006322d2 : CALL 0x004d3b30
006322d7 : CMP byte ptr [EAX],0x30
006322da : JL 0x006322eb
006322dc : PUSH 0x0
006322de : LEA ECX,[EBP + -0x2c]
006322e1 : CALL 0x004d3b30
006322e6 : CMP byte ptr [EAX],0x39
006322e9 : JLE 0x00632317
006322eb : XOR EDI,EDI
006322ed : PUSH 0x2d
006322ef : INC EDI
006322f0 : PUSH EDI
006322f1 : LEA ECX,[EBP + -0x48]
006322f4 : CALL 0x004d12b0
006322f9 : JMP 0x00632317
006322fb : PUSH EDI
006322fc : LEA ECX,[EBP + -0x2c]
006322ff : CALL 0x004d3b30
00632304 : MOV AL,byte ptr [EAX]
00632306 : MOV byte ptr [EBP + -0x54],AL
00632309 : PUSH dword ptr [EBP + -0x54]
0063230c : LEA ECX,[EBP + -0x48]
0063230f : PUSH 0x1
00632311 : CALL 0x004d12b0
00632316 : INC EDI
00632317 : CMP EDI,dword ptr [EBP + -0x18]
0063231a : JC 0x006322fb
0063231c : CMP dword ptr [EBP + -0x30],0x10
00632320 : MOV EDI,dword ptr [EBP + -0x44]
00632323 : JNC 0x00632328
00632325 : LEA EDI,[EBP + -0x44]
00632328 : AND dword ptr [EBP + -0x4c],0x0
0063232c : LEA EAX,[EBP + -0x4c]
0063232f : PUSH EAX
00632330 : PUSH 0x0
00632332 : LEA EAX,[EBP + -0x50]
00632335 : PUSH EAX
00632336 : PUSH EDI
00632337 : CALL 0x00633714
0063233c : ADD ESP,0x10
0063233f : CMP dword ptr [EBP + -0x50],EDI
00632342 : JZ 0x00632351
00632344 : CMP dword ptr [EBP + -0x4c],0x0
00632348 : JNZ 0x00632351
0063234a : MOV EAX,dword ptr [EBP + -0x58]
0063234d : FSTP double ptr [EAX]
0063234f : JMP 0x00632356
00632351 : OR dword ptr [ESI],0x2
00632354 : FSTP ST0
00632356 : PUSH 0x0
00632358 : PUSH 0x1
0063235a : LEA ECX,[EBP + -0x48]
0063235d : CALL 0x00405260
00632362 : MOV EAX,dword ptr [EBP + 0xc]
00632365 : MOV dword ptr [EBX],EAX
00632367 : MOV EAX,dword ptr [EBP + 0x10]
0063236a : PUSH 0x0
0063236c : PUSH 0x1
0063236e : LEA ECX,[EBP + -0x2c]
00632371 : MOV dword ptr [EBX + 0x4],EAX
00632374 : CALL 0x00405260
00632379 : MOV EAX,EBX
0063237b : CALL 0x00640ed0
00632380 : RET 0x24
