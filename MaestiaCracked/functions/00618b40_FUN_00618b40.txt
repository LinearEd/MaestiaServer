PROGRAM  : Maestia.exe
FUNCTION : FUN_00618b40
ENTRY    : 00618b40
BODY     : [[00618b40, 00618dd2]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00618b40(int param_1)

{
  int iVar1;
  int iVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  uint uVar5;
  code *pcVar6;
  int iVar7;
  int iVar8;
  float fVar9;
  void *_Base;
  size_t _NumOfElements;
  _PtFuncCompare *_PtFuncCompare;
  
  iVar8 = *(int *)(param_1 + 0x164);
  iVar7 = *(int *)(*(int *)(param_1 + 0x104) + 0x120);
  iVar1 = *(int *)(param_1 + 0x2c0);
  uVar5 = *(int *)(iVar8 + 0xe8) >> 8 & 0xff;
  if (((*(uint *)(iVar8 + 0x68) & 0x8000000) == 0) && (uVar5 != 1)) {
    if (((*(uint *)(iVar8 + 0x68) & 0x40000000) == 0) && (uVar5 != 2)) {
      if ((uVar5 != 4) && (uVar5 != 3)) {
        uVar5 = 0;
      }
    }
    else {
      uVar5 = 2;
    }
  }
  else {
    uVar5 = 1;
  }
  iVar2 = *(int *)(iVar1 + 0x90);
  if ((*(byte *)(iVar1 + 0xc) & 0x10) == 0) {
    *(undefined4 *)(iVar2 + 0x18) = 0;
  }
  *(undefined4 *)(iVar2 + 0x28) = 0;
  if (DAT_00d7b3e0 == 0) {
    puVar3 = *(undefined4 **)(*(int *)(param_1 + 0x104) + 0x124);
  }
  else {
    puVar3 = (undefined4 *)(*(int *)(*(int *)(param_1 + 800) + 0x14) + 0x10);
  }
  while ((puVar4 = puVar3, iVar7 != 0 && (puVar4 != (undefined4 *)0x0))) {
    puVar3 = (undefined4 *)*puVar4;
    iVar7 = iVar7 + -1;
    if ((float)puVar4[0x14] < (float)puVar4[7]) {
      if (*(int *)(iVar8 + 0x124) != 0) {
        if ((*(byte *)(iVar8 + 0x68) & 2) != 0) {
          *(int *)(iVar8 + 0x128) = puVar4[0x17] * 0x120 + *(int *)(iVar8 + 300);
          *(undefined4 *)(param_1 + 0x160) = puVar4[0x17];
        }
        if ((*(int *)(iVar8 + 0x124) != 0) && ((*(byte *)(iVar8 + 0x68) & 1) != 0)) {
          *(int *)(iVar8 + 0x128) = puVar4[0x17] * 0x120 + *(int *)(iVar8 + 300);
          *(undefined4 *)(param_1 + 0x160) = puVar4[0x17];
        }
      }
      if ((uVar5 == 2) || ((*(uint *)(iVar1 + 0xc) & 0x18) == 0)) {
        pcVar6 = *(code **)(param_1 + 0x290);
        if (((pcVar6 != (code *)0x0) && ((*(byte *)(param_1 + 0x100) & 4) != 0)) ||
           ((pcVar6 = *(code **)(param_1 + 0x280), pcVar6 != (code *)0x0 &&
            ((*(byte *)(param_1 + 0x100) & 4) != 0)))) {
          (*pcVar6)(param_1,puVar4);
        }
      }
      else {
        if ((*(uint *)(iVar1 + 0xc) & 2) == 0) {
          fVar9 = 0.0;
        }
        else {
          fVar9 = (float)puVar4[0xb] * *(float *)(iVar1 + 0x58) +
                  (float)puVar4[10] * *(float *)(iVar1 + 0x48) +
                  (float)puVar4[9] * *(float *)(iVar1 + 0x38) +
                  *(float *)(iVar1 + 0x28) * (float)puVar4[8];
        }
        puVar4[0xb] = fVar9;
        *(undefined4 **)(*(int *)(iVar2 + 0x1c) + *(int *)(iVar2 + 0x18) * 4) = puVar4;
        *(int *)(iVar2 + 0x18) = *(int *)(iVar2 + 0x18) + 1;
      }
    }
    else if (*(int *)(iVar2 + 0x28) < 0x2000) {
      *(undefined4 **)(*(int *)(iVar2 + 0x2c) + *(int *)(iVar2 + 0x28) * 4) = puVar4;
      *(int *)(iVar2 + 0x28) = *(int *)(iVar2 + 0x28) + 1;
    }
  }
  if (((uVar5 != 2) && (uVar5 = *(uint *)(iVar1 + 0xc), (uVar5 & 8) != 0)) && ((uVar5 & 0x10) == 0))
  {
    if ((uVar5 & 4) == 0) {
      _NumOfElements = *(size_t *)(iVar2 + 0x18);
      _Base = *(void **)(iVar2 + 0x1c);
      _PtFuncCompare = (_PtFuncCompare *)&LAB_0061c670;
    }
    else {
      _NumOfElements = *(size_t *)(iVar2 + 0x18);
      _Base = *(void **)(iVar2 + 0x1c);
      _PtFuncCompare = (_PtFuncCompare *)&LAB_0061c630;
    }
    _qsort(_Base,_NumOfElements,4,_PtFuncCompare);
    iVar8 = 0;
    if (0 < *(int *)(iVar2 + 0x18)) {
      do {
        iVar7 = *(int *)(*(int *)(iVar2 + 0x1c) + iVar8 * 4);
        *(undefined4 *)(iVar7 + 0x2c) = 0;
        pcVar6 = *(code **)(param_1 + 0x290);
        if (((pcVar6 != (code *)0x0) && ((*(byte *)(param_1 + 0x100) & 4) != 0)) ||
           ((pcVar6 = *(code **)(param_1 + 0x280), pcVar6 != (code *)0x0 &&
            ((*(byte *)(param_1 + 0x100) & 4) != 0)))) {
          (*pcVar6)(param_1,iVar7);
        }
        iVar8 = iVar8 + 1;
      } while (iVar8 < *(int *)(iVar2 + 0x18));
    }
    *(undefined4 *)(iVar2 + 0x18) = 0;
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00618b40 : SUB ESP,0x8
00618b43 : PUSH EBX
00618b44 : PUSH EBP
00618b45 : PUSH ESI
00618b46 : MOV ESI,dword ptr [ESP + 0x18]
00618b4a : MOV EAX,dword ptr [ESI + 0x104]
00618b50 : MOV EBP,dword ptr [ESI + 0x164]
00618b56 : MOV EDX,dword ptr [EAX + 0x120]
00618b5c : MOV EAX,dword ptr [EBP + 0xe8]
00618b62 : MOV ECX,dword ptr [EBP + 0x68]
00618b65 : MOV EBX,dword ptr [ESI + 0x2c0]
00618b6b : SAR EAX,0x8
00618b6e : AND EAX,0xff
00618b73 : PUSH EDI
00618b74 : TEST ECX,0x8000000
00618b7a : JNZ 0x00618ba7
00618b7c : CMP EAX,0x1
00618b7f : JZ 0x00618ba7
00618b81 : TEST ECX,0x40000000
00618b87 : JNZ 0x00618ba0
00618b89 : CMP EAX,0x2
00618b8c : JZ 0x00618ba0
00618b8e : CMP EAX,0x4
00618b91 : JNZ 0x00618b95
00618b93 : JMP 0x00618bac
00618b95 : CMP EAX,0x3
00618b98 : JNZ 0x00618b9c
00618b9a : JMP 0x00618bac
00618b9c : XOR EAX,EAX
00618b9e : JMP 0x00618bac
00618ba0 : MOV EAX,0x2
00618ba5 : JMP 0x00618bac
00618ba7 : MOV EAX,0x1
00618bac : MOV EDI,dword ptr [EBX + 0x90]
00618bb2 : XOR ECX,ECX
00618bb4 : CMP EAX,0x2
00618bb7 : SETZ CL
00618bba : TEST byte ptr [EBX + 0xc],0x10
00618bbe : MOV dword ptr [ESP + 0x10],ECX
00618bc2 : JNZ 0x00618bcb
00618bc4 : MOV dword ptr [EDI + 0x18],0x0
00618bcb : MOV dword ptr [EDI + 0x28],0x0
00618bd2 : CMP dword ptr [0x00d7b3e0],0x0
00618bd9 : JZ 0x00618be9
00618bdb : MOV EAX,dword ptr [ESI + 0x320]
00618be1 : MOV EAX,dword ptr [EAX + 0x14]
00618be4 : ADD EAX,0x10
00618be7 : JMP 0x00618bf5
00618be9 : MOV ECX,dword ptr [ESI + 0x104]
00618bef : MOV EAX,dword ptr [ECX + 0x124]
00618bf5 : TEST EDX,EDX
00618bf7 : JZ 0x00618d32
00618bfd : LEA ECX,[ECX]
00618c00 : TEST EAX,EAX
00618c02 : JZ 0x00618d32
00618c08 : MOV ECX,dword ptr [EAX]
00618c0a : MOVSS XMM0,dword ptr [EAX + 0x50]
00618c0f : DEC EDX
00618c10 : COMISS XMM0,dword ptr [EAX + 0x1c]
00618c14 : MOV dword ptr [ESP + 0x1c],ECX
00618c18 : MOV dword ptr [ESP + 0x14],EDX
00618c1c : JC 0x00618c3b
00618c1e : MOV ECX,dword ptr [EDI + 0x28]
00618c21 : CMP ECX,0x2000
00618c27 : JGE 0x00618d22
00618c2d : MOV EDX,dword ptr [EDI + 0x2c]
00618c30 : MOV dword ptr [EDX + ECX*0x4],EAX
00618c33 : INC dword ptr [EDI + 0x28]
00618c36 : JMP 0x00618d22
00618c3b : CMP dword ptr [EBP + 0x124],0x0
00618c42 : JZ 0x00618c95
00618c44 : TEST byte ptr [EBP + 0x68],0x2
00618c48 : JZ 0x00618c68
00618c4a : MOV ECX,dword ptr [EAX + 0x5c]
00618c4d : LEA ECX,[ECX + ECX*0x8]
00618c50 : SHL ECX,0x5
00618c53 : ADD ECX,dword ptr [EBP + 0x12c]
00618c59 : MOV dword ptr [EBP + 0x128],ECX
00618c5f : MOV EDX,dword ptr [EAX + 0x5c]
00618c62 : MOV dword ptr [ESI + 0x160],EDX
00618c68 : CMP dword ptr [EBP + 0x124],0x0
00618c6f : JZ 0x00618c95
00618c71 : TEST byte ptr [EBP + 0x68],0x1
00618c75 : JZ 0x00618c95
00618c77 : MOV ECX,dword ptr [EAX + 0x5c]
00618c7a : LEA ECX,[ECX + ECX*0x8]
00618c7d : SHL ECX,0x5
00618c80 : ADD ECX,dword ptr [EBP + 0x12c]
00618c86 : MOV dword ptr [EBP + 0x128],ECX
00618c8c : MOV EDX,dword ptr [EAX + 0x5c]
00618c8f : MOV dword ptr [ESI + 0x160],EDX
00618c95 : CMP dword ptr [ESP + 0x10],0x0
00618c9a : JNZ 0x00618cf5
00618c9c : MOV ECX,dword ptr [EBX + 0xc]
00618c9f : TEST CL,0x18
00618ca2 : JZ 0x00618cf5
00618ca4 : TEST CL,0x2
00618ca7 : JZ 0x00618cdf
00618ca9 : MOVSS XMM0,dword ptr [EAX + 0x2c]
00618cae : MULSS XMM0,dword ptr [EBX + 0x58]
00618cb3 : MOVSS XMM1,dword ptr [EAX + 0x28]
00618cb8 : MULSS XMM1,dword ptr [EBX + 0x48]
00618cbd : ADDSS XMM0,XMM1
00618cc1 : MOVSS XMM1,dword ptr [EAX + 0x24]
00618cc6 : MULSS XMM1,dword ptr [EBX + 0x38]
00618ccb : ADDSS XMM0,XMM1
00618ccf : MOVSS XMM1,dword ptr [EBX + 0x28]
00618cd4 : MULSS XMM1,dword ptr [EAX + 0x20]
00618cd9 : ADDSS XMM0,XMM1
00618cdd : JMP 0x00618ce2
00618cdf : XORPS XMM0,XMM0
00618ce2 : MOVSS dword ptr [EAX + 0x2c],XMM0
00618ce7 : MOV ECX,dword ptr [EDI + 0x18]
00618cea : MOV EDX,dword ptr [EDI + 0x1c]
00618ced : MOV dword ptr [EDX + ECX*0x4],EAX
00618cf0 : INC dword ptr [EDI + 0x18]
00618cf3 : JMP 0x00618d22
00618cf5 : MOV ECX,dword ptr [ESI + 0x290]
00618cfb : TEST ECX,ECX
00618cfd : JZ 0x00618d08
00618cff : TEST byte ptr [ESI + 0x100],0x4
00618d06 : JNZ 0x00618d1b
00618d08 : MOV ECX,dword ptr [ESI + 0x280]
00618d0e : TEST ECX,ECX
00618d10 : JZ 0x00618d22
00618d12 : TEST byte ptr [ESI + 0x100],0x4
00618d19 : JZ 0x00618d22
00618d1b : PUSH EAX
00618d1c : PUSH ESI
00618d1d : CALL ECX
00618d1f : ADD ESP,0x8
00618d22 : MOV EDX,dword ptr [ESP + 0x14]
00618d26 : MOV EAX,dword ptr [ESP + 0x1c]
00618d2a : TEST EDX,EDX
00618d2c : JNZ 0x00618c00
00618d32 : CMP dword ptr [ESP + 0x10],0x0
00618d37 : JNZ 0x00618dcb
00618d3d : MOV EAX,dword ptr [EBX + 0xc]
00618d40 : TEST AL,0x8
00618d42 : JZ 0x00618dcb
00618d48 : TEST AL,0x10
00618d4a : JNZ 0x00618dcb
00618d50 : TEST AL,0x4
00618d52 : JZ 0x00618d65
00618d54 : MOV EAX,dword ptr [EDI + 0x18]
00618d57 : MOV ECX,dword ptr [EDI + 0x1c]
00618d5a : PUSH 0x61c630
00618d5f : PUSH 0x4
00618d61 : PUSH EAX
00618d62 : PUSH ECX
00618d63 : JMP 0x00618d74
00618d65 : MOV EDX,dword ptr [EDI + 0x18]
00618d68 : MOV EAX,dword ptr [EDI + 0x1c]
00618d6b : PUSH 0x61c670
00618d70 : PUSH 0x4
00618d72 : PUSH EDX
00618d73 : PUSH EAX
00618d74 : CALL 0x00635ad0
00618d79 : XOR EBP,EBP
00618d7b : ADD ESP,0x10
00618d7e : CMP dword ptr [EDI + 0x18],EBP
00618d81 : JLE 0x00618dc4
00618d83 : MOV ECX,dword ptr [EDI + 0x1c]
00618d86 : MOV EAX,dword ptr [ECX + EBP*0x4]
00618d89 : XORPS XMM0,XMM0
00618d8c : MOVSS dword ptr [EAX + 0x2c],XMM0
00618d91 : MOV ECX,dword ptr [ESI + 0x290]
00618d97 : TEST ECX,ECX
00618d99 : JZ 0x00618da4
00618d9b : TEST byte ptr [ESI + 0x100],0x4
00618da2 : JNZ 0x00618db7
00618da4 : MOV ECX,dword ptr [ESI + 0x280]
00618daa : TEST ECX,ECX
00618dac : JZ 0x00618dbe
00618dae : TEST byte ptr [ESI + 0x100],0x4
00618db5 : JZ 0x00618dbe
00618db7 : PUSH EAX
00618db8 : PUSH ESI
00618db9 : CALL ECX
00618dbb : ADD ESP,0x8
00618dbe : INC EBP
00618dbf : CMP EBP,dword ptr [EDI + 0x18]
00618dc2 : JL 0x00618d83
00618dc4 : MOV dword ptr [EDI + 0x18],0x0
00618dcb : POP EDI
00618dcc : POP ESI
00618dcd : POP EBP
00618dce : POP EBX
00618dcf : ADD ESP,0x8
00618dd2 : RET
