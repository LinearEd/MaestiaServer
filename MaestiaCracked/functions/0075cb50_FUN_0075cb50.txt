PROGRAM  : Maestia.exe
FUNCTION : FUN_0075cb50
ENTRY    : 0075cb50
BODY     : [[0075cb50, 0075cc0c] [0075cc10, 0075cd0f]]

============================================================
DECOMPILED C CODE
============================================================

undefined4 FUN_0075cb50(byte *param_1,byte *param_2,size_t param_3,undefined4 *param_4)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  int iVar4;
  void *pvVar5;
  int in_ECX;
  byte *pbVar6;
  byte *pbVar7;
  int iVar8;
  bool bVar9;
  
  iVar8 = 0;
  *param_4 = 0;
  pbVar6 = (byte *)(in_ECX + 0x10c18);
  pbVar3 = param_1;
  pbVar7 = pbVar6;
LAB_0075cb74:
  do {
    bVar1 = *pbVar3;
    bVar9 = bVar1 < *pbVar6;
    if (bVar1 == *pbVar6) {
      if (bVar1 != 0) {
        bVar1 = pbVar3[1];
        bVar9 = bVar1 < pbVar6[1];
        if (bVar1 != pbVar6[1]) goto LAB_0075cb94;
        pbVar6 = pbVar6 + 2;
        pbVar3 = pbVar3 + 2;
        if (bVar1 != 0) goto LAB_0075cb74;
      }
      iVar4 = 0;
    }
    else {
LAB_0075cb94:
      iVar4 = (1 - (uint)bVar9) - (uint)(bVar9 != 0);
    }
    if (iVar4 == 0) break;
    iVar8 = iVar8 + 1;
    pbVar6 = pbVar7 + 0x10c;
    pbVar3 = param_1;
    pbVar7 = pbVar6;
  } while (iVar8 < 0x80);
  iVar8 = iVar8 * 0x10c + in_ECX;
  pbVar6 = (byte *)(iVar8 + 0x10c18);
  do {
    bVar1 = *param_1;
    bVar9 = bVar1 < *pbVar6;
    if (bVar1 != *pbVar6) {
LAB_0075cbe3:
      iVar4 = (1 - (uint)bVar9) - (uint)(bVar9 != 0);
      goto LAB_0075cbe8;
    }
    if (bVar1 == 0) break;
    bVar1 = param_1[1];
    bVar9 = bVar1 < pbVar6[1];
    if (bVar1 != pbVar6[1]) goto LAB_0075cbe3;
    param_1 = param_1 + 2;
    pbVar6 = pbVar6 + 2;
  } while (bVar1 != 0);
  iVar4 = 0;
LAB_0075cbe8:
  if (iVar4 != 0) {
    return 0;
  }
  pbVar6 = *(byte **)(iVar8 + 0x10d20);
  uVar2 = param_3;
  pbVar3 = param_2;
  if (pbVar6 == (byte *)0x0) {
LAB_0075cc99:
    if (0 < *(int *)(iVar8 + 0x10d1c)) {
      *param_4 = *(undefined4 *)(iVar8 + 0x10d18);
      *(undefined4 *)(iVar8 + 0x10d18) = 0;
    }
    pvVar5 = _malloc(param_3);
    _memcpy(pvVar5,param_2,param_3);
    *(void **)(iVar8 + 0x10d18) = pvVar5;
    *(size_t *)(iVar8 + 0x10d1c) = param_3;
    FUN_006144d0(pvVar5);
    pvVar5 = _malloc(param_3);
    *(void **)(iVar8 + 0x10d20) = pvVar5;
    _memcpy(pvVar5,param_2,param_3);
    return *(undefined4 *)(iVar8 + 0x10d18);
  }
  for (; 3 < uVar2; uVar2 = uVar2 - 4) {
    if (*(int *)pbVar6 != *(int *)pbVar3) goto LAB_0075cc28;
    pbVar6 = pbVar6 + 4;
    pbVar3 = pbVar3 + 4;
  }
  if (uVar2 != 0) {
LAB_0075cc28:
    iVar4 = (uint)*pbVar6 - (uint)*pbVar3;
    if (iVar4 == 0) {
      if (uVar2 < 2) goto LAB_0075cc6e;
      iVar4 = (uint)pbVar6[1] - (uint)pbVar3[1];
      if (iVar4 == 0) {
        if (uVar2 < 3) goto LAB_0075cc6e;
        iVar4 = (uint)pbVar6[2] - (uint)pbVar3[2];
        if (iVar4 == 0) {
          if (uVar2 < 4) goto LAB_0075cc6e;
          iVar4 = (uint)pbVar6[3] - (uint)pbVar3[3];
        }
      }
    }
    if ((iVar4 >> 0x1f | 1U) != 0) {
      _free(*(void **)(iVar8 + 0x10d20));
      *(undefined4 *)(iVar8 + 0x10d20) = 0;
      goto LAB_0075cc99;
    }
  }
LAB_0075cc6e:
  return *(undefined4 *)(iVar8 + 0x10d18);
}



============================================================
DISASSEMBLY
============================================================
0075cb50 : PUSH EBP
0075cb51 : MOV EBP,ESP
0075cb53 : PUSH ECX
0075cb54 : MOV EAX,dword ptr [EBP + 0x14]
0075cb57 : PUSH EBX
0075cb58 : PUSH ESI
0075cb59 : XOR ESI,ESI
0075cb5b : PUSH EDI
0075cb5c : MOV EDI,dword ptr [EBP + 0x8]
0075cb5f : MOV dword ptr [EBP + -0x4],ECX
0075cb62 : MOV dword ptr [EAX],ESI
0075cb64 : LEA EBX,[ECX + 0x10c18]
0075cb6a : LEA EBX,[EBX]
0075cb70 : MOV EDX,EBX
0075cb72 : MOV EAX,EDI
0075cb74 : MOV CL,byte ptr [EAX]
0075cb76 : CMP CL,byte ptr [EDX]
0075cb78 : JNZ 0x0075cb94
0075cb7a : TEST CL,CL
0075cb7c : JZ 0x0075cb90
0075cb7e : MOV CL,byte ptr [EAX + 0x1]
0075cb81 : CMP CL,byte ptr [EDX + 0x1]
0075cb84 : JNZ 0x0075cb94
0075cb86 : ADD EAX,0x2
0075cb89 : ADD EDX,0x2
0075cb8c : TEST CL,CL
0075cb8e : JNZ 0x0075cb74
0075cb90 : XOR EAX,EAX
0075cb92 : JMP 0x0075cb99
0075cb94 : SBB EAX,EAX
0075cb96 : SBB EAX,-0x1
0075cb99 : TEST EAX,EAX
0075cb9b : JZ 0x0075cbac
0075cb9d : INC ESI
0075cb9e : ADD EBX,0x10c
0075cba4 : CMP ESI,0x80
0075cbaa : JL 0x0075cb70
0075cbac : MOV ECX,dword ptr [EBP + -0x4]
0075cbaf : IMUL ESI,ESI,0x10c
0075cbb5 : LEA EBX,[ESI + ECX*0x1]
0075cbb8 : MOV dword ptr [EBP + 0x8],EBX
0075cbbb : LEA ECX,[EBX + 0x10c18]
0075cbc1 : MOV EAX,EDI
0075cbc3 : MOV DL,byte ptr [EAX]
0075cbc5 : CMP DL,byte ptr [ECX]
0075cbc7 : JNZ 0x0075cbe3
0075cbc9 : TEST DL,DL
0075cbcb : JZ 0x0075cbdf
0075cbcd : MOV DL,byte ptr [EAX + 0x1]
0075cbd0 : CMP DL,byte ptr [ECX + 0x1]
0075cbd3 : JNZ 0x0075cbe3
0075cbd5 : ADD EAX,0x2
0075cbd8 : ADD ECX,0x2
0075cbdb : TEST DL,DL
0075cbdd : JNZ 0x0075cbc3
0075cbdf : XOR EAX,EAX
0075cbe1 : JMP 0x0075cbe8
0075cbe3 : SBB EAX,EAX
0075cbe5 : SBB EAX,-0x1
0075cbe8 : TEST EAX,EAX
0075cbea : JNZ 0x0075cd05
0075cbf0 : MOV EDX,dword ptr [EBX + 0x10d20]
0075cbf6 : MOV EDI,dword ptr [EBP + 0x10]
0075cbf9 : TEST EDX,EDX
0075cbfb : JZ 0x0075cc99
0075cc01 : MOV ECX,dword ptr [EBP + 0xc]
0075cc04 : MOV ESI,EDI
0075cc06 : CMP EDI,0x4
0075cc09 : JC 0x0075cc24
0075cc0b : JMP 0x0075cc10
0075cc10 : MOV EAX,dword ptr [EDX]
0075cc12 : CMP EAX,dword ptr [ECX]
0075cc14 : JNZ 0x0075cc28
0075cc16 : SUB ESI,0x4
0075cc19 : ADD ECX,0x4
0075cc1c : ADD EDX,0x4
0075cc1f : CMP ESI,0x4
0075cc22 : JNC 0x0075cc10
0075cc24 : TEST ESI,ESI
0075cc26 : JZ 0x0075cc6e
0075cc28 : MOVZX EBX,byte ptr [ECX]
0075cc2b : MOVZX EAX,byte ptr [EDX]
0075cc2e : SUB EAX,EBX
0075cc30 : JNZ 0x0075cc63
0075cc32 : CMP ESI,0x1
0075cc35 : JBE 0x0075cc6b
0075cc37 : MOVZX EAX,byte ptr [EDX + 0x1]
0075cc3b : MOVZX EBX,byte ptr [ECX + 0x1]
0075cc3f : SUB EAX,EBX
0075cc41 : JNZ 0x0075cc63
0075cc43 : CMP ESI,0x2
0075cc46 : JBE 0x0075cc6b
0075cc48 : MOVZX EAX,byte ptr [EDX + 0x2]
0075cc4c : MOVZX EBX,byte ptr [ECX + 0x2]
0075cc50 : SUB EAX,EBX
0075cc52 : JNZ 0x0075cc63
0075cc54 : CMP ESI,0x3
0075cc57 : JBE 0x0075cc6b
0075cc59 : MOVZX EAX,byte ptr [EDX + 0x3]
0075cc5d : MOVZX ECX,byte ptr [ECX + 0x3]
0075cc61 : SUB EAX,ECX
0075cc63 : SAR EAX,0x1f
0075cc66 : OR EAX,0x1
0075cc69 : JNZ 0x0075cc7d
0075cc6b : MOV EBX,dword ptr [EBP + 0x8]
0075cc6e : MOV EAX,dword ptr [EBX + 0x10d18]
0075cc74 : POP EDI
0075cc75 : POP ESI
0075cc76 : POP EBX
0075cc77 : MOV ESP,EBP
0075cc79 : POP EBP
0075cc7a : RET 0x10
0075cc7d : MOV EBX,dword ptr [EBP + 0x8]
0075cc80 : MOV EAX,dword ptr [EBX + 0x10d20]
0075cc86 : PUSH EAX
0075cc87 : CALL 0x0063610d
0075cc8c : ADD ESP,0x4
0075cc8f : MOV dword ptr [EBX + 0x10d20],0x0
0075cc99 : CMP dword ptr [EBX + 0x10d1c],0x0
0075cca0 : JLE 0x0075ccb7
0075cca2 : MOV EDX,dword ptr [EBX + 0x10d18]
0075cca8 : MOV EAX,dword ptr [EBP + 0x14]
0075ccab : MOV dword ptr [EAX],EDX
0075ccad : MOV dword ptr [EBX + 0x10d18],0x0
0075ccb7 : PUSH EDI
0075ccb8 : CALL 0x00636043
0075ccbd : MOV ECX,dword ptr [EBP + 0xc]
0075ccc0 : PUSH EDI
0075ccc1 : MOV ESI,EAX
0075ccc3 : PUSH ECX
0075ccc4 : PUSH ESI
0075ccc5 : CALL 0x0063ae40
0075ccca : PUSH ESI
0075cccb : MOV dword ptr [EBX + 0x10d18],ESI
0075ccd1 : MOV dword ptr [EBX + 0x10d1c],EDI
0075ccd7 : CALL 0x006144d0
0075ccdc : PUSH EDI
0075ccdd : CALL 0x00636043
0075cce2 : MOV EDX,dword ptr [EBP + 0xc]
0075cce5 : PUSH EDI
0075cce6 : PUSH EDX
0075cce7 : PUSH EAX
0075cce8 : MOV dword ptr [EBX + 0x10d20],EAX
0075ccee : CALL 0x0063ae40
0075ccf3 : MOV EAX,dword ptr [EBX + 0x10d18]
0075ccf9 : ADD ESP,0x24
0075ccfc : POP EDI
0075ccfd : POP ESI
0075ccfe : POP EBX
0075ccff : MOV ESP,EBP
0075cd01 : POP EBP
0075cd02 : RET 0x10
0075cd05 : POP EDI
0075cd06 : POP ESI
0075cd07 : XOR EAX,EAX
0075cd09 : POP EBX
0075cd0a : MOV ESP,EBP
0075cd0c : POP EBP
0075cd0d : RET 0x10
