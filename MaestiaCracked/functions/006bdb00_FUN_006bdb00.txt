PROGRAM  : Maestia.exe
FUNCTION : FUN_006bdb00
ENTRY    : 006bdb00
BODY     : [[006bdb00, 006bdb98] [006bdba0, 006bde28]]

============================================================
DECOMPILED C CODE
============================================================

int FUN_006bdb00(void)

{
  short *psVar1;
  int *piVar2;
  short sVar3;
  short sVar4;
  undefined4 uVar5;
  bool bVar6;
  int in_EAX;
  int iVar7;
  int iVar8;
  undefined4 uVar9;
  short *psVar10;
  undefined4 *in_ECX;
  int iVar11;
  undefined1 *puVar12;
  byte *pbVar13;
  short *psVar14;
  short *psVar15;
  undefined1 *puVar16;
  undefined1 *puVar17;
  undefined4 uVar18;
  int iVar19;
  int local_2c;
  int local_24;
  int local_20;
  int local_18;
  int local_14;
  short *local_10;
  short *local_4;
  
  piVar2 = in_ECX + in_EAX * 7 + 0xc;
  uVar5 = *in_ECX;
  psVar10 = (short *)piVar2[2];
  iVar11 = in_EAX * 0x18c + 0x24 + in_ECX[0x1c];
  iVar19 = *piVar2;
  piVar2[3] = 0;
  if (in_EAX == 0) {
    uVar18 = in_ECX[1];
  }
  else {
    uVar18 = in_ECX[3];
  }
  iVar7 = FUN_00685ea0(*(undefined4 *)(iVar11 + 0xcc),uVar18);
  if (iVar7 < 0x11) {
    local_2c = *(int *)(iVar11 + 0xcc);
  }
  else {
    local_2c = FUN_00685f30(0x10,uVar18);
  }
  if (psVar10 < psVar10 + iVar19 * 0x1a) {
    psVar15 = psVar10 + 1;
    do {
      local_10 = (short *)0x0;
      local_18 = 0xffff;
      if (piVar2[3] < 1) {
LAB_006bdc60:
        iVar11 = FUN_006bb5c0((int)*psVar15,(int)*(char *)((int)psVar15 + -1),uVar5,&local_4);
        psVar14 = local_4;
        if (iVar11 != 0) {
          return iVar11;
        }
        _memset(local_4,0,0x30);
        psVar1 = psVar15 + -1;
        *(short **)(psVar14 + 0x14) = psVar1;
        *(short **)(psVar14 + 0x16) = psVar1;
        *psVar14 = *psVar15;
        uVar9 = FUN_00685ea0((int)*psVar15,uVar18);
        *(undefined4 *)(psVar14 + 4) = uVar9;
        *(undefined4 *)(psVar14 + 2) = uVar9;
        *(short **)(psVar15 + 7) = psVar1;
        *(undefined1 *)((int)psVar14 + 0xd) = *(undefined1 *)((int)psVar15 + -1);
      }
      else {
        local_14 = piVar2[3];
        psVar14 = (short *)piVar2[5];
        do {
          if (*(char *)((int)psVar14 + 0xd) == *(char *)((int)psVar15 + -1)) {
            iVar11 = (int)*psVar15 - (int)*psVar14;
            if (iVar11 < 0) {
              iVar11 = -iVar11;
            }
            if ((iVar11 < local_2c) && (iVar11 < local_18)) {
              if (*(int *)(psVar15 + 9) != 0) {
                iVar8 = 0;
                iVar7 = *(int *)(psVar14 + 0x14);
                do {
                  if (*(int *)(iVar7 + 0x14) != 0) {
                    sVar3 = *(short *)(*(int *)(psVar15 + 9) + 2);
                    sVar4 = *(short *)(*(int *)(iVar7 + 0x14) + 2);
                    if (sVar4 < sVar3) {
                      iVar8 = (int)sVar3 - (int)sVar4;
                    }
                    else {
                      iVar8 = (int)sVar4 - (int)sVar3;
                    }
                    if (local_2c <= iVar8) goto LAB_006bdc46;
                  }
                  iVar7 = *(int *)(iVar7 + 0x10);
                } while (iVar7 != *(int *)(psVar14 + 0x14));
                if (local_2c <= iVar8) goto LAB_006bdc46;
              }
              local_18 = iVar11;
              local_10 = psVar14;
            }
          }
LAB_006bdc46:
          psVar14 = psVar14 + 0x18;
          local_14 = local_14 + -1;
        } while (local_14 != 0);
        if (local_10 == (short *)0x0) goto LAB_006bdc60;
        *(undefined4 *)(psVar15 + 7) = *(undefined4 *)(local_10 + 0x14);
        *(short **)(*(int *)(local_10 + 0x16) + 0x10) = psVar15 + -1;
        *(short **)(local_10 + 0x16) = psVar15 + -1;
      }
      psVar14 = psVar15 + 0x19;
      psVar15 = psVar15 + 0x1a;
    } while (psVar14 < psVar10 + iVar19 * 0x1a);
  }
  puVar17 = (undefined1 *)piVar2[5];
  puVar16 = puVar17 + piVar2[3] * 0x30;
  puVar12 = puVar17;
  if (puVar17 < puVar16) {
    do {
      iVar11 = *(int *)(puVar12 + 0x28);
      if (iVar11 != 0) {
        do {
          *(undefined1 **)(iVar11 + 0xc) = puVar12;
          iVar11 = *(int *)(iVar11 + 0x10);
        } while (iVar11 != *(int *)(puVar12 + 0x28));
      }
      puVar12 = puVar12 + 0x30;
    } while (puVar12 < puVar16);
    if (puVar17 < puVar16) {
      puVar17 = puVar17 + 0xc;
      do {
        pbVar13 = *(byte **)(puVar17 + 0x1c);
        local_20 = 0;
        local_24 = 0;
        do {
          if ((*pbVar13 & 1) == 0) {
            local_24 = local_24 + 1;
          }
          else {
            local_20 = local_20 + 1;
          }
          iVar11 = *(int *)(pbVar13 + 0x18);
          if ((iVar11 == 0) || (*(undefined1 **)(iVar11 + 0xc) == puVar17 + -0xc)) {
            bVar6 = false;
          }
          else {
            bVar6 = true;
          }
          if ((*(int *)(pbVar13 + 0x14) != 0) || (bVar6)) {
            psVar10 = *(short **)(puVar17 + 0xc);
            iVar19 = *(int *)(pbVar13 + 0x14);
            if (bVar6) {
              psVar10 = *(short **)(puVar17 + 0x10);
              iVar19 = iVar11;
            }
            if (psVar10 == (short *)0x0) {
LAB_006bddc5:
              psVar10 = *(short **)(iVar19 + 0xc);
            }
            else {
              iVar11 = (int)*(short *)(puVar17 + -0xc) - (int)*psVar10;
              if (iVar11 < 0) {
                iVar11 = -iVar11;
              }
              sVar3 = *(short *)(iVar19 + 2);
              sVar4 = *(short *)(pbVar13 + 2);
              if (sVar3 < sVar4) {
                iVar7 = (int)sVar4;
                iVar8 = (int)sVar3;
              }
              else {
                iVar8 = (int)sVar4;
                iVar7 = (int)sVar3;
              }
              if (iVar7 - iVar8 < iVar11) goto LAB_006bddc5;
            }
            if (bVar6) {
              *(short **)(puVar17 + 0x10) = psVar10;
              *(byte *)(psVar10 + 6) = *(byte *)(psVar10 + 6) | 2;
            }
            else {
              *(short **)(puVar17 + 0xc) = psVar10;
            }
          }
          pbVar13 = *(byte **)(pbVar13 + 0x10);
        } while (pbVar13 != *(byte **)(puVar17 + 0x1c));
        *puVar17 = 0;
        if ((0 < local_20) && (local_24 <= local_20)) {
          *puVar17 = 1;
        }
        if ((*(int *)(puVar17 + 0x10) != 0) && (*(int *)(puVar17 + 0xc) != 0)) {
          *(undefined4 *)(puVar17 + 0x10) = 0;
        }
        puVar12 = puVar17 + 0x24;
        puVar17 = puVar17 + 0x30;
      } while (puVar12 < puVar16);
    }
  }
  return 0;
}



============================================================
DISASSEMBLY
============================================================
006bdb00 : SUB ESP,0x2c
006bdb03 : PUSH EBX
006bdb04 : LEA EDX,[EAX*0x8 + 0x0]
006bdb0b : SUB EDX,EAX
006bdb0d : LEA EBX,[ECX + EDX*0x4 + 0x30]
006bdb11 : MOV EDX,dword ptr [ECX]
006bdb13 : MOV dword ptr [ESP + 0x28],EDX
006bdb17 : MOV EDX,EAX
006bdb19 : IMUL EDX,EDX,0x18c
006bdb1f : PUSH EBP
006bdb20 : MOV EBP,dword ptr [EBX + 0x8]
006bdb23 : PUSH ESI
006bdb24 : MOV ESI,dword ptr [ECX + 0x70]
006bdb27 : LEA ESI,[EDX + ESI*0x1 + 0x24]
006bdb2b : MOV EDX,dword ptr [EBX]
006bdb2d : IMUL EDX,EDX,0x34
006bdb30 : PUSH EDI
006bdb31 : XOR EDI,EDI
006bdb33 : ADD EDX,EBP
006bdb35 : MOV dword ptr [ESP + 0x14],EBX
006bdb39 : MOV dword ptr [ESP + 0x20],EDI
006bdb3d : MOV dword ptr [ESP + 0x30],EDX
006bdb41 : MOV dword ptr [EBX + 0xc],EDI
006bdb44 : CMP EAX,EDI
006bdb46 : JNZ 0x006bdb51
006bdb48 : MOV EDI,dword ptr [ECX + 0x4]
006bdb4b : MOV dword ptr [ESP + 0x1c],EDI
006bdb4f : JMP 0x006bdb5a
006bdb51 : MOV EAX,dword ptr [ECX + 0xc]
006bdb54 : MOV dword ptr [ESP + 0x1c],EAX
006bdb58 : MOV EDI,EAX
006bdb5a : MOV ECX,dword ptr [ESI + 0xcc]
006bdb60 : PUSH EDI
006bdb61 : PUSH ECX
006bdb62 : CALL 0x00685ea0
006bdb67 : ADD ESP,0x8
006bdb6a : CMP EAX,0x10
006bdb6d : JLE 0x006bdb80
006bdb6f : PUSH EDI
006bdb70 : PUSH 0x10
006bdb72 : CALL 0x00685f30
006bdb77 : ADD ESP,0x8
006bdb7a : MOV dword ptr [ESP + 0x10],EAX
006bdb7e : JMP 0x006bdb8a
006bdb80 : MOV EDX,dword ptr [ESI + 0xcc]
006bdb86 : MOV dword ptr [ESP + 0x10],EDX
006bdb8a : CMP EBP,dword ptr [ESP + 0x30]
006bdb8e : JNC 0x006bdcee
006bdb94 : ADD EBP,0x2
006bdb97 : JMP 0x006bdba0
006bdba0 : CMP dword ptr [EBX + 0xc],0x0
006bdba4 : MOV dword ptr [ESP + 0x2c],0x0
006bdbac : MOV dword ptr [ESP + 0x24],0xffff
006bdbb4 : JLE 0x006bdc60
006bdbba : MOV EAX,dword ptr [ESP + 0x14]
006bdbbe : MOV ECX,dword ptr [EAX + 0xc]
006bdbc1 : MOV EBX,dword ptr [EBX + 0x14]
006bdbc4 : MOV dword ptr [ESP + 0x28],ECX
006bdbc8 : MOV AL,byte ptr [EBP + -0x1]
006bdbcb : CMP byte ptr [EBX + 0xd],AL
006bdbce : JNZ 0x006bdc46
006bdbd0 : MOVSX ECX,word ptr [EBP]
006bdbd4 : MOVSX EDX,word ptr [EBX]
006bdbd7 : SUB ECX,EDX
006bdbd9 : MOV dword ptr [ESP + 0x18],ECX
006bdbdd : JNS 0x006bdbe5
006bdbdf : NEG ECX
006bdbe1 : MOV dword ptr [ESP + 0x18],ECX
006bdbe5 : CMP ECX,dword ptr [ESP + 0x10]
006bdbe9 : JGE 0x006bdc46
006bdbeb : CMP ECX,dword ptr [ESP + 0x24]
006bdbef : JGE 0x006bdc46
006bdbf1 : MOV EAX,dword ptr [EBP + 0x12]
006bdbf4 : TEST EAX,EAX
006bdbf6 : JZ 0x006bdc3e
006bdbf8 : MOV EDI,dword ptr [EBX + 0x28]
006bdbfb : MOV ESI,EDI
006bdbfd : XOR EAX,EAX
006bdbff : NOP
006bdc00 : MOV EDX,dword ptr [ESI + 0x14]
006bdc03 : TEST EDX,EDX
006bdc05 : JZ 0x006bdc31
006bdc07 : MOV EAX,dword ptr [EBP + 0x12]
006bdc0a : MOVZX ECX,word ptr [EAX + 0x2]
006bdc0e : MOVZX EAX,word ptr [EDX + 0x2]
006bdc12 : CMP CX,AX
006bdc15 : JLE 0x006bdc21
006bdc17 : MOVSX EDX,AX
006bdc1a : MOVSX EAX,CX
006bdc1d : SUB EAX,EDX
006bdc1f : JMP 0x006bdc27
006bdc21 : CWDE
006bdc22 : MOVSX ECX,CX
006bdc25 : SUB EAX,ECX
006bdc27 : CMP EAX,dword ptr [ESP + 0x10]
006bdc2b : JGE 0x006bdc46
006bdc2d : MOV ECX,dword ptr [ESP + 0x18]
006bdc31 : MOV ESI,dword ptr [ESI + 0x10]
006bdc34 : CMP ESI,EDI
006bdc36 : JNZ 0x006bdc00
006bdc38 : CMP EAX,dword ptr [ESP + 0x10]
006bdc3c : JGE 0x006bdc46
006bdc3e : MOV dword ptr [ESP + 0x24],ECX
006bdc42 : MOV dword ptr [ESP + 0x2c],EBX
006bdc46 : ADD EBX,0x30
006bdc49 : SUB dword ptr [ESP + 0x28],0x1
006bdc4e : JNZ 0x006bdbc8
006bdc54 : MOV ECX,dword ptr [ESP + 0x2c]
006bdc58 : TEST ECX,ECX
006bdc5a : JNZ 0x006bdcc8
006bdc5c : MOV EBX,dword ptr [ESP + 0x14]
006bdc60 : MOV EAX,dword ptr [ESP + 0x34]
006bdc64 : MOVSX ECX,byte ptr [EBP + -0x1]
006bdc68 : LEA EDX,[ESP + 0x38]
006bdc6c : PUSH EDX
006bdc6d : MOVSX EDX,word ptr [EBP]
006bdc71 : PUSH EAX
006bdc72 : PUSH ECX
006bdc73 : PUSH EDX
006bdc74 : CALL 0x006bb5c0
006bdc79 : ADD ESP,0x10
006bdc7c : MOV dword ptr [ESP + 0x20],EAX
006bdc80 : TEST EAX,EAX
006bdc82 : JNZ 0x006bde21
006bdc88 : MOV ESI,dword ptr [ESP + 0x38]
006bdc8c : PUSH 0x30
006bdc8e : PUSH EAX
006bdc8f : PUSH ESI
006bdc90 : CALL 0x0063b700
006bdc95 : MOV ECX,dword ptr [ESP + 0x28]
006bdc99 : LEA EDI,[EBP + -0x2]
006bdc9c : MOV dword ptr [ESI + 0x28],EDI
006bdc9f : MOV dword ptr [ESI + 0x2c],EDI
006bdca2 : MOV AX,word ptr [EBP]
006bdca6 : MOV word ptr [ESI],AX
006bdca9 : MOVSX EDX,word ptr [EBP]
006bdcad : PUSH ECX
006bdcae : PUSH EDX
006bdcaf : CALL 0x00685ea0
006bdcb4 : MOV dword ptr [ESI + 0x8],EAX
006bdcb7 : MOV dword ptr [ESI + 0x4],EAX
006bdcba : MOV AL,byte ptr [EBP + -0x1]
006bdcbd : MOV dword ptr [EBP + 0xe],EDI
006bdcc0 : ADD ESP,0x14
006bdcc3 : MOV byte ptr [ESI + 0xd],AL
006bdcc6 : JMP 0x006bdcda
006bdcc8 : MOV EDX,dword ptr [ECX + 0x28]
006bdccb : MOV dword ptr [EBP + 0xe],EDX
006bdcce : MOV EDX,dword ptr [ECX + 0x2c]
006bdcd1 : LEA EAX,[EBP + -0x2]
006bdcd4 : MOV dword ptr [EDX + 0x10],EAX
006bdcd7 : MOV dword ptr [ECX + 0x2c],EAX
006bdcda : MOV EBX,dword ptr [ESP + 0x14]
006bdcde : ADD EBP,0x34
006bdce1 : LEA EAX,[EBP + -0x2]
006bdce4 : CMP EAX,dword ptr [ESP + 0x30]
006bdce8 : JC 0x006bdba0
006bdcee : MOV EAX,dword ptr [EBX + 0xc]
006bdcf1 : MOV EDX,dword ptr [EBX + 0x14]
006bdcf4 : LEA EBP,[EAX + EAX*0x2]
006bdcf7 : SHL EBP,0x4
006bdcfa : ADD EBP,EDX
006bdcfc : MOV dword ptr [ESP + 0x30],EBP
006bdd00 : MOV ECX,EDX
006bdd02 : CMP EDX,EBP
006bdd04 : JNC 0x006bde1d
006bdd0a : LEA EBX,[EBX]
006bdd10 : MOV EAX,dword ptr [ECX + 0x28]
006bdd13 : TEST EAX,EAX
006bdd15 : JZ 0x006bdd22
006bdd17 : MOV dword ptr [EAX + 0xc],ECX
006bdd1a : MOV EAX,dword ptr [EAX + 0x10]
006bdd1d : CMP EAX,dword ptr [ECX + 0x28]
006bdd20 : JNZ 0x006bdd17
006bdd22 : ADD ECX,0x30
006bdd25 : CMP ECX,EBP
006bdd27 : JC 0x006bdd10
006bdd29 : CMP EDX,EBP
006bdd2b : JNC 0x006bde1d
006bdd31 : LEA ESI,[EDX + 0xc]
006bdd34 : MOV EDX,dword ptr [ESI + 0x1c]
006bdd37 : XOR EAX,EAX
006bdd39 : MOV dword ptr [ESP + 0x1c],EAX
006bdd3d : MOV dword ptr [ESP + 0x18],EAX
006bdd41 : MOV dword ptr [ESP + 0x14],EDX
006bdd45 : JMP 0x006bdd4b
006bdd47 : MOV EDX,dword ptr [ESP + 0x14]
006bdd4b : TEST byte ptr [EDX],0x1
006bdd4e : JZ 0x006bdd56
006bdd50 : INC dword ptr [ESP + 0x1c]
006bdd54 : JMP 0x006bdd5a
006bdd56 : INC dword ptr [ESP + 0x18]
006bdd5a : MOV ECX,dword ptr [EDX + 0x18]
006bdd5d : TEST ECX,ECX
006bdd5f : JZ 0x006bdd6d
006bdd61 : LEA EAX,[ESI + -0xc]
006bdd64 : CMP dword ptr [ECX + 0xc],EAX
006bdd67 : JZ 0x006bdd6d
006bdd69 : MOV BL,0x1
006bdd6b : JMP 0x006bdd6f
006bdd6d : XOR BL,BL
006bdd6f : MOV EDI,dword ptr [EDX + 0x14]
006bdd72 : TEST EDI,EDI
006bdd74 : JNZ 0x006bdd7a
006bdd76 : TEST BL,BL
006bdd78 : JZ 0x006bddd8
006bdd7a : MOV EAX,dword ptr [ESI + 0xc]
006bdd7d : TEST BL,BL
006bdd7f : JZ 0x006bdd86
006bdd81 : MOV EAX,dword ptr [ESI + 0x10]
006bdd84 : MOV EDI,ECX
006bdd86 : TEST EAX,EAX
006bdd88 : JZ 0x006bddc5
006bdd8a : MOVSX EBP,word ptr [ESI + -0xc]
006bdd8e : MOVSX ECX,word ptr [EAX]
006bdd91 : SUB EBP,ECX
006bdd93 : JNS 0x006bdd97
006bdd95 : NEG EBP
006bdd97 : MOVZX ECX,word ptr [EDI + 0x2]
006bdd9b : MOVZX EDX,word ptr [EDX + 0x2]
006bdd9f : CMP DX,CX
006bdda2 : MOVSX ECX,CX
006bdda5 : JLE 0x006bddb4
006bdda7 : MOV dword ptr [ESP + 0x38],ECX
006bddab : MOVSX ECX,DX
006bddae : MOV EDX,dword ptr [ESP + 0x38]
006bddb2 : JMP 0x006bddb7
006bddb4 : MOVSX EDX,DX
006bddb7 : SUB ECX,EDX
006bddb9 : MOV EDX,dword ptr [ESP + 0x14]
006bddbd : CMP ECX,EBP
006bddbf : MOV EBP,dword ptr [ESP + 0x30]
006bddc3 : JGE 0x006bddc8
006bddc5 : MOV EAX,dword ptr [EDI + 0xc]
006bddc8 : TEST BL,BL
006bddca : JZ 0x006bddd5
006bddcc : MOV dword ptr [ESI + 0x10],EAX
006bddcf : OR byte ptr [EAX + 0xc],0x2
006bddd3 : JMP 0x006bddd8
006bddd5 : MOV dword ptr [ESI + 0xc],EAX
006bddd8 : MOV EAX,dword ptr [EDX + 0x10]
006bdddb : MOV dword ptr [ESP + 0x14],EAX
006bdddf : CMP EAX,dword ptr [ESI + 0x1c]
006bdde2 : JNZ 0x006bdd47
006bdde8 : MOV EAX,dword ptr [ESP + 0x1c]
006bddec : MOV byte ptr [ESI],0x0
006bddef : TEST EAX,EAX
006bddf1 : JLE 0x006bddfc
006bddf3 : CMP EAX,dword ptr [ESP + 0x18]
006bddf7 : JL 0x006bddfc
006bddf9 : MOV byte ptr [ESI],0x1
006bddfc : CMP dword ptr [ESI + 0x10],0x0
006bde00 : JZ 0x006bde0f
006bde02 : CMP dword ptr [ESI + 0xc],0x0
006bde06 : JZ 0x006bde0f
006bde08 : MOV dword ptr [ESI + 0x10],0x0
006bde0f : ADD ESI,0x30
006bde12 : LEA EAX,[ESI + -0xc]
006bde15 : CMP EAX,EBP
006bde17 : JC 0x006bdd34
006bde1d : MOV EAX,dword ptr [ESP + 0x20]
006bde21 : POP EDI
006bde22 : POP ESI
006bde23 : POP EBP
006bde24 : POP EBX
006bde25 : ADD ESP,0x2c
006bde28 : RET
