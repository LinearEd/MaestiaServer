PROGRAM  : Maestia.exe
FUNCTION : __ld12tof
ENTRY    : 0065e69b
BODY     : [[0065e69b, 0065ebde]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Multiple Matches With Different Base Names
    __ld12tod
    __ld12tof
   
   Library: Visual Studio 2008 Release */

INTRNCVT_STATUS __cdecl __ld12tof(_LDBL12 *_Ifp,_CRT_FLOAT *_F)

{
  uint uVar1;
  int iVar2;
  INTRNCVT_STATUS IVar3;
  byte bVar4;
  uint *puVar5;
  uint *puVar6;
  uint uVar7;
  _LDBL12 *p_Var8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  float fVar12;
  int iVar13;
  bool bVar14;
  uint local_24;
  float local_20;
  uint local_1c [5];
  _LDBL12 *local_8;
  
  local_1c[1] = *(ushort *)(_Ifp->ld12 + 10) & 0x8000;
  uVar9 = *(uint *)(_Ifp->ld12 + 6);
  local_24 = uVar9;
  fVar12 = *(float *)(_Ifp->ld12 + 2);
  uVar10 = *(ushort *)(_Ifp->ld12 + 10) & 0x7fff;
  iVar11 = uVar10 - 0x3fff;
  uVar1 = (uint)*(ushort *)_Ifp->ld12 << 0x10;
  local_20 = fVar12;
  local_1c[0] = uVar1;
  if (iVar11 == -0x3fff) {
    iVar11 = 0;
    iVar2 = 0;
    do {
      if ((&local_24)[iVar2] != 0) {
        local_24 = 0;
        local_20 = 0.0;
        IVar3 = INTRNCVT_UNDERFLOW;
        goto LAB_0065eb9c;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < 3);
    IVar3 = INTRNCVT_OK;
  }
  else {
    _Ifp = (_LDBL12 *)0x0;
    iVar13 = DAT_00d683d4 - 1;
    iVar2 = (int)(DAT_00d683d4 + ((int)DAT_00d683d4 >> 0x1f & 0x1fU)) >> 5;
    uVar7 = DAT_00d683d4 & 0x8000001f;
    local_1c[2] = iVar11;
    local_1c[3] = iVar2;
    if ((int)uVar7 < 0) {
      uVar7 = (uVar7 - 1 | 0xffffffe0) + 1;
    }
    puVar6 = &local_24 + iVar2;
    bVar4 = (byte)(0x1f - uVar7);
    local_1c[4] = 0x1f - uVar7;
    if ((*puVar6 & 1 << (bVar4 & 0x1f)) != 0) {
      uVar7 = (&local_24)[iVar2] & ~(-1 << (bVar4 & 0x1f));
      while( true ) {
        if (uVar7 != 0) {
          iVar2 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
          local_8 = (_LDBL12 *)0x0;
          p_Var8 = (_LDBL12 *)(1 << (0x1f - ((byte)iVar13 & 0x1f) & 0x1f));
          puVar5 = &local_24 + iVar2;
          _Ifp = (_LDBL12 *)(p_Var8->ld12 + *puVar5);
          if (_Ifp < (_LDBL12 *)*puVar5) goto LAB_0065e7d0;
          bVar14 = _Ifp < p_Var8;
          do {
            local_8 = (_LDBL12 *)0x0;
            if (!bVar14) goto LAB_0065e7d7;
LAB_0065e7d0:
            do {
              local_8 = (_LDBL12 *)0x1;
LAB_0065e7d7:
              iVar2 = iVar2 + -1;
              *puVar5 = (uint)_Ifp;
              if ((iVar2 < 0) || (local_8 == (_LDBL12 *)0x0)) {
                _Ifp = local_8;
                goto LAB_0065e7e5;
              }
              local_8 = (_LDBL12 *)0x0;
              puVar5 = &local_24 + iVar2;
              _Ifp = (_LDBL12 *)(((_LDBL12 *)*puVar5)->ld12 + 1);
            } while (_Ifp < (_LDBL12 *)*puVar5);
            bVar14 = _Ifp == (_LDBL12 *)0x0;
          } while( true );
        }
        iVar2 = iVar2 + 1;
        if (2 < iVar2) break;
        uVar7 = (&local_24)[iVar2];
      }
    }
LAB_0065e7e5:
    *puVar6 = *puVar6 & -1 << ((byte)local_1c[4] & 0x1f);
    iVar2 = local_1c[3] + 1;
    if (iVar2 < 3) {
      puVar6 = &local_24 + iVar2;
      for (iVar13 = 3 - iVar2; iVar13 != 0; iVar13 = iVar13 + -1) {
        *puVar6 = 0;
        puVar6 = puVar6 + 1;
      }
    }
    if (_Ifp != (_LDBL12 *)0x0) {
      iVar11 = uVar10 - 0x3ffe;
    }
    if (iVar11 < (int)(DAT_00d683d0 - DAT_00d683d4)) {
      local_24 = 0;
      local_20 = 0.0;
    }
    else {
      if (DAT_00d683d0 < iVar11) {
        if (iVar11 < DAT_00d683cc) {
          local_24 = local_24 & 0x7fffffff;
          iVar11 = iVar11 + DAT_00d683e0;
          iVar2 = (int)(DAT_00d683d8 + ((int)DAT_00d683d8 >> 0x1f & 0x1fU)) >> 5;
          uVar9 = DAT_00d683d8 & 0x8000001f;
          if ((int)uVar9 < 0) {
            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;
          }
          local_1c[3] = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar9);
          do {
            local_1c[2] = (&local_24)[(int)_Ifp] & ~(-1 << ((byte)uVar9 & 0x1f));
            (&local_24)[(int)_Ifp] = (&local_24)[(int)_Ifp] >> ((byte)uVar9 & 0x1f) | local_1c[3];
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_1c[3] = local_1c[2] << ((byte)(0x20 - uVar9) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar13 = 2;
          puVar6 = local_1c + -iVar2;
          do {
            if (iVar13 < iVar2) {
              (&local_24)[iVar13] = 0;
            }
            else {
              (&local_24)[iVar13] = *puVar6;
            }
            iVar13 = iVar13 + -1;
            puVar6 = puVar6 + -1;
          } while (-1 < iVar13);
          IVar3 = INTRNCVT_OK;
        }
        else {
          local_20 = 0.0;
          local_1c[0] = 0;
          local_24 = 0x80000000;
          iVar11 = (int)(DAT_00d683d8 + ((int)DAT_00d683d8 >> 0x1f & 0x1fU)) >> 5;
          uVar9 = DAT_00d683d8 & 0x8000001f;
          if ((int)uVar9 < 0) {
            uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;
          }
          local_1c[3] = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar9);
          do {
            uVar1 = (&local_24)[(int)_Ifp];
            local_1c[2] = uVar1 & ~(-1 << ((byte)uVar9 & 0x1f));
            (&local_24)[(int)_Ifp] = uVar1 >> ((byte)uVar9 & 0x1f) | local_1c[3];
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_1c[3] = local_1c[2] << ((byte)(0x20 - uVar9) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar2 = 2;
          puVar6 = local_1c + -iVar11;
          do {
            if (iVar2 < iVar11) {
              (&local_24)[iVar2] = 0;
            }
            else {
              (&local_24)[iVar2] = *puVar6;
            }
            iVar2 = iVar2 + -1;
            puVar6 = puVar6 + -1;
          } while (-1 < iVar2);
          iVar11 = DAT_00d683e0 + DAT_00d683cc;
          IVar3 = INTRNCVT_OVERFLOW;
        }
        goto LAB_0065eb9c;
      }
      local_1c[2] = DAT_00d683d0 - local_1c[2];
      local_24 = uVar9;
      local_20 = fVar12;
      iVar11 = (int)(local_1c[2] + ((int)local_1c[2] >> 0x1f & 0x1fU)) >> 5;
      uVar9 = local_1c[2] & 0x8000001f;
      if ((int)uVar9 < 0) {
        uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;
      }
      local_1c[3] = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar9);
      do {
        uVar1 = (&local_24)[(int)_Ifp];
        local_1c[2] = uVar1 & ~(-1 << ((byte)uVar9 & 0x1f));
        (&local_24)[(int)_Ifp] = uVar1 >> ((byte)uVar9 & 0x1f) | local_1c[3];
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_1c[3] = local_1c[2] << ((byte)(0x20 - uVar9) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar2 = 2;
      puVar6 = local_1c + -iVar11;
      do {
        if (iVar2 < iVar11) {
          (&local_24)[iVar2] = 0;
        }
        else {
          (&local_24)[iVar2] = *puVar6;
        }
        iVar2 = iVar2 + -1;
        puVar6 = puVar6 + -1;
      } while (-1 < iVar2);
      iVar2 = DAT_00d683d4 - 1;
      iVar11 = (int)(DAT_00d683d4 + ((int)DAT_00d683d4 >> 0x1f & 0x1fU)) >> 5;
      uVar9 = DAT_00d683d4 & 0x8000001f;
      local_1c[3] = iVar11;
      if ((int)uVar9 < 0) {
        uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;
      }
      bVar4 = (byte)(0x1f - uVar9);
      puVar6 = &local_24 + iVar11;
      local_1c[2] = 0x1f - uVar9;
      if ((*puVar6 & 1 << (bVar4 & 0x1f)) != 0) {
        uVar9 = (&local_24)[iVar11] & ~(-1 << (bVar4 & 0x1f));
        while (uVar9 == 0) {
          iVar11 = iVar11 + 1;
          if (2 < iVar11) goto LAB_0065e988;
          uVar9 = (&local_24)[iVar11];
        }
        iVar11 = (int)(iVar2 + (iVar2 >> 0x1f & 0x1fU)) >> 5;
        bVar14 = false;
        uVar10 = 1 << (0x1f - ((byte)iVar2 & 0x1f) & 0x1f);
        uVar1 = (&local_24)[iVar11];
        uVar9 = uVar1 + uVar10;
        if ((uVar9 < uVar1) || (uVar9 < uVar10)) {
          bVar14 = true;
        }
        (&local_24)[iVar11] = uVar9;
        while ((iVar11 = iVar11 + -1, -1 < iVar11 && (bVar14))) {
          uVar1 = (&local_24)[iVar11];
          uVar9 = uVar1 + 1;
          bVar14 = false;
          if ((uVar9 < uVar1) || (uVar9 == 0)) {
            bVar14 = true;
          }
          (&local_24)[iVar11] = uVar9;
        }
      }
LAB_0065e988:
      *puVar6 = *puVar6 & -1 << ((byte)local_1c[2] & 0x1f);
      iVar11 = local_1c[3] + 1;
      if (iVar11 < 3) {
        puVar6 = &local_24 + iVar11;
        for (iVar2 = 3 - iVar11; iVar2 != 0; iVar2 = iVar2 + -1) {
          *puVar6 = 0;
          puVar6 = puVar6 + 1;
        }
      }
      uVar9 = DAT_00d683d8 + 1;
      iVar11 = (int)(uVar9 + ((int)uVar9 >> 0x1f & 0x1fU)) >> 5;
      uVar9 = uVar9 & 0x8000001f;
      if ((int)uVar9 < 0) {
        uVar9 = (uVar9 - 1 | 0xffffffe0) + 1;
      }
      local_1c[3] = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar9);
      do {
        uVar1 = (&local_24)[(int)_Ifp];
        local_1c[2] = uVar1 & ~(-1 << ((byte)uVar9 & 0x1f));
        (&local_24)[(int)_Ifp] = uVar1 >> ((byte)uVar9 & 0x1f) | local_1c[3];
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_1c[3] = local_1c[2] << ((byte)(0x20 - uVar9) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar2 = 2;
      puVar6 = local_1c + -iVar11;
      do {
        if (iVar2 < iVar11) {
          (&local_24)[iVar2] = 0;
        }
        else {
          (&local_24)[iVar2] = *puVar6;
        }
        iVar2 = iVar2 + -1;
        puVar6 = puVar6 + -1;
      } while (-1 < iVar2);
    }
    iVar11 = 0;
    IVar3 = INTRNCVT_UNDERFLOW;
  }
LAB_0065eb9c:
  fVar12 = (float)(iVar11 << (0x1fU - (char)DAT_00d683d8 & 0x1f) |
                   -(uint)(local_1c[1] != 0) & 0x80000000 | local_24);
  if (DAT_00d683dc == 0x40) {
    _F[1].f = fVar12;
    _F->f = local_20;
  }
  else if (DAT_00d683dc == 0x20) {
    _F->f = fVar12;
  }
  return IVar3;
}



============================================================
DISASSEMBLY
============================================================
0065e69b : MOV EDI,EDI
0065e69d : PUSH EBP
0065e69e : MOV EBP,ESP
0065e6a0 : SUB ESP,0x2c
0065e6a3 : MOV EAX,dword ptr [EBP + 0x8]
0065e6a6 : MOVZX ECX,word ptr [EAX + 0xa]
0065e6aa : PUSH EBX
0065e6ab : MOV EBX,ECX
0065e6ad : AND ECX,0x8000
0065e6b3 : MOV dword ptr [EBP + -0x14],ECX
0065e6b6 : MOV ECX,dword ptr [EAX + 0x6]
0065e6b9 : MOV dword ptr [EBP + -0x20],ECX
0065e6bc : MOV ECX,dword ptr [EAX + 0x2]
0065e6bf : MOVZX EAX,word ptr [EAX]
0065e6c2 : AND EBX,0x7fff
0065e6c8 : SUB EBX,0x3fff
0065e6ce : SHL EAX,0x10
0065e6d1 : PUSH EDI
0065e6d2 : MOV dword ptr [EBP + -0x1c],ECX
0065e6d5 : MOV dword ptr [EBP + -0x18],EAX
0065e6d8 : CMP EBX,0xffffc001
0065e6de : JNZ 0x0065e707
0065e6e0 : XOR EBX,EBX
0065e6e2 : XOR EAX,EAX
0065e6e4 : CMP dword ptr [EBP + EAX*0x4 + -0x20],EBX
0065e6e8 : JNZ 0x0065e6f7
0065e6ea : INC EAX
0065e6eb : CMP EAX,0x3
0065e6ee : JL 0x0065e6e4
0065e6f0 : XOR EAX,EAX
0065e6f2 : JMP 0x0065eb9c
0065e6f7 : XOR EAX,EAX
0065e6f9 : LEA EDI,[EBP + -0x20]
0065e6fc : STOSD ES:EDI
0065e6fd : STOSD ES:EDI
0065e6fe : PUSH 0x2
0065e700 : STOSD ES:EDI
0065e701 : POP EAX
0065e702 : JMP 0x0065eb9c
0065e707 : AND dword ptr [EBP + 0x8],0x0
0065e70b : PUSH ESI
0065e70c : LEA ESI,[EBP + -0x20]
0065e70f : LEA EDI,[EBP + -0x2c]
0065e712 : MOVSD ES:EDI,ESI
0065e713 : MOVSD ES:EDI,ESI
0065e714 : MOVSD ES:EDI,ESI
0065e715 : MOV ESI,dword ptr [0x00d683d4]
0065e71b : DEC ESI
0065e71c : LEA ECX,[ESI + 0x1]
0065e71f : MOV EAX,ECX
0065e721 : CDQ
0065e722 : AND EDX,0x1f
0065e725 : ADD EAX,EDX
0065e727 : SAR EAX,0x5
0065e72a : MOV EDX,ECX
0065e72c : AND EDX,0x8000001f
0065e732 : MOV dword ptr [EBP + -0x10],EBX
0065e735 : MOV dword ptr [EBP + -0xc],EAX
0065e738 : JNS 0x0065e73f
0065e73a : DEC EDX
0065e73b : OR EDX,0xffffffe0
0065e73e : INC EDX
0065e73f : LEA EDI,[EBP + EAX*0x4 + -0x20]
0065e743 : PUSH 0x1f
0065e745 : XOR EAX,EAX
0065e747 : POP ECX
0065e748 : SUB ECX,EDX
0065e74a : INC EAX
0065e74b : SHL EAX,CL
0065e74d : MOV dword ptr [EBP + -0x8],ECX
0065e750 : TEST dword ptr [EDI],EAX
0065e752 : JZ 0x0065e7e5
0065e758 : MOV EAX,dword ptr [EBP + -0xc]
0065e75b : OR EDX,0xffffffff
0065e75e : SHL EDX,CL
0065e760 : NOT EDX
0065e762 : TEST dword ptr [EBP + EAX*0x4 + -0x20],EDX
0065e766 : JMP 0x0065e76d
0065e768 : CMP dword ptr [EBP + EAX*0x4 + -0x20],0x0
0065e76d : JNZ 0x0065e777
0065e76f : INC EAX
0065e770 : CMP EAX,0x3
0065e773 : JL 0x0065e768
0065e775 : JMP 0x0065e7e5
0065e777 : MOV EAX,ESI
0065e779 : CDQ
0065e77a : PUSH 0x1f
0065e77c : POP ECX
0065e77d : AND EDX,ECX
0065e77f : ADD EAX,EDX
0065e781 : SAR EAX,0x5
0065e784 : AND ESI,0x8000001f
0065e78a : JNS 0x0065e791
0065e78c : DEC ESI
0065e78d : OR ESI,0xffffffe0
0065e790 : INC ESI
0065e791 : AND dword ptr [EBP + -0x4],0x0
0065e795 : SUB ECX,ESI
0065e797 : XOR EDX,EDX
0065e799 : INC EDX
0065e79a : SHL EDX,CL
0065e79c : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e7a0 : MOV ESI,dword ptr [ECX]
0065e7a2 : ADD ESI,EDX
0065e7a4 : MOV dword ptr [EBP + 0x8],ESI
0065e7a7 : MOV ESI,dword ptr [ECX]
0065e7a9 : CMP dword ptr [EBP + 0x8],ESI
0065e7ac : JC 0x0065e7d0
0065e7ae : CMP dword ptr [EBP + 0x8],EDX
0065e7b1 : JMP 0x0065e7ce
0065e7b3 : TEST ECX,ECX
0065e7b5 : JZ 0x0065e7e2
0065e7b7 : AND dword ptr [EBP + -0x4],0x0
0065e7bb : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e7bf : MOV EDX,dword ptr [ECX]
0065e7c1 : LEA ESI,[EDX + 0x1]
0065e7c4 : MOV dword ptr [EBP + 0x8],ESI
0065e7c7 : CMP ESI,EDX
0065e7c9 : JC 0x0065e7d0
0065e7cb : CMP ESI,0x1
0065e7ce : JNC 0x0065e7d7
0065e7d0 : MOV dword ptr [EBP + -0x4],0x1
0065e7d7 : DEC EAX
0065e7d8 : MOV EDX,dword ptr [EBP + 0x8]
0065e7db : MOV dword ptr [ECX],EDX
0065e7dd : MOV ECX,dword ptr [EBP + -0x4]
0065e7e0 : JNS 0x0065e7b3
0065e7e2 : MOV dword ptr [EBP + 0x8],ECX
0065e7e5 : MOV ECX,dword ptr [EBP + -0x8]
0065e7e8 : OR EAX,0xffffffff
0065e7eb : SHL EAX,CL
0065e7ed : AND dword ptr [EDI],EAX
0065e7ef : MOV EAX,dword ptr [EBP + -0xc]
0065e7f2 : INC EAX
0065e7f3 : CMP EAX,0x3
0065e7f6 : JGE 0x0065e805
0065e7f8 : PUSH 0x3
0065e7fa : POP ECX
0065e7fb : LEA EDI,[EBP + EAX*0x4 + -0x20]
0065e7ff : SUB ECX,EAX
0065e801 : XOR EAX,EAX
0065e803 : STOSD.REP ES:EDI
0065e805 : CMP dword ptr [EBP + 0x8],0x0
0065e809 : JZ 0x0065e80c
0065e80b : INC EBX
0065e80c : MOV EAX,[0x00d683d0]
0065e811 : MOV ECX,EAX
0065e813 : SUB ECX,dword ptr [0x00d683d4]
0065e819 : CMP EBX,ECX
0065e81b : JGE 0x0065e82a
0065e81d : XOR EAX,EAX
0065e81f : LEA EDI,[EBP + -0x20]
0065e822 : STOSD ES:EDI
0065e823 : STOSD ES:EDI
0065e824 : STOSD ES:EDI
0065e825 : JMP 0x0065ea37
0065e82a : CMP EBX,EAX
0065e82c : JG 0x0065ea41
0065e832 : SUB EAX,dword ptr [EBP + -0x10]
0065e835 : LEA ESI,[EBP + -0x2c]
0065e838 : MOV ECX,EAX
0065e83a : LEA EDI,[EBP + -0x20]
0065e83d : MOVSD ES:EDI,ESI
0065e83e : CDQ
0065e83f : AND EDX,0x1f
0065e842 : ADD EAX,EDX
0065e844 : MOVSD ES:EDI,ESI
0065e845 : MOV EDX,ECX
0065e847 : SAR EAX,0x5
0065e84a : AND EDX,0x8000001f
0065e850 : MOVSD ES:EDI,ESI
0065e851 : JNS 0x0065e858
0065e853 : DEC EDX
0065e854 : OR EDX,0xffffffe0
0065e857 : INC EDX
0065e858 : AND dword ptr [EBP + -0xc],0x0
0065e85c : AND dword ptr [EBP + 0x8],0x0
0065e860 : OR EDI,0xffffffff
0065e863 : MOV ECX,EDX
0065e865 : SHL EDI,CL
0065e867 : MOV dword ptr [EBP + -0x4],0x20
0065e86e : SUB dword ptr [EBP + -0x4],EDX
0065e871 : NOT EDI
0065e873 : MOV EBX,dword ptr [EBP + 0x8]
0065e876 : LEA EBX,[EBP + EBX*0x4 + -0x20]
0065e87a : MOV ESI,dword ptr [EBX]
0065e87c : MOV ECX,ESI
0065e87e : AND ECX,EDI
0065e880 : MOV dword ptr [EBP + -0x10],ECX
0065e883 : MOV ECX,EDX
0065e885 : SHR ESI,CL
0065e887 : MOV ECX,dword ptr [EBP + -0x4]
0065e88a : OR ESI,dword ptr [EBP + -0xc]
0065e88d : MOV dword ptr [EBX],ESI
0065e88f : MOV ESI,dword ptr [EBP + -0x10]
0065e892 : SHL ESI,CL
0065e894 : INC dword ptr [EBP + 0x8]
0065e897 : CMP dword ptr [EBP + 0x8],0x3
0065e89b : MOV dword ptr [EBP + -0xc],ESI
0065e89e : JL 0x0065e873
0065e8a0 : MOV ESI,EAX
0065e8a2 : PUSH 0x2
0065e8a4 : SHL ESI,0x2
0065e8a7 : LEA ECX,[EBP + -0x18]
0065e8aa : POP EDX
0065e8ab : SUB ECX,ESI
0065e8ad : CMP EDX,EAX
0065e8af : JL 0x0065e8b9
0065e8b1 : MOV ESI,dword ptr [ECX]
0065e8b3 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065e8b7 : JMP 0x0065e8be
0065e8b9 : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065e8be : DEC EDX
0065e8bf : SUB ECX,0x4
0065e8c2 : TEST EDX,EDX
0065e8c4 : JGE 0x0065e8ad
0065e8c6 : MOV ESI,dword ptr [0x00d683d4]
0065e8cc : DEC ESI
0065e8cd : LEA ECX,[ESI + 0x1]
0065e8d0 : MOV EAX,ECX
0065e8d2 : CDQ
0065e8d3 : AND EDX,0x1f
0065e8d6 : ADD EAX,EDX
0065e8d8 : SAR EAX,0x5
0065e8db : MOV EDX,ECX
0065e8dd : AND EDX,0x8000001f
0065e8e3 : MOV dword ptr [EBP + -0xc],EAX
0065e8e6 : JNS 0x0065e8ed
0065e8e8 : DEC EDX
0065e8e9 : OR EDX,0xffffffe0
0065e8ec : INC EDX
0065e8ed : PUSH 0x1f
0065e8ef : POP ECX
0065e8f0 : SUB ECX,EDX
0065e8f2 : XOR EDX,EDX
0065e8f4 : INC EDX
0065e8f5 : SHL EDX,CL
0065e8f7 : LEA EBX,[EBP + EAX*0x4 + -0x20]
0065e8fb : MOV dword ptr [EBP + -0x10],ECX
0065e8fe : TEST dword ptr [EBX],EDX
0065e900 : JZ 0x0065e988
0065e906 : OR EDX,0xffffffff
0065e909 : SHL EDX,CL
0065e90b : NOT EDX
0065e90d : TEST dword ptr [EBP + EAX*0x4 + -0x20],EDX
0065e911 : JMP 0x0065e918
0065e913 : CMP dword ptr [EBP + EAX*0x4 + -0x20],0x0
0065e918 : JNZ 0x0065e922
0065e91a : INC EAX
0065e91b : CMP EAX,0x3
0065e91e : JL 0x0065e913
0065e920 : JMP 0x0065e988
0065e922 : MOV EAX,ESI
0065e924 : CDQ
0065e925 : PUSH 0x1f
0065e927 : POP ECX
0065e928 : AND EDX,ECX
0065e92a : ADD EAX,EDX
0065e92c : SAR EAX,0x5
0065e92f : AND ESI,0x8000001f
0065e935 : JNS 0x0065e93c
0065e937 : DEC ESI
0065e938 : OR ESI,0xffffffe0
0065e93b : INC ESI
0065e93c : AND dword ptr [EBP + 0x8],0x0
0065e940 : XOR EDX,EDX
0065e942 : SUB ECX,ESI
0065e944 : INC EDX
0065e945 : SHL EDX,CL
0065e947 : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e94b : MOV ESI,dword ptr [ECX]
0065e94d : LEA EDI,[ESI + EDX*0x1]
0065e950 : CMP EDI,ESI
0065e952 : JC 0x0065e958
0065e954 : CMP EDI,EDX
0065e956 : JNC 0x0065e95f
0065e958 : MOV dword ptr [EBP + 0x8],0x1
0065e95f : MOV dword ptr [ECX],EDI
0065e961 : MOV ECX,dword ptr [EBP + 0x8]
0065e964 : JMP 0x0065e985
0065e966 : TEST ECX,ECX
0065e968 : JZ 0x0065e988
0065e96a : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e96e : MOV EDX,dword ptr [ECX]
0065e970 : LEA ESI,[EDX + 0x1]
0065e973 : XOR EDI,EDI
0065e975 : CMP ESI,EDX
0065e977 : JC 0x0065e97e
0065e979 : CMP ESI,0x1
0065e97c : JNC 0x0065e981
0065e97e : XOR EDI,EDI
0065e980 : INC EDI
0065e981 : MOV dword ptr [ECX],ESI
0065e983 : MOV ECX,EDI
0065e985 : DEC EAX
0065e986 : JNS 0x0065e966
0065e988 : MOV ECX,dword ptr [EBP + -0x10]
0065e98b : OR EAX,0xffffffff
0065e98e : SHL EAX,CL
0065e990 : AND dword ptr [EBX],EAX
0065e992 : MOV EAX,dword ptr [EBP + -0xc]
0065e995 : INC EAX
0065e996 : CMP EAX,0x3
0065e999 : JGE 0x0065e9a8
0065e99b : PUSH 0x3
0065e99d : POP ECX
0065e99e : LEA EDI,[EBP + EAX*0x4 + -0x20]
0065e9a2 : SUB ECX,EAX
0065e9a4 : XOR EAX,EAX
0065e9a6 : STOSD.REP ES:EDI
0065e9a8 : MOV ECX,dword ptr [0x00d683d8]
0065e9ae : INC ECX
0065e9af : MOV EAX,ECX
0065e9b1 : CDQ
0065e9b2 : AND EDX,0x1f
0065e9b5 : ADD EAX,EDX
0065e9b7 : MOV EDX,ECX
0065e9b9 : SAR EAX,0x5
0065e9bc : AND EDX,0x8000001f
0065e9c2 : JNS 0x0065e9c9
0065e9c4 : DEC EDX
0065e9c5 : OR EDX,0xffffffe0
0065e9c8 : INC EDX
0065e9c9 : AND dword ptr [EBP + -0xc],0x0
0065e9cd : AND dword ptr [EBP + 0x8],0x0
0065e9d1 : OR EDI,0xffffffff
0065e9d4 : MOV ECX,EDX
0065e9d6 : SHL EDI,CL
0065e9d8 : MOV dword ptr [EBP + -0x4],0x20
0065e9df : SUB dword ptr [EBP + -0x4],EDX
0065e9e2 : NOT EDI
0065e9e4 : MOV EBX,dword ptr [EBP + 0x8]
0065e9e7 : LEA EBX,[EBP + EBX*0x4 + -0x20]
0065e9eb : MOV ESI,dword ptr [EBX]
0065e9ed : MOV ECX,ESI
0065e9ef : AND ECX,EDI
0065e9f1 : MOV dword ptr [EBP + -0x10],ECX
0065e9f4 : MOV ECX,EDX
0065e9f6 : SHR ESI,CL
0065e9f8 : MOV ECX,dword ptr [EBP + -0x4]
0065e9fb : OR ESI,dword ptr [EBP + -0xc]
0065e9fe : MOV dword ptr [EBX],ESI
0065ea00 : MOV ESI,dword ptr [EBP + -0x10]
0065ea03 : SHL ESI,CL
0065ea05 : INC dword ptr [EBP + 0x8]
0065ea08 : CMP dword ptr [EBP + 0x8],0x3
0065ea0c : MOV dword ptr [EBP + -0xc],ESI
0065ea0f : JL 0x0065e9e4
0065ea11 : MOV ESI,EAX
0065ea13 : PUSH 0x2
0065ea15 : SHL ESI,0x2
0065ea18 : LEA ECX,[EBP + -0x18]
0065ea1b : POP EDX
0065ea1c : SUB ECX,ESI
0065ea1e : CMP EDX,EAX
0065ea20 : JL 0x0065ea2a
0065ea22 : MOV ESI,dword ptr [ECX]
0065ea24 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065ea28 : JMP 0x0065ea2f
0065ea2a : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065ea2f : DEC EDX
0065ea30 : SUB ECX,0x4
0065ea33 : TEST EDX,EDX
0065ea35 : JGE 0x0065ea1e
0065ea37 : PUSH 0x2
0065ea39 : XOR EBX,EBX
0065ea3b : POP EAX
0065ea3c : JMP 0x0065eb9b
0065ea41 : CMP EBX,dword ptr [0x00d683cc]
0065ea47 : MOV ECX,dword ptr [0x00d683d8]
0065ea4d : JL 0x0065eb00
0065ea53 : XOR EAX,EAX
0065ea55 : LEA EDI,[EBP + -0x20]
0065ea58 : STOSD ES:EDI
0065ea59 : STOSD ES:EDI
0065ea5a : STOSD ES:EDI
0065ea5b : OR dword ptr [EBP + -0x20],0x80000000
0065ea62 : MOV EAX,ECX
0065ea64 : CDQ
0065ea65 : AND EDX,0x1f
0065ea68 : ADD EAX,EDX
0065ea6a : MOV EDX,ECX
0065ea6c : SAR EAX,0x5
0065ea6f : AND EDX,0x8000001f
0065ea75 : JNS 0x0065ea7c
0065ea77 : DEC EDX
0065ea78 : OR EDX,0xffffffe0
0065ea7b : INC EDX
0065ea7c : AND dword ptr [EBP + -0xc],0x0
0065ea80 : AND dword ptr [EBP + 0x8],0x0
0065ea84 : OR EDI,0xffffffff
0065ea87 : MOV ECX,EDX
0065ea89 : SHL EDI,CL
0065ea8b : MOV dword ptr [EBP + -0x4],0x20
0065ea92 : SUB dword ptr [EBP + -0x4],EDX
0065ea95 : NOT EDI
0065ea97 : MOV EBX,dword ptr [EBP + 0x8]
0065ea9a : LEA EBX,[EBP + EBX*0x4 + -0x20]
0065ea9e : MOV ESI,dword ptr [EBX]
0065eaa0 : MOV ECX,ESI
0065eaa2 : AND ECX,EDI
0065eaa4 : MOV dword ptr [EBP + -0x10],ECX
0065eaa7 : MOV ECX,EDX
0065eaa9 : SHR ESI,CL
0065eaab : MOV ECX,dword ptr [EBP + -0x4]
0065eaae : OR ESI,dword ptr [EBP + -0xc]
0065eab1 : MOV dword ptr [EBX],ESI
0065eab3 : MOV ESI,dword ptr [EBP + -0x10]
0065eab6 : SHL ESI,CL
0065eab8 : INC dword ptr [EBP + 0x8]
0065eabb : CMP dword ptr [EBP + 0x8],0x3
0065eabf : MOV dword ptr [EBP + -0xc],ESI
0065eac2 : JL 0x0065ea97
0065eac4 : MOV ESI,EAX
0065eac6 : PUSH 0x2
0065eac8 : SHL ESI,0x2
0065eacb : LEA ECX,[EBP + -0x18]
0065eace : POP EDX
0065eacf : SUB ECX,ESI
0065ead1 : CMP EDX,EAX
0065ead3 : JL 0x0065eadd
0065ead5 : MOV ESI,dword ptr [ECX]
0065ead7 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065eadb : JMP 0x0065eae2
0065eadd : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065eae2 : DEC EDX
0065eae3 : SUB ECX,0x4
0065eae6 : TEST EDX,EDX
0065eae8 : JGE 0x0065ead1
0065eaea : MOV EAX,[0x00d683cc]
0065eaef : MOV ECX,dword ptr [0x00d683e0]
0065eaf5 : LEA EBX,[ECX + EAX*0x1]
0065eaf8 : XOR EAX,EAX
0065eafa : INC EAX
0065eafb : JMP 0x0065eb9b
0065eb00 : MOV EAX,[0x00d683e0]
0065eb05 : AND dword ptr [EBP + -0x20],0x7fffffff
0065eb0c : ADD EBX,EAX
0065eb0e : MOV EAX,ECX
0065eb10 : CDQ
0065eb11 : AND EDX,0x1f
0065eb14 : ADD EAX,EDX
0065eb16 : MOV EDX,ECX
0065eb18 : SAR EAX,0x5
0065eb1b : AND EDX,0x8000001f
0065eb21 : JNS 0x0065eb28
0065eb23 : DEC EDX
0065eb24 : OR EDX,0xffffffe0
0065eb27 : INC EDX
0065eb28 : AND dword ptr [EBP + -0xc],0x0
0065eb2c : AND dword ptr [EBP + 0x8],0x0
0065eb30 : OR ESI,0xffffffff
0065eb33 : MOV ECX,EDX
0065eb35 : SHL ESI,CL
0065eb37 : MOV dword ptr [EBP + -0x4],0x20
0065eb3e : SUB dword ptr [EBP + -0x4],EDX
0065eb41 : NOT ESI
0065eb43 : MOV ECX,dword ptr [EBP + 0x8]
0065eb46 : MOV EDI,dword ptr [EBP + ECX*0x4 + -0x20]
0065eb4a : MOV ECX,EDI
0065eb4c : AND ECX,ESI
0065eb4e : MOV dword ptr [EBP + -0x10],ECX
0065eb51 : MOV ECX,EDX
0065eb53 : SHR EDI,CL
0065eb55 : MOV ECX,dword ptr [EBP + 0x8]
0065eb58 : OR EDI,dword ptr [EBP + -0xc]
0065eb5b : MOV dword ptr [EBP + ECX*0x4 + -0x20],EDI
0065eb5f : MOV EDI,dword ptr [EBP + -0x10]
0065eb62 : MOV ECX,dword ptr [EBP + -0x4]
0065eb65 : SHL EDI,CL
0065eb67 : INC dword ptr [EBP + 0x8]
0065eb6a : CMP dword ptr [EBP + 0x8],0x3
0065eb6e : MOV dword ptr [EBP + -0xc],EDI
0065eb71 : JL 0x0065eb43
0065eb73 : MOV ESI,EAX
0065eb75 : PUSH 0x2
0065eb77 : SHL ESI,0x2
0065eb7a : LEA ECX,[EBP + -0x18]
0065eb7d : POP EDX
0065eb7e : SUB ECX,ESI
0065eb80 : CMP EDX,EAX
0065eb82 : JL 0x0065eb8c
0065eb84 : MOV ESI,dword ptr [ECX]
0065eb86 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065eb8a : JMP 0x0065eb91
0065eb8c : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065eb91 : DEC EDX
0065eb92 : SUB ECX,0x4
0065eb95 : TEST EDX,EDX
0065eb97 : JGE 0x0065eb80
0065eb99 : XOR EAX,EAX
0065eb9b : POP ESI
0065eb9c : PUSH 0x1f
0065eb9e : POP ECX
0065eb9f : SUB ECX,dword ptr [0x00d683d8]
0065eba5 : SHL EBX,CL
0065eba7 : MOV ECX,dword ptr [EBP + -0x14]
0065ebaa : NEG ECX
0065ebac : SBB ECX,ECX
0065ebae : AND ECX,0x80000000
0065ebb4 : OR EBX,ECX
0065ebb6 : MOV ECX,dword ptr [0x00d683dc]
0065ebbc : OR EBX,dword ptr [EBP + -0x20]
0065ebbf : CMP ECX,0x40
0065ebc2 : JNZ 0x0065ebd1
0065ebc4 : MOV ECX,dword ptr [EBP + 0xc]
0065ebc7 : MOV EDX,dword ptr [EBP + -0x1c]
0065ebca : MOV dword ptr [ECX + 0x4],EBX
0065ebcd : MOV dword ptr [ECX],EDX
0065ebcf : JMP 0x0065ebdb
0065ebd1 : CMP ECX,0x20
0065ebd4 : JNZ 0x0065ebdb
0065ebd6 : MOV ECX,dword ptr [EBP + 0xc]
0065ebd9 : MOV dword ptr [ECX],EBX
0065ebdb : POP EDI
0065ebdc : POP EBX
0065ebdd : LEAVE
0065ebde : RET
