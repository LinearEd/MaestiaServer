PROGRAM  : Maestia.exe
FUNCTION : FUN_00705a70
ENTRY    : 00705a70
BODY     : [[00705a70, 00705b04]]

============================================================
DECOMPILED C CODE
============================================================

int FUN_00705a70(void)

{
  char *pcVar1;
  short *psVar2;
  char cVar3;
  short sVar4;
  undefined4 *in_EAX;
  char *pcVar5;
  uint uVar6;
  short *psVar7;
  int iVar8;
  undefined1 *in_ECX;
  uint uVar9;
  undefined1 *puVar10;
  
  if (*(char *)(in_EAX + 2) == '\0') {
    pcVar5 = (char *)in_EAX[1];
    if (pcVar5 != (char *)0x0) {
      pcVar1 = pcVar5 + 1;
      do {
        cVar3 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar3 != '\0');
      uVar6 = (int)pcVar5 - (int)pcVar1;
      *in_ECX = (char)uVar6;
      in_ECX[1] = *(undefined1 *)(in_EAX + 2);
      iVar8 = in_EAX[1];
      uVar9 = 0;
      if (uVar6 != 0) {
        puVar10 = in_ECX + 2;
        do {
          *puVar10 = *(undefined1 *)(uVar9 + iVar8);
          uVar9 = uVar9 + 1;
          puVar10 = puVar10 + 1;
        } while (uVar9 < uVar6);
      }
      return uVar6 + 2;
    }
  }
  else {
    psVar7 = (short *)*in_EAX;
    if (psVar7 != (short *)0x0) {
      psVar2 = psVar7 + 1;
      do {
        sVar4 = *psVar7;
        psVar7 = psVar7 + 1;
      } while (sVar4 != 0);
      iVar8 = (int)psVar7 - (int)psVar2 >> 1;
      *in_ECX = (char)iVar8;
      in_ECX[1] = *(undefined1 *)(in_EAX + 2);
      FUN_004d0c10();
      return iVar8 * 2 + 2;
    }
  }
  *in_ECX = 0;
  in_ECX[1] = *(undefined1 *)(in_EAX + 2);
  return 2;
}



============================================================
DISASSEMBLY
============================================================
00705a70 : PUSH ESI
00705a71 : MOV ESI,EAX
00705a73 : CMP byte ptr [ESI + 0x8],0x0
00705a77 : PUSH EDI
00705a78 : JNZ 0x00705ab3
00705a7a : MOV EAX,dword ptr [ESI + 0x4]
00705a7d : TEST EAX,EAX
00705a7f : JZ 0x00705af4
00705a81 : LEA EDI,[EAX + 0x1]
00705a84 : MOV DL,byte ptr [EAX]
00705a86 : INC EAX
00705a87 : TEST DL,DL
00705a89 : JNZ 0x00705a84
00705a8b : SUB EAX,EDI
00705a8d : MOV byte ptr [ECX],AL
00705a8f : MOV DL,byte ptr [ESI + 0x8]
00705a92 : MOV byte ptr [ECX + 0x1],DL
00705a95 : MOV ESI,dword ptr [ESI + 0x4]
00705a98 : MOV EDX,0x0
00705a9d : JZ 0x00705aad
00705a9f : LEA EDI,[ECX + 0x2]
00705aa2 : MOV CL,byte ptr [EDX + ESI*0x1]
00705aa5 : MOV byte ptr [EDI],CL
00705aa7 : INC EDX
00705aa8 : INC EDI
00705aa9 : CMP EDX,EAX
00705aab : JC 0x00705aa2
00705aad : POP EDI
00705aae : ADD EAX,0x2
00705ab1 : POP ESI
00705ab2 : RET
00705ab3 : MOV EAX,dword ptr [ESI]
00705ab5 : TEST EAX,EAX
00705ab7 : JZ 0x00705af4
00705ab9 : LEA EDI,[EAX + 0x2]
00705abc : LEA ESP,[ESP]
00705ac0 : MOV DX,word ptr [EAX]
00705ac3 : ADD EAX,0x2
00705ac6 : TEST DX,DX
00705ac9 : JNZ 0x00705ac0
00705acb : SUB EAX,EDI
00705acd : SAR EAX,0x1
00705acf : PUSH EBX
00705ad0 : MOV EBX,EAX
00705ad2 : MOV byte ptr [ECX],BL
00705ad4 : MOV AL,byte ptr [ESI + 0x8]
00705ad7 : MOV byte ptr [ECX + 0x1],AL
00705ada : MOV EDX,dword ptr [ESI]
00705adc : PUSH ECX
00705add : MOV EDI,EBX
00705adf : MOV EAX,0x2
00705ae4 : CALL 0x004d0c10
00705ae9 : ADD ESP,0x4
00705aec : LEA EAX,[EBX + EBX*0x1 + 0x2]
00705af0 : POP EBX
00705af1 : POP EDI
00705af2 : POP ESI
00705af3 : RET
00705af4 : MOV byte ptr [ECX],0x0
00705af7 : MOV AL,byte ptr [ESI + 0x8]
00705afa : POP EDI
00705afb : MOV byte ptr [ECX + 0x1],AL
00705afe : MOV EAX,0x2
00705b03 : POP ESI
00705b04 : RET
