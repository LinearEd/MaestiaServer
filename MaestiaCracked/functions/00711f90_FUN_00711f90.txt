PROGRAM  : Maestia.exe
FUNCTION : FUN_00711f90
ENTRY    : 00711f90
BODY     : [[00711f90, 0071206c]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00711f90(void)

{
  ushort *puVar1;
  uint _Size;
  short sVar2;
  short *psVar3;
  int iVar4;
  uint uVar5;
  int *unaff_EDI;
  
  _Size = unaff_EDI[9];
  while( true ) {
    if ((_Size - 0x106) + unaff_EDI[9] <= (uint)unaff_EDI[0x19]) {
      _memcpy((void *)unaff_EDI[0xc],(void *)(unaff_EDI[0xc] + _Size),_Size);
      iVar4 = unaff_EDI[0x11];
      unaff_EDI[0x1a] = unaff_EDI[0x1a] - _Size;
      unaff_EDI[0x19] = unaff_EDI[0x19] - _Size;
      unaff_EDI[0x15] = unaff_EDI[0x15] - _Size;
      psVar3 = (short *)(unaff_EDI[0xf] + iVar4 * 2);
      do {
        puVar1 = (ushort *)(psVar3 + -1);
        psVar3 = psVar3 + -1;
        if (*puVar1 < _Size) {
          sVar2 = 0;
        }
        else {
          sVar2 = *puVar1 - (short)_Size;
        }
        iVar4 = iVar4 + -1;
        *psVar3 = sVar2;
      } while (iVar4 != 0);
      psVar3 = (short *)(unaff_EDI[0xe] + _Size * 2);
      uVar5 = _Size;
      do {
        puVar1 = (ushort *)(psVar3 + -1);
        psVar3 = psVar3 + -1;
        if (*puVar1 < _Size) {
          sVar2 = 0;
        }
        else {
          sVar2 = *puVar1 - (short)_Size;
        }
        uVar5 = uVar5 - 1;
        *psVar3 = sVar2;
      } while (uVar5 != 0);
    }
    if (*(int *)(*unaff_EDI + 4) == 0) break;
    iVar4 = FUN_00711880(unaff_EDI[0x1b] + unaff_EDI[0x19] + unaff_EDI[0xc]);
    unaff_EDI[0x1b] = unaff_EDI[0x1b] + iVar4;
    if (2 < (uint)unaff_EDI[0x1b]) {
      uVar5 = (uint)*(byte *)(unaff_EDI[0x19] + unaff_EDI[0xc]);
      unaff_EDI[0x10] = uVar5;
      unaff_EDI[0x10] =
           (uVar5 << ((byte)unaff_EDI[0x14] & 0x1f) ^
           (uint)((byte *)(unaff_EDI[0x19] + unaff_EDI[0xc]))[1]) & unaff_EDI[0x13];
    }
    if (0x105 < (uint)unaff_EDI[0x1b]) {
      return;
    }
    if (*(int *)(*unaff_EDI + 4) == 0) {
      return;
    }
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00711f90 : PUSH EBX
00711f91 : MOV EBX,dword ptr [EDI + 0x24]
00711f94 : PUSH ESI
00711f95 : MOV ESI,dword ptr [EDI + 0x34]
00711f98 : SUB ESI,dword ptr [EDI + 0x6c]
00711f9b : MOV EAX,dword ptr [EDI + 0x64]
00711f9e : MOV ECX,dword ptr [EDI + 0x24]
00711fa1 : LEA EDX,[EBX + ECX*0x1 + 0xfffffefa]
00711fa8 : SUB ESI,EAX
00711faa : CMP EAX,EDX
00711fac : JC 0x0071200d
00711fae : MOV EAX,dword ptr [EDI + 0x30]
00711fb1 : PUSH EBX
00711fb2 : LEA ECX,[EAX + EBX*0x1]
00711fb5 : PUSH ECX
00711fb6 : PUSH EAX
00711fb7 : CALL 0x0063ae40
00711fbc : MOV EDX,dword ptr [EDI + 0x44]
00711fbf : MOV EAX,dword ptr [EDI + 0x3c]
00711fc2 : SUB dword ptr [EDI + 0x68],EBX
00711fc5 : SUB dword ptr [EDI + 0x64],EBX
00711fc8 : ADD ESP,0xc
00711fcb : SUB dword ptr [EDI + 0x54],EBX
00711fce : LEA ECX,[EAX + EDX*0x2]
00711fd1 : MOVZX EAX,word ptr [ECX + -0x2]
00711fd5 : SUB ECX,0x2
00711fd8 : CMP EAX,EBX
00711fda : JC 0x00711fe0
00711fdc : SUB EAX,EBX
00711fde : JMP 0x00711fe2
00711fe0 : XOR EAX,EAX
00711fe2 : SUB EDX,0x1
00711fe5 : MOV word ptr [ECX],AX
00711fe8 : JNZ 0x00711fd1
00711fea : MOV ECX,dword ptr [EDI + 0x38]
00711fed : MOV EDX,EBX
00711fef : LEA ECX,[ECX + EBX*0x2]
00711ff2 : MOVZX EAX,word ptr [ECX + -0x2]
00711ff6 : SUB ECX,0x2
00711ff9 : CMP EAX,EBX
00711ffb : JC 0x00712001
00711ffd : SUB EAX,EBX
00711fff : JMP 0x00712003
00712001 : XOR EAX,EAX
00712003 : SUB EDX,0x1
00712006 : MOV word ptr [ECX],AX
00712009 : JNZ 0x00711ff2
0071200b : ADD ESI,EBX
0071200d : MOV EAX,dword ptr [EDI]
0071200f : CMP dword ptr [EAX + 0x4],0x0
00712013 : JZ 0x0071206a
00712015 : MOV EDX,dword ptr [EDI + 0x6c]
00712018 : ADD EDX,dword ptr [EDI + 0x64]
0071201b : MOV ECX,ESI
0071201d : ADD EDX,dword ptr [EDI + 0x30]
00712020 : MOV ESI,EAX
00712022 : PUSH EDX
00712023 : CALL 0x00711880
00712028 : ADD dword ptr [EDI + 0x6c],EAX
0071202b : MOV EDX,dword ptr [EDI + 0x6c]
0071202e : ADD ESP,0x4
00712031 : CMP EDX,0x3
00712034 : JC 0x00712056
00712036 : MOV EAX,dword ptr [EDI + 0x64]
00712039 : MOV ECX,dword ptr [EDI + 0x30]
0071203c : LEA ESI,[EAX + ECX*0x1]
0071203f : MOVZX EAX,byte ptr [ESI]
00712042 : MOV ECX,dword ptr [EDI + 0x50]
00712045 : MOV dword ptr [EDI + 0x40],EAX
00712048 : SHL EAX,CL
0071204a : MOVZX ECX,byte ptr [ESI + 0x1]
0071204e : XOR EAX,ECX
00712050 : AND EAX,dword ptr [EDI + 0x4c]
00712053 : MOV dword ptr [EDI + 0x40],EAX
00712056 : CMP EDX,0x106
0071205c : JNC 0x0071206a
0071205e : MOV EDX,dword ptr [EDI]
00712060 : CMP dword ptr [EDX + 0x4],0x0
00712064 : JNZ 0x00711f95
0071206a : POP ESI
0071206b : POP EBX
0071206c : RET
