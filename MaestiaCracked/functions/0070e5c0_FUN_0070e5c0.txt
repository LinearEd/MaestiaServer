PROGRAM  : Maestia.exe
FUNCTION : FUN_0070e5c0
ENTRY    : 0070e5c0
BODY     : [[0070e5c0, 0070e5db] [0070e5e0, 0070e9e4]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_0070e5c0(int param_1,int param_2)

{
  ushort uVar1;
  int iVar2;
  int in_EAX;
  byte bVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  
  uVar4 = 0;
  if (*(int *)(in_EAX + 0x1698) != 0) {
    do {
      uVar10 = (uint)*(ushort *)(*(int *)(in_EAX + 0x169c) + uVar4 * 2);
      uVar8 = (uint)*(byte *)(uVar4 + *(int *)(in_EAX + 0x1690));
      uVar4 = uVar4 + 1;
      if (uVar10 == 0) {
        uVar10 = (uint)*(ushort *)(param_1 + 2 + uVar8 * 4);
        iVar5 = *(int *)(in_EAX + 0x16b4);
        if ((int)(0x10 - uVar10) < iVar5) {
          uVar1 = *(ushort *)(param_1 + uVar8 * 4);
          *(ushort *)(in_EAX + 0x16b0) =
               *(ushort *)(in_EAX + 0x16b0) | uVar1 << ((byte)iVar5 & 0x1f);
          *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
               *(undefined1 *)(in_EAX + 0x16b0);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
               *(undefined1 *)(in_EAX + 0x16b1);
          iVar2 = *(int *)(in_EAX + 0x16b4);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(uint *)(in_EAX + 0x16b4) = iVar2 + -0x10 + uVar10;
          *(ushort *)(in_EAX + 0x16b0) = uVar1 >> (0x10U - (char)iVar2 & 0x1f);
        }
        else {
          *(ushort *)(in_EAX + 0x16b0) =
               *(ushort *)(in_EAX + 0x16b0) |
               *(short *)(param_1 + uVar8 * 4) << ((byte)iVar5 & 0x1f);
          iVar5 = iVar5 + uVar10;
LAB_0070e917:
          *(int *)(in_EAX + 0x16b4) = iVar5;
        }
      }
      else {
        uVar7 = (uint)(byte)(&DAT_00bfe240)[uVar8];
        uVar6 = (uint)*(ushort *)(param_1 + 0x406 + uVar7 * 4);
        bVar3 = (byte)*(int *)(in_EAX + 0x16b4);
        if ((int)(0x10 - uVar6) < *(int *)(in_EAX + 0x16b4)) {
          uVar1 = *(ushort *)(param_1 + 0x404 + uVar7 * 4);
          *(ushort *)(in_EAX + 0x16b0) = *(ushort *)(in_EAX + 0x16b0) | uVar1 << (bVar3 & 0x1f);
          *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
               *(undefined1 *)(in_EAX + 0x16b0);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
               *(undefined1 *)(in_EAX + 0x16b1);
          iVar2 = *(int *)(in_EAX + 0x16b4);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(uint *)(in_EAX + 0x16b4) = iVar2 + -0x10 + uVar6;
          *(ushort *)(in_EAX + 0x16b0) = uVar1 >> (0x10U - (char)iVar2 & 0x1f);
        }
        else {
          *(ushort *)(in_EAX + 0x16b0) =
               *(ushort *)(in_EAX + 0x16b0) |
               *(short *)(param_1 + 0x404 + uVar7 * 4) << (bVar3 & 0x1f);
          *(uint *)(in_EAX + 0x16b4) = *(int *)(in_EAX + 0x16b4) + uVar6;
        }
        iVar2 = *(int *)(&DAT_00bfd9f8 + uVar7 * 4);
        if (iVar2 != 0) {
          iVar9 = uVar8 - *(int *)(&DAT_00bfe340 + uVar7 * 4);
          iVar5 = *(int *)(in_EAX + 0x16b4);
          if (0x10 - iVar2 < iVar5) {
            *(ushort *)(in_EAX + 0x16b0) =
                 *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar9 << ((byte)iVar5 & 0x1f));
            *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
                 *(undefined1 *)(in_EAX + 0x16b0);
            *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
            *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
                 *(undefined1 *)(in_EAX + 0x16b1);
            iVar5 = *(int *)(in_EAX + 0x16b4);
            *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
            *(int *)(in_EAX + 0x16b4) = iVar5 + -0x10 + iVar2;
            *(ushort *)(in_EAX + 0x16b0) = (ushort)iVar9 >> (0x10U - (char)iVar5 & 0x1f);
          }
          else {
            *(ushort *)(in_EAX + 0x16b0) =
                 *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar9 << ((byte)iVar5 & 0x1f));
            *(int *)(in_EAX + 0x16b4) = iVar5 + iVar2;
          }
        }
        uVar8 = uVar10 - 1;
        if (uVar8 < 0x100) {
          bVar3 = (&DAT_00bfe03f)[uVar10];
        }
        else {
          bVar3 = (&DAT_00bfe140)[uVar8 >> 7];
        }
        uVar10 = (uint)bVar3;
        uVar6 = (uint)*(ushort *)(param_2 + 2 + uVar10 * 4);
        iVar2 = *(int *)(in_EAX + 0x16b4);
        if ((int)(0x10 - uVar6) < iVar2) {
          uVar1 = *(ushort *)(param_2 + uVar10 * 4);
          *(ushort *)(in_EAX + 0x16b0) =
               *(ushort *)(in_EAX + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
          *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
               *(undefined1 *)(in_EAX + 0x16b0);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
               *(undefined1 *)(in_EAX + 0x16b1);
          iVar2 = *(int *)(in_EAX + 0x16b4);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(uint *)(in_EAX + 0x16b4) = iVar2 + -0x10 + uVar6;
          *(ushort *)(in_EAX + 0x16b0) = uVar1 >> (0x10U - (char)iVar2 & 0x1f);
        }
        else {
          *(ushort *)(in_EAX + 0x16b0) =
               *(ushort *)(in_EAX + 0x16b0) |
               *(short *)(param_2 + uVar10 * 4) << ((byte)iVar2 & 0x1f);
          *(uint *)(in_EAX + 0x16b4) = iVar2 + uVar6;
        }
        iVar2 = *(int *)(&DAT_00bfda80 + uVar10 * 4);
        if (iVar2 != 0) {
          iVar9 = uVar8 - *(int *)(&DAT_00bfe3b8 + uVar10 * 4);
          iVar5 = *(int *)(in_EAX + 0x16b4);
          if (iVar5 <= 0x10 - iVar2) {
            *(ushort *)(in_EAX + 0x16b0) =
                 *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar9 << ((byte)iVar5 & 0x1f));
            iVar5 = iVar5 + iVar2;
            goto LAB_0070e917;
          }
          *(ushort *)(in_EAX + 0x16b0) =
               *(ushort *)(in_EAX + 0x16b0) | (ushort)(iVar9 << ((byte)iVar5 & 0x1f));
          *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) =
               *(undefined1 *)(in_EAX + 0x16b0);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) =
               *(undefined1 *)(in_EAX + 0x16b1);
          iVar5 = *(int *)(in_EAX + 0x16b4);
          *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
          *(int *)(in_EAX + 0x16b4) = iVar5 + -0x10 + iVar2;
          *(ushort *)(in_EAX + 0x16b0) = (ushort)iVar9 >> (0x10U - (char)iVar5 & 0x1f);
        }
      }
    } while (uVar4 < *(uint *)(in_EAX + 0x1698));
  }
  uVar4 = (uint)*(ushort *)(param_1 + 0x402);
  iVar2 = *(int *)(in_EAX + 0x16b4);
  if (iVar2 <= (int)(0x10 - uVar4)) {
    *(ushort *)(in_EAX + 0x16b0) =
         *(ushort *)(in_EAX + 0x16b0) | *(short *)(param_1 + 0x400) << ((byte)iVar2 & 0x1f);
    *(uint *)(in_EAX + 0x16b4) = iVar2 + uVar4;
    *(uint *)(in_EAX + 0x16ac) = (uint)*(ushort *)(param_1 + 0x402);
    return;
  }
  uVar1 = *(ushort *)(param_1 + 0x400);
  *(ushort *)(in_EAX + 0x16b0) = *(ushort *)(in_EAX + 0x16b0) | uVar1 << ((byte)iVar2 & 0x1f);
  *(undefined1 *)(*(int *)(in_EAX + 8) + *(int *)(in_EAX + 0x14)) = *(undefined1 *)(in_EAX + 0x16b0)
  ;
  *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
  *(undefined1 *)(*(int *)(in_EAX + 0x14) + *(int *)(in_EAX + 8)) = *(undefined1 *)(in_EAX + 0x16b1)
  ;
  iVar2 = *(int *)(in_EAX + 0x16b4);
  *(int *)(in_EAX + 0x14) = *(int *)(in_EAX + 0x14) + 1;
  *(uint *)(in_EAX + 0x16b4) = iVar2 + -0x10 + uVar4;
  *(ushort *)(in_EAX + 0x16b0) = uVar1 >> (0x10U - (char)iVar2 & 0x1f);
  *(uint *)(in_EAX + 0x16ac) = (uint)*(ushort *)(param_1 + 0x402);
  return;
}



============================================================
DISASSEMBLY
============================================================
0070e5c0 : PUSH EBP
0070e5c1 : MOV EBP,ESP
0070e5c3 : SUB ESP,0x10
0070e5c6 : PUSH EBX
0070e5c7 : MOV EBX,dword ptr [EBP + 0x8]
0070e5ca : XOR ECX,ECX
0070e5cc : PUSH ESI
0070e5cd : PUSH EDI
0070e5ce : CMP dword ptr [EAX + 0x1698],ECX
0070e5d4 : JZ 0x0070e92c
0070e5da : JMP 0x0070e5e3
0070e5e0 : MOV ECX,dword ptr [EBP + -0xc]
0070e5e3 : MOV EDX,dword ptr [EAX + 0x169c]
0070e5e9 : MOVZX EDI,word ptr [EDX + ECX*0x2]
0070e5ed : MOV EDX,dword ptr [EAX + 0x1690]
0070e5f3 : MOVZX ESI,byte ptr [ECX + EDX*0x1]
0070e5f7 : INC ECX
0070e5f8 : MOV dword ptr [EBP + -0x10],EDI
0070e5fb : MOV dword ptr [EBP + -0xc],ECX
0070e5fe : TEST EDI,EDI
0070e600 : JNZ 0x0070e693
0070e606 : MOVZX EDX,word ptr [EBX + ESI*0x4 + 0x2]
0070e60b : MOV ECX,dword ptr [EAX + 0x16b4]
0070e611 : MOV EDI,0x10
0070e616 : SUB EDI,EDX
0070e618 : CMP ECX,EDI
0070e61a : MOV dword ptr [EBP + -0x8],EDX
0070e61d : JLE 0x0070e67e
0070e61f : MOVZX ESI,word ptr [EBX + ESI*0x4]
0070e623 : MOV EDX,ESI
0070e625 : SHL EDX,CL
0070e627 : MOV ECX,dword ptr [EAX + 0x8]
0070e62a : MOV dword ptr [EBP + -0x4],EBX
0070e62d : OR word ptr [EAX + 0x16b0],DX
0070e634 : MOV EDX,dword ptr [EAX + 0x14]
0070e637 : MOV BL,byte ptr [EAX + 0x16b0]
0070e63d : MOV byte ptr [ECX + EDX*0x1],BL
0070e640 : INC dword ptr [EAX + 0x14]
0070e643 : MOV ECX,dword ptr [EAX + 0x8]
0070e646 : MOV DL,byte ptr [EAX + 0x16b1]
0070e64c : MOV EDI,dword ptr [EAX + 0x14]
0070e64f : MOV EBX,dword ptr [EBP + -0x4]
0070e652 : MOV byte ptr [EDI + ECX*0x1],DL
0070e655 : MOV EDX,dword ptr [EAX + 0x16b4]
0070e65b : INC dword ptr [EAX + 0x14]
0070e65e : MOV CL,0x10
0070e660 : SUB CL,DL
0070e662 : SHR SI,CL
0070e665 : MOV ECX,dword ptr [EBP + -0x8]
0070e668 : LEA EDX,[EDX + ECX*0x1 + -0x10]
0070e66c : MOV dword ptr [EAX + 0x16b4],EDX
0070e672 : MOV word ptr [EAX + 0x16b0],SI
0070e679 : JMP 0x0070e91d
0070e67e : MOV SI,word ptr [EBX + ESI*0x4]
0070e682 : SHL SI,CL
0070e685 : OR word ptr [EAX + 0x16b0],SI
0070e68c : ADD ECX,EDX
0070e68e : JMP 0x0070e917
0070e693 : MOVZX EDX,byte ptr [ESI + 0xbfe240]
0070e69a : MOVZX ECX,word ptr [EBX + EDX*0x4 + 0x406]
0070e6a2 : MOV EBX,0x10
0070e6a7 : SUB EBX,ECX
0070e6a9 : MOV dword ptr [EBP + -0x8],ECX
0070e6ac : MOV ECX,dword ptr [EAX + 0x16b4]
0070e6b2 : CMP ECX,EBX
0070e6b4 : MOV dword ptr [EBP + -0x4],EDX
0070e6b7 : JLE 0x0070e71e
0070e6b9 : MOV EDI,dword ptr [EBP + 0x8]
0070e6bc : MOVZX EDI,word ptr [EDI + EDX*0x4 + 0x404]
0070e6c4 : MOV EDX,EDI
0070e6c6 : SHL EDX,CL
0070e6c8 : MOV ECX,dword ptr [EAX + 0x8]
0070e6cb : OR word ptr [EAX + 0x16b0],DX
0070e6d2 : MOVZX EBX,byte ptr [EAX + 0x16b0]
0070e6d9 : MOV EDX,dword ptr [EAX + 0x14]
0070e6dc : MOV byte ptr [ECX + EDX*0x1],BL
0070e6df : INC dword ptr [EAX + 0x14]
0070e6e2 : MOV ECX,dword ptr [EAX + 0x14]
0070e6e5 : MOVZX EBX,byte ptr [EAX + 0x16b1]
0070e6ec : MOV EDX,dword ptr [EAX + 0x8]
0070e6ef : MOV byte ptr [ECX + EDX*0x1],BL
0070e6f2 : MOV EDX,dword ptr [EAX + 0x16b4]
0070e6f8 : INC dword ptr [EAX + 0x14]
0070e6fb : MOV CL,0x10
0070e6fd : SUB CL,DL
0070e6ff : SHR DI,CL
0070e702 : MOV ECX,dword ptr [EBP + -0x8]
0070e705 : LEA EDX,[EDX + ECX*0x1 + -0x10]
0070e709 : MOV dword ptr [EAX + 0x16b4],EDX
0070e70f : MOV EDX,dword ptr [EBP + -0x4]
0070e712 : MOV word ptr [EAX + 0x16b0],DI
0070e719 : MOV EDI,dword ptr [EBP + -0x10]
0070e71c : JMP 0x0070e744
0070e71e : MOV EBX,dword ptr [EBP + 0x8]
0070e721 : MOV BX,word ptr [EBX + EDX*0x4 + 0x404]
0070e729 : SHL BX,CL
0070e72c : MOV ECX,dword ptr [EAX + 0x16b4]
0070e732 : OR word ptr [EAX + 0x16b0],BX
0070e739 : MOV EBX,dword ptr [EBP + -0x8]
0070e73c : ADD ECX,EBX
0070e73e : MOV dword ptr [EAX + 0x16b4],ECX
0070e744 : MOV EBX,dword ptr [EDX*0x4 + 0xbfd9f8]
0070e74b : MOV dword ptr [EBP + -0x4],EBX
0070e74e : TEST EBX,EBX
0070e750 : JZ 0x0070e7d3
0070e756 : SUB ESI,dword ptr [EDX*0x4 + 0xbfe340]
0070e75d : MOV ECX,dword ptr [EAX + 0x16b4]
0070e763 : MOV EDX,0x10
0070e768 : SUB EDX,EBX
0070e76a : CMP ECX,EDX
0070e76c : JLE 0x0070e7c2
0070e76e : MOV EDX,ESI
0070e770 : SHL EDX,CL
0070e772 : MOV ECX,dword ptr [EAX + 0x8]
0070e775 : OR word ptr [EAX + 0x16b0],DX
0070e77c : MOVZX EBX,byte ptr [EAX + 0x16b0]
0070e783 : MOV EDX,dword ptr [EAX + 0x14]
0070e786 : MOV byte ptr [ECX + EDX*0x1],BL
0070e789 : INC dword ptr [EAX + 0x14]
0070e78c : MOV ECX,dword ptr [EAX + 0x14]
0070e78f : MOVZX EBX,byte ptr [EAX + 0x16b1]
0070e796 : MOV EDX,dword ptr [EAX + 0x8]
0070e799 : MOV byte ptr [ECX + EDX*0x1],BL
0070e79c : MOV EDX,dword ptr [EAX + 0x16b4]
0070e7a2 : INC dword ptr [EAX + 0x14]
0070e7a5 : MOV CL,0x10
0070e7a7 : SUB CL,DL
0070e7a9 : SHR SI,CL
0070e7ac : MOV ECX,dword ptr [EBP + -0x4]
0070e7af : LEA EDX,[EDX + ECX*0x1 + -0x10]
0070e7b3 : MOV dword ptr [EAX + 0x16b4],EDX
0070e7b9 : MOV word ptr [EAX + 0x16b0],SI
0070e7c0 : JMP 0x0070e7d3
0070e7c2 : SHL ESI,CL
0070e7c4 : OR word ptr [EAX + 0x16b0],SI
0070e7cb : ADD ECX,EBX
0070e7cd : MOV dword ptr [EAX + 0x16b4],ECX
0070e7d3 : DEC EDI
0070e7d4 : CMP EDI,0x100
0070e7da : JNC 0x0070e7e5
0070e7dc : MOVZX EDX,byte ptr [EDI + 0xbfe040]
0070e7e3 : JMP 0x0070e7f1
0070e7e5 : MOV ECX,EDI
0070e7e7 : SHR ECX,0x7
0070e7ea : MOVZX EDX,byte ptr [ECX + 0xbfe140]
0070e7f1 : MOV ECX,dword ptr [EBP + 0xc]
0070e7f4 : MOVZX ESI,word ptr [ECX + EDX*0x4 + 0x2]
0070e7f9 : MOV ECX,dword ptr [EAX + 0x16b4]
0070e7ff : MOV EBX,0x10
0070e804 : SUB EBX,ESI
0070e806 : CMP ECX,EBX
0070e808 : MOV dword ptr [EBP + -0x8],ESI
0070e80b : MOV ESI,dword ptr [EBP + 0xc]
0070e80e : MOV dword ptr [EBP + -0x4],EDX
0070e811 : JLE 0x0070e86e
0070e813 : MOVZX ESI,word ptr [ESI + EDX*0x4]
0070e817 : MOV EDX,ESI
0070e819 : SHL EDX,CL
0070e81b : MOV ECX,dword ptr [EAX + 0x8]
0070e81e : OR word ptr [EAX + 0x16b0],DX
0070e825 : MOVZX EBX,byte ptr [EAX + 0x16b0]
0070e82c : MOV EDX,dword ptr [EAX + 0x14]
0070e82f : MOV byte ptr [ECX + EDX*0x1],BL
0070e832 : INC dword ptr [EAX + 0x14]
0070e835 : MOV ECX,dword ptr [EAX + 0x14]
0070e838 : MOVZX EBX,byte ptr [EAX + 0x16b1]
0070e83f : MOV EDX,dword ptr [EAX + 0x8]
0070e842 : MOV byte ptr [ECX + EDX*0x1],BL
0070e845 : MOV EDX,dword ptr [EAX + 0x16b4]
0070e84b : INC dword ptr [EAX + 0x14]
0070e84e : MOV CL,0x10
0070e850 : SUB CL,DL
0070e852 : SHR SI,CL
0070e855 : MOV ECX,dword ptr [EBP + -0x8]
0070e858 : LEA EDX,[EDX + ECX*0x1 + -0x10]
0070e85c : MOV dword ptr [EAX + 0x16b4],EDX
0070e862 : MOV EDX,dword ptr [EBP + -0x4]
0070e865 : MOV word ptr [EAX + 0x16b0],SI
0070e86c : JMP 0x0070e887
0070e86e : MOV SI,word ptr [ESI + EDX*0x4]
0070e872 : SHL SI,CL
0070e875 : OR word ptr [EAX + 0x16b0],SI
0070e87c : MOV ESI,dword ptr [EBP + -0x8]
0070e87f : ADD ECX,ESI
0070e881 : MOV dword ptr [EAX + 0x16b4],ECX
0070e887 : MOV ESI,dword ptr [EDX*0x4 + 0xbfda80]
0070e88e : MOV EBX,dword ptr [EBP + 0x8]
0070e891 : MOV dword ptr [EBP + -0x4],ESI
0070e894 : TEST ESI,ESI
0070e896 : JZ 0x0070e91d
0070e89c : SUB EDI,dword ptr [EDX*0x4 + 0xbfe3b8]
0070e8a3 : MOV ECX,dword ptr [EAX + 0x16b4]
0070e8a9 : MOV EDX,0x10
0070e8ae : SUB EDX,ESI
0070e8b0 : CMP ECX,EDX
0070e8b2 : JLE 0x0070e90c
0070e8b4 : MOV EDX,EDI
0070e8b6 : SHL EDX,CL
0070e8b8 : MOV ECX,dword ptr [EAX + 0x8]
0070e8bb : MOV dword ptr [EBP + -0x10],EBX
0070e8be : OR word ptr [EAX + 0x16b0],DX
0070e8c5 : MOV EDX,dword ptr [EAX + 0x14]
0070e8c8 : MOV BL,byte ptr [EAX + 0x16b0]
0070e8ce : MOV byte ptr [ECX + EDX*0x1],BL
0070e8d1 : INC dword ptr [EAX + 0x14]
0070e8d4 : MOV ECX,dword ptr [EAX + 0x8]
0070e8d7 : MOV DL,byte ptr [EAX + 0x16b1]
0070e8dd : MOV ESI,dword ptr [EAX + 0x14]
0070e8e0 : MOV EBX,dword ptr [EBP + -0x10]
0070e8e3 : MOV byte ptr [ESI + ECX*0x1],DL
0070e8e6 : MOV EDX,dword ptr [EAX + 0x16b4]
0070e8ec : INC dword ptr [EAX + 0x14]
0070e8ef : MOV CL,0x10
0070e8f1 : SUB CL,DL
0070e8f3 : SHR DI,CL
0070e8f6 : MOV ECX,dword ptr [EBP + -0x4]
0070e8f9 : LEA EDX,[EDX + ECX*0x1 + -0x10]
0070e8fd : MOV dword ptr [EAX + 0x16b4],EDX
0070e903 : MOV word ptr [EAX + 0x16b0],DI
0070e90a : JMP 0x0070e91d
0070e90c : SHL EDI,CL
0070e90e : OR word ptr [EAX + 0x16b0],DI
0070e915 : ADD ECX,ESI
0070e917 : MOV dword ptr [EAX + 0x16b4],ECX
0070e91d : MOV ECX,dword ptr [EBP + -0xc]
0070e920 : CMP ECX,dword ptr [EAX + 0x1698]
0070e926 : JC 0x0070e5e0
0070e92c : MOVZX EDX,word ptr [EBX + 0x402]
0070e933 : MOV ECX,dword ptr [EAX + 0x16b4]
0070e939 : MOV ESI,0x10
0070e93e : SUB ESI,EDX
0070e940 : CMP ECX,ESI
0070e942 : MOV dword ptr [EBP + 0x8],EDX
0070e945 : JLE 0x0070e9b8
0070e947 : MOVZX ESI,word ptr [EBX + 0x400]
0070e94e : MOV EDX,ESI
0070e950 : SHL EDX,CL
0070e952 : MOV ECX,dword ptr [EAX + 0x8]
0070e955 : MOV dword ptr [EBP + -0x10],EBX
0070e958 : OR word ptr [EAX + 0x16b0],DX
0070e95f : MOV EDX,dword ptr [EAX + 0x14]
0070e962 : MOV BL,byte ptr [EAX + 0x16b0]
0070e968 : MOV byte ptr [ECX + EDX*0x1],BL
0070e96b : INC dword ptr [EAX + 0x14]
0070e96e : MOV EDI,dword ptr [EAX + 0x14]
0070e971 : MOV ECX,dword ptr [EAX + 0x8]
0070e974 : MOV DL,byte ptr [EAX + 0x16b1]
0070e97a : MOV EBX,dword ptr [EBP + -0x10]
0070e97d : MOV byte ptr [EDI + ECX*0x1],DL
0070e980 : MOV EDX,dword ptr [EAX + 0x16b4]
0070e986 : INC dword ptr [EAX + 0x14]
0070e989 : MOV CL,0x10
0070e98b : SUB CL,DL
0070e98d : SHR SI,CL
0070e990 : MOV ECX,dword ptr [EBP + 0x8]
0070e993 : LEA EDX,[EDX + ECX*0x1 + -0x10]
0070e997 : MOV dword ptr [EAX + 0x16b4],EDX
0070e99d : MOV word ptr [EAX + 0x16b0],SI
0070e9a4 : MOVZX ECX,word ptr [EBX + 0x402]
0070e9ab : POP EDI
0070e9ac : POP ESI
0070e9ad : MOV dword ptr [EAX + 0x16ac],ECX
0070e9b3 : POP EBX
0070e9b4 : MOV ESP,EBP
0070e9b6 : POP EBP
0070e9b7 : RET
0070e9b8 : MOV SI,word ptr [EBX + 0x400]
0070e9bf : SHL SI,CL
0070e9c2 : POP EDI
0070e9c3 : OR word ptr [EAX + 0x16b0],SI
0070e9ca : ADD ECX,EDX
0070e9cc : MOV dword ptr [EAX + 0x16b4],ECX
0070e9d2 : MOVZX EDX,word ptr [EBX + 0x402]
0070e9d9 : POP ESI
0070e9da : MOV dword ptr [EAX + 0x16ac],EDX
0070e9e0 : POP EBX
0070e9e1 : MOV ESP,EBP
0070e9e3 : POP EBP
0070e9e4 : RET
