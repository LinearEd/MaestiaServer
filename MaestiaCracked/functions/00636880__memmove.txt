PROGRAM  : Maestia.exe
FUNCTION : _memmove
ENTRY    : 00636880
BODY     : [[00636880, 006368e2] [006368e4, 00636902] [00636904, 0063690a] [00636918, 00636940] [00636944, 00636966] [00636968, 00636984] [006369a8, 006369f1] [00636a04, 00636a0a] [00636a0c, 00636a16] [00636a18, 00636a28] [00636a2c, 00636a42] [00636a44, 00636a69] [00636a6c, 00636a74] [00636a78, 00636a96] [00636aa4, 00636ac4] [00636ac8, 00636aee] [00636af0, 00636b20] [00636b44, 00636b8d] [00636ba0, 00636ba6] [00636ba8, 00636bb4] [00636bb8, 00636bca] [00636bcc, 00636be4]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    _memmove
   
   Libraries: Visual Studio 2005 Debug, Visual Studio 2005 Release, Visual Studio 2008 Debug, Visual
   Studio 2008 Release */

void * __cdecl _memmove(void *_Dst,void *_Src,size_t _Size)

{
  void *pvVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar4 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar5 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar5 & 3) == 0) {
      uVar2 = _Size >> 2;
      uVar3 = _Size & 3;
      if (7 < uVar2) {
        for (; uVar2 != 0; uVar2 = uVar2 - 1) {
          *puVar5 = *puVar4;
          puVar4 = puVar4 + -1;
          puVar5 = puVar5 + -1;
        }
        switch(uVar3) {
        case 0:
          return _Dst;
        case 2:
          goto switchD_00636a63_caseD_2;
        case 3:
          goto switchD_00636a63_caseD_3;
        }
        goto switchD_00636a63_caseD_1;
      }
    }
    else {
      switch(_Size) {
      case 0:
        goto switchD_00636a63_caseD_0;
      case 1:
        goto switchD_00636a63_caseD_1;
      case 2:
        goto switchD_00636a63_caseD_2;
      case 3:
        goto switchD_00636a63_caseD_3;
      default:
        uVar2 = _Size - ((uint)puVar5 & 3);
        switch((uint)puVar5 & 3) {
        case 1:
          uVar3 = uVar2 & 3;
          *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
          puVar4 = (undefined4 *)((int)puVar4 + -1);
          uVar2 = uVar2 >> 2;
          puVar5 = (undefined4 *)((int)puVar5 - 1);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar5 = *puVar4;
              puVar4 = puVar4 + -1;
              puVar5 = puVar5 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_00636a63_caseD_2;
            case 3:
              goto switchD_00636a63_caseD_3;
            }
            goto switchD_00636a63_caseD_1;
          }
          break;
        case 2:
          uVar3 = uVar2 & 3;
          *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
          uVar2 = uVar2 >> 2;
          *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
          puVar4 = (undefined4 *)((int)puVar4 + -2);
          puVar5 = (undefined4 *)((int)puVar5 - 2);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar5 = *puVar4;
              puVar4 = puVar4 + -1;
              puVar5 = puVar5 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_00636a63_caseD_2;
            case 3:
              goto switchD_00636a63_caseD_3;
            }
            goto switchD_00636a63_caseD_1;
          }
          break;
        case 3:
          uVar3 = uVar2 & 3;
          *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
          *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
          uVar2 = uVar2 >> 2;
          *(undefined1 *)((int)puVar5 + 1) = *(undefined1 *)((int)puVar4 + 1);
          puVar4 = (undefined4 *)((int)puVar4 + -3);
          puVar5 = (undefined4 *)((int)puVar5 - 3);
          if (7 < uVar2) {
            for (; uVar2 != 0; uVar2 = uVar2 - 1) {
              *puVar5 = *puVar4;
              puVar4 = puVar4 + -1;
              puVar5 = puVar5 + -1;
            }
            switch(uVar3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_00636a63_caseD_2;
            case 3:
              goto switchD_00636a63_caseD_3;
            }
            goto switchD_00636a63_caseD_1;
          }
        }
      }
    }
    switch(uVar2) {
    case 7:
      puVar5[7 - uVar2] = puVar4[7 - uVar2];
    case 6:
      puVar5[6 - uVar2] = puVar4[6 - uVar2];
    case 5:
      puVar5[5 - uVar2] = puVar4[5 - uVar2];
    case 4:
      puVar5[4 - uVar2] = puVar4[4 - uVar2];
    case 3:
      puVar5[3 - uVar2] = puVar4[3 - uVar2];
    case 2:
      puVar5[2 - uVar2] = puVar4[2 - uVar2];
    case 1:
      puVar5[1 - uVar2] = puVar4[1 - uVar2];
      puVar4 = puVar4 + -uVar2;
      puVar5 = puVar5 + -uVar2;
    }
    switch(uVar3) {
    case 1:
switchD_00636a63_caseD_1:
      *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
      return _Dst;
    case 2:
switchD_00636a63_caseD_2:
      *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
      *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
      return _Dst;
    case 3:
switchD_00636a63_caseD_3:
      *(undefined1 *)((int)puVar5 + 3) = *(undefined1 *)((int)puVar4 + 3);
      *(undefined1 *)((int)puVar5 + 2) = *(undefined1 *)((int)puVar4 + 2);
      *(undefined1 *)((int)puVar5 + 1) = *(undefined1 *)((int)puVar4 + 1);
      return _Dst;
    }
switchD_00636a63_caseD_0:
    return _Dst;
  }
  if (((0xff < _Size) && (DAT_01728c2c != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {
    pvVar1 = (void *)__VEC_memcpy();
    return pvVar1;
  }
  puVar4 = _Dst;
  if (((uint)_Dst & 3) == 0) {
    uVar2 = _Size >> 2;
    uVar3 = _Size & 3;
    if (7 < uVar2) {
      for (; uVar2 != 0; uVar2 = uVar2 - 1) {
        *puVar4 = *(undefined4 *)_Src;
        _Src = (undefined4 *)((int)_Src + 4);
        puVar4 = puVar4 + 1;
      }
      switch(uVar3) {
      case 0:
        return _Dst;
      case 2:
        goto switchD_006368dc_caseD_2;
      case 3:
        goto switchD_006368dc_caseD_3;
      }
      goto switchD_006368dc_caseD_1;
    }
  }
  else {
    switch(_Size) {
    case 0:
      goto switchD_006368dc_caseD_0;
    case 1:
      goto switchD_006368dc_caseD_1;
    case 2:
      goto switchD_006368dc_caseD_2;
    case 3:
      goto switchD_006368dc_caseD_3;
    default:
      uVar2 = (_Size - 4) + ((uint)_Dst & 3);
      switch((uint)_Dst & 3) {
      case 1:
        uVar3 = uVar2 & 3;
        *(undefined1 *)_Dst = *(undefined1 *)_Src;
        *(undefined1 *)((int)_Dst + 1) = *(undefined1 *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        *(undefined1 *)((int)_Dst + 2) = *(undefined1 *)((int)_Src + 2);
        _Src = (void *)((int)_Src + 3);
        puVar4 = (undefined4 *)((int)_Dst + 3);
        if (7 < uVar2) {
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar4 = *(undefined4 *)_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar4 = puVar4 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_006368dc_caseD_2;
          case 3:
            goto switchD_006368dc_caseD_3;
          }
          goto switchD_006368dc_caseD_1;
        }
        break;
      case 2:
        uVar3 = uVar2 & 3;
        *(undefined1 *)_Dst = *(undefined1 *)_Src;
        uVar2 = uVar2 >> 2;
        *(undefined1 *)((int)_Dst + 1) = *(undefined1 *)((int)_Src + 1);
        _Src = (void *)((int)_Src + 2);
        puVar4 = (undefined4 *)((int)_Dst + 2);
        if (7 < uVar2) {
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar4 = *(undefined4 *)_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar4 = puVar4 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_006368dc_caseD_2;
          case 3:
            goto switchD_006368dc_caseD_3;
          }
          goto switchD_006368dc_caseD_1;
        }
        break;
      case 3:
        uVar3 = uVar2 & 3;
        *(undefined1 *)_Dst = *(undefined1 *)_Src;
        _Src = (void *)((int)_Src + 1);
        uVar2 = uVar2 >> 2;
        puVar4 = (undefined4 *)((int)_Dst + 1);
        if (7 < uVar2) {
          for (; uVar2 != 0; uVar2 = uVar2 - 1) {
            *puVar4 = *(undefined4 *)_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar4 = puVar4 + 1;
          }
          switch(uVar3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_006368dc_caseD_2;
          case 3:
            goto switchD_006368dc_caseD_3;
          }
          goto switchD_006368dc_caseD_1;
        }
      }
    }
  }
  switch(uVar2) {
  case 7:
    puVar4[uVar2 - 7] = *(undefined4 *)((int)_Src + (uVar2 - 7) * 4);
  case 6:
    puVar4[uVar2 - 6] = *(undefined4 *)((int)_Src + (uVar2 - 6) * 4);
  case 5:
    puVar4[uVar2 - 5] = *(undefined4 *)((int)_Src + (uVar2 - 5) * 4);
  case 4:
    puVar4[uVar2 - 4] = *(undefined4 *)((int)_Src + (uVar2 - 4) * 4);
  case 3:
    puVar4[uVar2 - 3] = *(undefined4 *)((int)_Src + (uVar2 - 3) * 4);
  case 2:
    puVar4[uVar2 - 2] = *(undefined4 *)((int)_Src + (uVar2 - 2) * 4);
  case 1:
    puVar4[uVar2 - 1] = *(undefined4 *)((int)_Src + (uVar2 - 1) * 4);
    _Src = (void *)((int)_Src + uVar2 * 4);
    puVar4 = puVar4 + uVar2;
  }
  switch(uVar3) {
  case 1:
switchD_006368dc_caseD_1:
    *(undefined1 *)puVar4 = *(undefined1 *)_Src;
    return _Dst;
  case 2:
switchD_006368dc_caseD_2:
    *(undefined1 *)puVar4 = *(undefined1 *)_Src;
    *(undefined1 *)((int)puVar4 + 1) = *(undefined1 *)((int)_Src + 1);
    return _Dst;
  case 3:
switchD_006368dc_caseD_3:
    *(undefined1 *)puVar4 = *(undefined1 *)_Src;
    *(undefined1 *)((int)puVar4 + 1) = *(undefined1 *)((int)_Src + 1);
    *(undefined1 *)((int)puVar4 + 2) = *(undefined1 *)((int)_Src + 2);
    return _Dst;
  }
switchD_006368dc_caseD_0:
  return _Dst;
}



============================================================
DISASSEMBLY
============================================================
00636880 : PUSH EBP
00636881 : MOV EBP,ESP
00636883 : PUSH EDI
00636884 : PUSH ESI
00636885 : MOV ESI,dword ptr [EBP + 0xc]
00636888 : MOV ECX,dword ptr [EBP + 0x10]
0063688b : MOV EDI,dword ptr [EBP + 0x8]
0063688e : MOV EAX,ECX
00636890 : MOV EDX,ECX
00636892 : ADD EAX,ESI
00636894 : CMP EDI,ESI
00636896 : JBE 0x006368a0
00636898 : CMP EDI,EAX
0063689a : JC 0x00636a44
006368a0 : CMP ECX,0x100
006368a6 : JC 0x006368c7
006368a8 : CMP dword ptr [0x01728c2c],0x0
006368af : JZ 0x006368c7
006368b1 : PUSH EDI
006368b2 : PUSH ESI
006368b3 : AND EDI,0xf
006368b6 : AND ESI,0xf
006368b9 : CMP EDI,ESI
006368bb : POP ESI
006368bc : POP EDI
006368bd : JNZ 0x006368c7
006368bf : POP ESI
006368c0 : POP EDI
006368c1 : POP EBP
006368c2 : JMP 0x0065032b
006368c7 : TEST EDI,0x3
006368cd : JNZ 0x006368e4
006368cf : SHR ECX,0x2
006368d2 : AND EDX,0x3
006368d5 : CMP ECX,0x8
006368d8 : JC 0x00636904
006368da : MOVSD.REP ES:EDI,ESI
006368dc : JMP dword ptr [EDX*0x4 + 0x6369f4]
006368e4 : MOV EAX,EDI
006368e6 : MOV EDX,0x3
006368eb : SUB ECX,0x4
006368ee : JC 0x006368fc
006368f0 : AND EAX,0x3
006368f3 : ADD ECX,EAX
006368f5 : JMP dword ptr [EAX*0x4 + 0x636908]
006368fc : JMP dword ptr [ECX*0x4 + 0x636a04]
00636904 : JMP dword ptr [ECX*0x4 + 0x636988]
00636918 : AND EDX,ECX
0063691a : MOV AL,byte ptr [ESI]
0063691c : MOV byte ptr [EDI],AL
0063691e : MOV AL,byte ptr [ESI + 0x1]
00636921 : MOV byte ptr [EDI + 0x1],AL
00636924 : MOV AL,byte ptr [ESI + 0x2]
00636927 : SHR ECX,0x2
0063692a : MOV byte ptr [EDI + 0x2],AL
0063692d : ADD ESI,0x3
00636930 : ADD EDI,0x3
00636933 : CMP ECX,0x8
00636936 : JC 0x00636904
00636938 : MOVSD.REP ES:EDI,ESI
0063693a : JMP dword ptr [EDX*0x4 + 0x6369f4]
00636944 : AND EDX,ECX
00636946 : MOV AL,byte ptr [ESI]
00636948 : MOV byte ptr [EDI],AL
0063694a : MOV AL,byte ptr [ESI + 0x1]
0063694d : SHR ECX,0x2
00636950 : MOV byte ptr [EDI + 0x1],AL
00636953 : ADD ESI,0x2
00636956 : ADD EDI,0x2
00636959 : CMP ECX,0x8
0063695c : JC 0x00636904
0063695e : MOVSD.REP ES:EDI,ESI
00636960 : JMP dword ptr [EDX*0x4 + 0x6369f4]
00636968 : AND EDX,ECX
0063696a : MOV AL,byte ptr [ESI]
0063696c : MOV byte ptr [EDI],AL
0063696e : ADD ESI,0x1
00636971 : SHR ECX,0x2
00636974 : ADD EDI,0x1
00636977 : CMP ECX,0x8
0063697a : JC 0x00636904
0063697c : MOVSD.REP ES:EDI,ESI
0063697e : JMP dword ptr [EDX*0x4 + 0x6369f4]
006369a8 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x1c]
006369ac : MOV dword ptr [EDI + ECX*0x4 + -0x1c],EAX
006369b0 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x18]
006369b4 : MOV dword ptr [EDI + ECX*0x4 + -0x18],EAX
006369b8 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x14]
006369bc : MOV dword ptr [EDI + ECX*0x4 + -0x14],EAX
006369c0 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x10]
006369c4 : MOV dword ptr [EDI + ECX*0x4 + -0x10],EAX
006369c8 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0xc]
006369cc : MOV dword ptr [EDI + ECX*0x4 + -0xc],EAX
006369d0 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x8]
006369d4 : MOV dword ptr [EDI + ECX*0x4 + -0x8],EAX
006369d8 : MOV EAX,dword ptr [ESI + ECX*0x4 + -0x4]
006369dc : MOV dword ptr [EDI + ECX*0x4 + -0x4],EAX
006369e0 : LEA EAX,[ECX*0x4 + 0x0]
006369e7 : ADD ESI,EAX
006369e9 : ADD EDI,EAX
006369eb : JMP dword ptr [EDX*0x4 + 0x6369f4]
00636a04 : MOV EAX,dword ptr [EBP + 0x8]
00636a07 : POP ESI
00636a08 : POP EDI
00636a09 : LEAVE
00636a0a : RET
00636a0c : MOV AL,byte ptr [ESI]
00636a0e : MOV byte ptr [EDI],AL
00636a10 : MOV EAX,dword ptr [EBP + 0x8]
00636a13 : POP ESI
00636a14 : POP EDI
00636a15 : LEAVE
00636a16 : RET
00636a18 : MOV AL,byte ptr [ESI]
00636a1a : MOV byte ptr [EDI],AL
00636a1c : MOV AL,byte ptr [ESI + 0x1]
00636a1f : MOV byte ptr [EDI + 0x1],AL
00636a22 : MOV EAX,dword ptr [EBP + 0x8]
00636a25 : POP ESI
00636a26 : POP EDI
00636a27 : LEAVE
00636a28 : RET
00636a2c : MOV AL,byte ptr [ESI]
00636a2e : MOV byte ptr [EDI],AL
00636a30 : MOV AL,byte ptr [ESI + 0x1]
00636a33 : MOV byte ptr [EDI + 0x1],AL
00636a36 : MOV AL,byte ptr [ESI + 0x2]
00636a39 : MOV byte ptr [EDI + 0x2],AL
00636a3c : MOV EAX,dword ptr [EBP + 0x8]
00636a3f : POP ESI
00636a40 : POP EDI
00636a41 : LEAVE
00636a42 : RET
00636a44 : LEA ESI,[ECX + ESI*0x1 + -0x4]
00636a48 : LEA EDI,[ECX + EDI*0x1 + -0x4]
00636a4c : TEST EDI,0x3
00636a52 : JNZ 0x00636a78
00636a54 : SHR ECX,0x2
00636a57 : AND EDX,0x3
00636a5a : CMP ECX,0x8
00636a5d : JC 0x00636a6c
00636a5f : STD
00636a60 : MOVSD.REP ES:EDI,ESI
00636a62 : CLD
00636a63 : JMP dword ptr [EDX*0x4 + 0x636b90]
00636a6c : NEG ECX
00636a6e : JMP dword ptr [ECX*0x4 + 0x636b40]
00636a78 : MOV EAX,EDI
00636a7a : MOV EDX,0x3
00636a7f : CMP ECX,0x4
00636a82 : JC 0x00636a90
00636a84 : AND EAX,0x3
00636a87 : SUB ECX,EAX
00636a89 : JMP dword ptr [EAX*0x4 + 0x636a94]
00636a90 : JMP dword ptr [ECX*0x4 + 0x636b90]
00636aa4 : MOV AL,byte ptr [ESI + 0x3]
00636aa7 : AND EDX,ECX
00636aa9 : MOV byte ptr [EDI + 0x3],AL
00636aac : SUB ESI,0x1
00636aaf : SHR ECX,0x2
00636ab2 : SUB EDI,0x1
00636ab5 : CMP ECX,0x8
00636ab8 : JC 0x00636a6c
00636aba : STD
00636abb : MOVSD.REP ES:EDI,ESI
00636abd : CLD
00636abe : JMP dword ptr [EDX*0x4 + 0x636b90]
00636ac8 : MOV AL,byte ptr [ESI + 0x3]
00636acb : AND EDX,ECX
00636acd : MOV byte ptr [EDI + 0x3],AL
00636ad0 : MOV AL,byte ptr [ESI + 0x2]
00636ad3 : SHR ECX,0x2
00636ad6 : MOV byte ptr [EDI + 0x2],AL
00636ad9 : SUB ESI,0x2
00636adc : SUB EDI,0x2
00636adf : CMP ECX,0x8
00636ae2 : JC 0x00636a6c
00636ae4 : STD
00636ae5 : MOVSD.REP ES:EDI,ESI
00636ae7 : CLD
00636ae8 : JMP dword ptr [EDX*0x4 + 0x636b90]
00636af0 : MOV AL,byte ptr [ESI + 0x3]
00636af3 : AND EDX,ECX
00636af5 : MOV byte ptr [EDI + 0x3],AL
00636af8 : MOV AL,byte ptr [ESI + 0x2]
00636afb : MOV byte ptr [EDI + 0x2],AL
00636afe : MOV AL,byte ptr [ESI + 0x1]
00636b01 : SHR ECX,0x2
00636b04 : MOV byte ptr [EDI + 0x1],AL
00636b07 : SUB ESI,0x3
00636b0a : SUB EDI,0x3
00636b0d : CMP ECX,0x8
00636b10 : JC 0x00636a6c
00636b16 : STD
00636b17 : MOVSD.REP ES:EDI,ESI
00636b19 : CLD
00636b1a : JMP dword ptr [EDX*0x4 + 0x636b90]
00636b44 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x1c]
00636b48 : MOV dword ptr [EDI + ECX*0x4 + 0x1c],EAX
00636b4c : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x18]
00636b50 : MOV dword ptr [EDI + ECX*0x4 + 0x18],EAX
00636b54 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x14]
00636b58 : MOV dword ptr [EDI + ECX*0x4 + 0x14],EAX
00636b5c : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x10]
00636b60 : MOV dword ptr [EDI + ECX*0x4 + 0x10],EAX
00636b64 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0xc]
00636b68 : MOV dword ptr [EDI + ECX*0x4 + 0xc],EAX
00636b6c : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x8]
00636b70 : MOV dword ptr [EDI + ECX*0x4 + 0x8],EAX
00636b74 : MOV EAX,dword ptr [ESI + ECX*0x4 + 0x4]
00636b78 : MOV dword ptr [EDI + ECX*0x4 + 0x4],EAX
00636b7c : LEA EAX,[ECX*0x4 + 0x0]
00636b83 : ADD ESI,EAX
00636b85 : ADD EDI,EAX
00636b87 : JMP dword ptr [EDX*0x4 + 0x636b90]
00636ba0 : MOV EAX,dword ptr [EBP + 0x8]
00636ba3 : POP ESI
00636ba4 : POP EDI
00636ba5 : LEAVE
00636ba6 : RET
00636ba8 : MOV AL,byte ptr [ESI + 0x3]
00636bab : MOV byte ptr [EDI + 0x3],AL
00636bae : MOV EAX,dword ptr [EBP + 0x8]
00636bb1 : POP ESI
00636bb2 : POP EDI
00636bb3 : LEAVE
00636bb4 : RET
00636bb8 : MOV AL,byte ptr [ESI + 0x3]
00636bbb : MOV byte ptr [EDI + 0x3],AL
00636bbe : MOV AL,byte ptr [ESI + 0x2]
00636bc1 : MOV byte ptr [EDI + 0x2],AL
00636bc4 : MOV EAX,dword ptr [EBP + 0x8]
00636bc7 : POP ESI
00636bc8 : POP EDI
00636bc9 : LEAVE
00636bca : RET
00636bcc : MOV AL,byte ptr [ESI + 0x3]
00636bcf : MOV byte ptr [EDI + 0x3],AL
00636bd2 : MOV AL,byte ptr [ESI + 0x2]
00636bd5 : MOV byte ptr [EDI + 0x2],AL
00636bd8 : MOV AL,byte ptr [ESI + 0x1]
00636bdb : MOV byte ptr [EDI + 0x1],AL
00636bde : MOV EAX,dword ptr [EBP + 0x8]
00636be1 : POP ESI
00636be2 : POP EDI
00636be3 : LEAVE
00636be4 : RET
