PROGRAM  : Maestia.exe
FUNCTION : FUN_00566cb0
ENTRY    : 00566cb0
BODY     : [[00566cb0, 00567631]]

============================================================
DECOMPILED C CODE
============================================================

uint FUN_00566cb0(void)

{
  int iVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  int iVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  char cVar7;
  uint uVar8;
  int iVar9;
  GRefCountImpl *pGVar10;
  int iVar11;
  undefined4 uVar12;
  LONG LVar13;
  int in_ECX;
  uint uVar14;
  uint uVar15;
  undefined4 uVar16;
  int iVar17;
  uint *puVar18;
  int *piVar19;
  GMutex *pGVar20;
  bool bVar21;
  int local_70;
  int iStack_6c;
  uint local_68;
  int *local_58;
  int iStack_54;
  int iStack_50;
  int iStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  int iStack_40;
  uint uStack_3c;
  uint uStack_38;
  undefined1 auStack_34 [12];
  undefined4 auStack_28 [2];
  uint uStack_20;
  undefined1 auStack_1c [4];
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  
  if (*(int *)(in_ECX + 0x20) == 0) {
    return 3;
  }
  uVar8 = *(uint *)(*(int *)(in_ECX + 0x20) + 0x74) & 0xf;
  if (uVar8 != 1) {
    if (uVar8 != 0) {
      return uVar8;
    }
    FUN_00562150(*(uint *)(*(int *)(in_ECX + 0x20) + 0x74) & 0xfffffff1 | 1);
  }
  if (*(int *)(in_ECX + 0x14) == 0) {
    local_70 = *(int *)(*(int *)(*(int *)(in_ECX + 0x24) + 0x20) + 0x88);
  }
  else {
    local_70 = *(int *)(*(int *)(in_ECX + 0x14) + 0x20);
  }
  if (local_70 == 0) {
    iVar1 = *(int *)(*(int *)(in_ECX + 0x24) + 0x20);
    pGVar20 = (GMutex *)(*(int *)(iVar1 + 0x84) + 8);
    GMutex::Lock(pGVar20);
    if (*(int *)(in_ECX + 0x14) == 0) {
      local_70 = *(int *)(*(int *)(*(int *)(in_ECX + 0x24) + 0x20) + 0x88);
    }
    else {
      local_70 = *(int *)(*(int *)(in_ECX + 0x14) + 0x20);
    }
    while (((local_70 == 0 && (*(int *)(iVar1 + 0x74) == 1)) &&
           (*(char *)(*(int *)(in_ECX + 0x20) + 0x84) == '\0'))) {
      GWaitCondition::Wait
                ((GWaitCondition *)(*(int *)(iVar1 + 0x84) + 0x1c),
                 (GMutex *)(*(int *)(iVar1 + 0x84) + 8),0xffffffff);
      if (*(int *)(in_ECX + 0x14) == 0) {
        local_70 = *(int *)(*(int *)(*(int *)(in_ECX + 0x24) + 0x20) + 0x88);
      }
      else {
        local_70 = *(int *)(*(int *)(in_ECX + 0x14) + 0x20);
      }
    }
    if (*(int *)(iVar1 + 0x74) == 3) {
      *(undefined1 *)(*(int *)(in_ECX + 0x20) + 0x84) = 1;
    }
    GMutex::Unlock(pGVar20);
    if (local_70 == 0) goto LAB_0056757a;
  }
  if (*(char *)(*(int *)(in_ECX + 0x20) + 0x84) == '\0') {
    iVar1 = *(int *)(in_ECX + 0x10);
    *(int *)(in_ECX + 0x14) = local_70;
    uVar8 = *(uint *)(*(int *)(in_ECX + 0x20) + 0x14);
    if ((uVar8 & 0x100000) == 0) {
      iVar17 = *(int *)(local_70 + 0x14);
      local_68 = 0;
      if (*(int *)(local_70 + 0xc) != 0) {
        do {
          puVar18 = (uint *)(iVar17 + 0xc);
          uVar14 = *(uint *)(*(uint *)(iVar17 + 0xc) & 0xfffffffc) & 0x7fffffff;
          if ((uVar14 < 0xe) ||
             (iVar9 = FUN_0051b280(((*(uint *)(iVar17 + 0xc) & 0xfffffffc) - 6) + uVar14,
                                   "gfxfontlib.swf"), iVar9 != 0)) {
LAB_00566e7e:
            pGVar10 = (GRefCountImpl *)FUN_005a1ea0();
            uStack_48 = *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x10);
            iVar9 = *(int *)(in_ECX + 0x2c);
            uVar14 = uVar8 | 1;
            uStack_44 = 0;
            if (iVar9 == 0) {
              *(undefined4 **)(in_ECX + 0x2c) = &uStack_48;
            }
            else {
              iVar4 = *(int *)(iVar9 + 4);
              while (iVar4 != 0) {
                iVar9 = *(int *)(iVar9 + 4);
                iVar4 = *(int *)(iVar9 + 4);
              }
              *(undefined4 **)(iVar9 + 4) = &uStack_48;
            }
            if (*(char *)(in_ECX + 0x28) == '\0') {
LAB_00566f9b:
              auStack_28[0] = 1;
              FUN_0051c600(puVar18);
              FUN_0051c600(iVar1 + 0x40);
              iVar9 = FUN_00514460(pGVar10,auStack_28,uVar14,*(undefined4 *)(in_ECX + 0x2c),0);
              FUN_00512c60();
            }
            else {
              uVar15 = *(uint *)(*puVar18 & 0xfffffffc) & 0x7fffffff;
              if ((uVar15 < 5) ||
                 (iVar9 = FUN_0051b280((*puVar18 & 0xfffffffc) + 4 + uVar15,&DAT_00b8cc9c),
                 iVar9 != 0)) goto LAB_00566f9b;
              FUN_00561320(1,puVar18,iVar1 + 0x40);
              FUN_0051bf30();
              FUN_0051b950((uint *)(*puVar18 & 0xfffffffc) + 2,
                           (*(uint *)(*puVar18 & 0xfffffffc) & 0x7fffffff) - 4);
              FUN_0051b950(&DAT_00b8cc94,0xffffffff);
              iVar9 = FUN_00514460(pGVar10,auStack_34,uVar14,*(undefined4 *)(in_ECX + 0x2c),0);
              FUN_00512c60();
              if (iVar9 == 0) goto LAB_00566f9b;
            }
            puVar2 = *(undefined4 **)(in_ECX + 0x2c);
            if (puVar2 == &uStack_48) {
              *(undefined4 *)(in_ECX + 0x2c) = 0;
            }
            else {
              iVar4 = puVar2[1];
              while (iVar4 != 0) {
                puVar3 = (undefined4 *)puVar2[1];
                if (puVar3 == &uStack_48) {
                  puVar2[1] = puVar3[1];
                  break;
                }
                puVar2 = puVar3;
                iVar4 = puVar3[1];
              }
            }
            if (iVar9 == 0) {
              FUN_00561960();
              FUN_00562150(*(uint *)(*(int *)(in_ECX + 0x20) + 0x74) & 0xfffffff4 | 4);
              if (pGVar10 != (GRefCountImpl *)0x0) {
                GRefCountImpl::Release(pGVar10);
              }
              return 4;
            }
            bVar21 = *(int *)(iVar9 + 0x1c) == *(int *)(in_ECX + 0x20);
            if ((bVar21) && (*(int *)(iVar1 + 0xc) != 0)) {
              FUN_0050a9f0(*(int *)(iVar1 + 0xc) + 0xc,
                           "Warning: Self recursive import detected in \'%s\'\n",
                           (*puVar18 & 0xfffffffc) + 8);
            }
            FUN_00566210(iVar17,iVar9,iVar1,bVar21);
            iVar4 = *(int *)(*(int *)(iVar1 + 8) + 0x14);
            if ((iVar4 != 0) && (iVar11 = FUN_00561220(), iVar11 != 0)) {
              (**(code **)(*(int *)(iVar4 + 0xc) + 4))(iVar11,iVar9,(*puVar18 & 0xfffffffc) + 8);
              FUN_00524240();
            }
            FUN_00524240();
            if (pGVar10 != (GRefCountImpl *)0x0) {
              GRefCountImpl::Release(pGVar10);
            }
          }
          else {
            iVar9 = FUN_00561220();
            if (iVar9 != 0) {
              pGVar10 = (GRefCountImpl *)(**(code **)(*(int *)(iVar9 + 0xc) + 0xc))(0x13);
              if ((pGVar10 == (GRefCountImpl *)0x0) &&
                 ((*(int *)(iVar17 + 4) == 0 ||
                  (cVar7 = FUN_004ffbc0("$IMECandidateListFont"), cVar7 == '\0')))) {
                FUN_00524240();
                goto LAB_00566e7e;
              }
              FUN_00566560(iVar17);
              if (pGVar10 != (GRefCountImpl *)0x0) {
                GRefCountImpl::Release(pGVar10);
              }
              FUN_00524240();
            }
          }
          iVar17 = *(int *)(iVar17 + 0x18);
          local_68 = local_68 + 1;
        } while (local_68 < *(uint *)(local_70 + 0xc));
      }
    }
    iVar17 = *(int *)(in_ECX + 0x20);
    piVar19 = *(int **)(local_70 + 0x1c);
    uVar5 = *(undefined4 *)(iVar17 + 8);
    local_68 = 0;
    if (*(int *)(local_70 + 0x10) != 0) {
      do {
        if ((int *)*piVar19 != (int *)0x0) {
          local_58 = (int *)0x0;
          iStack_54 = iVar17 + 0x18;
          cVar7 = (**(code **)(*(int *)*piVar19 + 0xc))(piVar19[1],&local_58,iVar1,uVar5);
          if (cVar7 == '\0') {
            if (*(char *)(*(int *)(in_ECX + 0x20) + 0x84) != '\0') {
              if (*(int **)(in_ECX + 0x1c) != (int *)0x0) {
                (**(code **)(**(int **)(in_ECX + 0x1c) + 0xc))();
              }
              *(undefined1 *)(*(int *)(in_ECX + 0x20) + 0x3c) = 1;
              FUN_00562150(*(uint *)(*(int *)(in_ECX + 0x20) + 0x74) & 0xfffffff3 | 3);
              pGVar10 = *(GRefCountImpl **)(*(int *)(in_ECX + 0x20) + 0x78);
              if (pGVar10 != (GRefCountImpl *)0x0) {
                GRefCountImpl::AddRef(pGVar10);
              }
              if (*(GRefCountImpl **)(in_ECX + 0x20) != (GRefCountImpl *)0x0) {
                GRefCountImpl::Release(*(GRefCountImpl **)(in_ECX + 0x20));
              }
              *(undefined4 *)(in_ECX + 0x20) = 0;
              GMutex::Lock((GMutex *)(pGVar10 + 8));
              pGVar10[0x20] = (GRefCountImpl)0x1;
              GWaitCondition::NotifyAll((GWaitCondition *)(pGVar10 + 0x1c));
              GMutex::Unlock((GMutex *)(pGVar10 + 8));
              GRefCountImpl::Release(pGVar10);
              if (local_58 == (int *)0x0) {
                return 3;
              }
              FUN_00524240();
              return 3;
            }
          }
          else if ((((*(int *)(in_ECX + 0x1c) != 0) &&
                    (uVar8 = (**(code **)(*local_58 + 8))(), (uVar8 & 0xff00) == 0x100)) &&
                   (iVar9 = FUN_00562fc0(piVar19 + 2), iVar9 == 0)) &&
                  (cVar7 = (**(code **)(*local_58 + 8))(), cVar7 == '\x01')) {
            (**(code **)(**(int **)(in_ECX + 0x1c) + 8))(piVar19,local_58[3]);
          }
          FUN_0056a050(piVar19[2],&local_58);
          if (local_58 != (int *)0x0) {
            FUN_00524240();
          }
        }
        piVar19 = (int *)piVar19[3];
        local_68 = local_68 + 1;
      } while (local_68 < *(uint *)(local_70 + 0x10));
    }
    if (*(int *)(local_70 + 8) != 0) {
      iStack_6c = *(int *)(local_70 + 0x18);
      iStack_40 = 0;
      uStack_3c = 0;
      uStack_38 = 0;
      local_68 = 0;
      if (*(int *)(local_70 + 8) != 0) {
        do {
          uVar8 = *(uint *)(iStack_6c + 8);
          iStack_50 = 0;
          iStack_4c = 0;
          if ((*(char *)(iVar17 + 0x3c) == '\0') || (*(uint *)(iVar17 + 0x1c) <= uVar8)) {
            FUN_00569f80(&iStack_50,uVar8);
          }
          else {
            piVar19 = (int *)(*(int *)(iVar17 + 0x20) + uVar8 * 8);
            if (((GRefCountImpl *)*piVar19 != (GRefCountImpl *)0x0) &&
               (GRefCountImpl::AddRef((GRefCountImpl *)*piVar19), iStack_50 != 0)) {
              FUN_00524240();
            }
            iStack_50 = *piVar19;
            iStack_4c = piVar19[1];
          }
          iVar9 = iStack_50;
          if (iStack_50 != 0) {
            uVar8 = uStack_3c + 1;
            if (uVar8 < uStack_3c) {
              uVar14 = uVar8;
              if (uVar8 < uStack_38 >> 1) {
LAB_0056736b:
                FUN_0057c3a0(&iStack_40,uVar14);
              }
            }
            else if (uStack_38 <= uVar8) {
              uVar14 = (uVar8 >> 2) + uVar8;
              goto LAB_0056736b;
            }
            piVar19 = (int *)(iStack_40 + -4 + uVar8 * 4);
            if (piVar19 != (int *)0x0) {
              *piVar19 = iVar9;
            }
            uStack_3c = uVar8;
            if (iStack_50 != 0) {
              FUN_00524240();
            }
          }
          iStack_6c = *(int *)(iStack_6c + 0xc);
          local_68 = local_68 + 1;
        } while (local_68 < *(uint *)(local_70 + 8));
        if ((uStack_3c != 0) && (*(int *)(*(int *)(iVar1 + 8) + 0x1c) != 0)) {
          if ((*(char *)(iVar1 + 0x44) == '\0') && (*(int *)(iVar1 + 0x18) == 0)) {
            uVar16 = 0;
          }
          else {
            uVar16 = 1;
          }
          FUN_005ebf20(*(undefined4 *)(*(int *)(iVar1 + 8) + 0x1c),&iStack_40,
                       *(undefined4 *)(*(int *)(iVar1 + 8) + 0x10),*(undefined4 *)(iVar1 + 0x20),
                       *(undefined4 *)(iVar1 + 0xc),in_ECX + 0x18,uVar5,uVar16);
        }
      }
      FUN_00515cf0(iStack_40);
    }
    *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x80) = *(undefined4 *)(local_70 + 4);
    InterlockedExchange((LONG *)(*(int *)(in_ECX + 0x20) + 0x7c),
                        *(int *)(*(int *)(in_ECX + 0x20) + 0x7c) + 1);
    if (*(int *)(*(int *)(in_ECX + 0x20) + 0x7c) == 1) {
      uVar8 = *(uint *)(*(int *)(in_ECX + 0x20) + 0x74);
      iVar17 = *(int *)(in_ECX + 0x20);
      if (iVar17 != 0) {
        pGVar20 = (GMutex *)(*(int *)(iVar17 + 0x78) + 8);
        GMutex::Lock(pGVar20);
        *(uint *)(iVar17 + 0x74) = uVar8 | 0x100;
        GWaitCondition::NotifyAll((GWaitCondition *)(*(int *)(iVar17 + 0x78) + 0x1c));
        GMutex::Unlock(pGVar20);
      }
    }
    iVar17 = *(int *)(in_ECX + 0x20);
    iVar9 = (**(code **)(**(int **)(in_ECX + 0x24) + 0x28))();
    if (*(int *)(iVar17 + 0x7c) == iVar9) {
      *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x80) =
           *(undefined4 *)(*(int *)(*(int *)(in_ECX + 0x24) + 0x20) + 0x28);
      if (*(int **)(in_ECX + 0x1c) != (int *)0x0) {
        (**(code **)(**(int **)(in_ECX + 0x1c) + 0xc))();
      }
      *(undefined1 *)(*(int *)(in_ECX + 0x20) + 0x3c) = 1;
      uVar8 = *(uint *)(*(int *)(in_ECX + 0x20) + 0x74);
      iVar17 = *(int *)(in_ECX + 0x20);
      if (iVar17 != 0) {
        pGVar20 = (GMutex *)(*(int *)(iVar17 + 0x78) + 8);
        GMutex::Lock(pGVar20);
        *(uint *)(iVar17 + 0x74) = uVar8 & 0xfffffff2 | 0x202;
        GWaitCondition::NotifyAll((GWaitCondition *)(*(int *)(iVar17 + 0x78) + 0x1c));
        GMutex::Unlock(pGVar20);
      }
    }
    piVar19 = *(int **)(iVar1 + 0x14);
    if (piVar19 != (int *)0x0) {
      iVar1 = *(int *)(in_ECX + 0x20);
      iVar17 = (*(int **)(iVar1 + 0xc))[8];
      uVar5 = *(undefined4 *)(iVar17 + 0x28);
      uVar12 = (**(code **)(**(int **)(iVar1 + 0xc) + 0x28))();
      uVar16 = *(undefined4 *)(iVar1 + 0x7c);
      uVar6 = *(undefined4 *)(iVar1 + 0x80);
      FUN_0051c600(iVar17 + 0x24);
      uStack_18 = uVar6;
      uStack_14 = uVar5;
      uStack_10 = uVar16;
      uStack_c = uVar12;
      (**(code **)(*piVar19 + 4))(auStack_1c);
      LVar13 = InterlockedExchangeAdd((LONG *)((uStack_20 & 0xfffffffc) + 4),-1);
      if (LVar13 == 1) {
        FUN_00515cf0(uStack_20 & 0xfffffffc);
      }
    }
    return *(uint *)(*(int *)(in_ECX + 0x20) + 0x74) & 0xf;
  }
LAB_0056757a:
  if (*(int **)(in_ECX + 0x1c) != (int *)0x0) {
    (**(code **)(**(int **)(in_ECX + 0x1c) + 0xc))();
  }
  *(undefined1 *)(*(int *)(in_ECX + 0x20) + 0x3c) = 1;
  uVar14 = (*(char *)(*(int *)(in_ECX + 0x20) + 0x84) == '\0') + 3;
  uVar8 = *(uint *)(*(int *)(in_ECX + 0x20) + 0x74);
  iVar1 = *(int *)(in_ECX + 0x20);
  if (iVar1 != 0) {
    pGVar20 = (GMutex *)(*(int *)(iVar1 + 0x78) + 8);
    GMutex::Lock(pGVar20);
    *(uint *)(iVar1 + 0x74) = uVar8 & 0xfffffff0 | uVar14;
    GWaitCondition::NotifyAll((GWaitCondition *)(*(int *)(iVar1 + 0x78) + 0x1c));
    GMutex::Unlock(pGVar20);
  }
  pGVar10 = *(GRefCountImpl **)(*(int *)(in_ECX + 0x20) + 0x78);
  if (pGVar10 != (GRefCountImpl *)0x0) {
    GRefCountImpl::AddRef(pGVar10);
  }
  if (*(GRefCountImpl **)(in_ECX + 0x20) != (GRefCountImpl *)0x0) {
    GRefCountImpl::Release(*(GRefCountImpl **)(in_ECX + 0x20));
  }
  *(undefined4 *)(in_ECX + 0x20) = 0;
  GMutex::Lock((GMutex *)(pGVar10 + 8));
  pGVar10[0x20] = (GRefCountImpl)0x1;
  GWaitCondition::NotifyAll((GWaitCondition *)(pGVar10 + 0x1c));
  GMutex::Unlock((GMutex *)(pGVar10 + 8));
  GRefCountImpl::Release(pGVar10);
  return uVar14;
}



============================================================
DISASSEMBLY
============================================================
00566cb0 : PUSH EBP
00566cb1 : MOV EBP,ESP
00566cb3 : AND ESP,0xfffffff8
00566cb6 : SUB ESP,0x70
00566cb9 : PUSH EBX
00566cba : PUSH EBP
00566cbb : PUSH ESI
00566cbc : MOV ESI,ECX
00566cbe : MOV EAX,dword ptr [ESI + 0x20]
00566cc1 : PUSH EDI
00566cc2 : TEST EAX,EAX
00566cc4 : JZ 0x00567319
00566cca : MOV EAX,dword ptr [EAX + 0x74]
00566ccd : AND EAX,0xf
00566cd0 : CMP EAX,0x1
00566cd3 : JZ 0x00566cef
00566cd5 : TEST EAX,EAX
00566cd7 : JNZ 0x0056762a
00566cdd : MOV EAX,dword ptr [ESI + 0x20]
00566ce0 : MOV EAX,dword ptr [EAX + 0x74]
00566ce3 : AND EAX,0xfffffff1
00566ce6 : OR EAX,0x1
00566ce9 : PUSH EAX
00566cea : CALL 0x00562150
00566cef : MOV EAX,dword ptr [ESI + 0x14]
00566cf2 : TEST EAX,EAX
00566cf4 : JZ 0x00566cfb
00566cf6 : MOV EDI,dword ptr [EAX + 0x20]
00566cf9 : JMP 0x00566d0c
00566cfb : MOV ECX,dword ptr [ESI + 0x24]
00566cfe : MOV EAX,dword ptr [ECX + 0x20]
00566d01 : MOV EDI,dword ptr [EAX + 0x88]
00566d07 : ADD EAX,0x88
00566d0c : MOV dword ptr [ESP + 0x18],EDI
00566d10 : TEST EDI,EDI
00566d12 : JNZ 0x00566dbe
00566d18 : MOV EDX,dword ptr [ESI + 0x24]
00566d1b : MOV EBX,dword ptr [EDX + 0x20]
00566d1e : MOV EBP,dword ptr [EBX + 0x84]
00566d24 : ADD EBP,0x8
00566d27 : MOV ECX,EBP
00566d29 : CALL 0x005162b0
00566d2e : MOV EAX,dword ptr [ESI + 0x14]
00566d31 : TEST EAX,EAX
00566d33 : JZ 0x00566d3a
00566d35 : MOV EDI,dword ptr [EAX + 0x20]
00566d38 : JMP 0x00566d4b
00566d3a : MOV EAX,dword ptr [ESI + 0x24]
00566d3d : MOV EAX,dword ptr [EAX + 0x20]
00566d40 : MOV EDI,dword ptr [EAX + 0x88]
00566d46 : ADD EAX,0x88
00566d4b : MOV dword ptr [ESP + 0x18],EDI
00566d4f : TEST EDI,EDI
00566d51 : JNZ 0x00566d9f
00566d53 : CMP dword ptr [EBX + 0x74],0x1
00566d57 : JNZ 0x00566d9b
00566d59 : MOV EAX,dword ptr [ESI + 0x20]
00566d5c : MOV CL,byte ptr [EAX + 0x84]
00566d62 : TEST CL,CL
00566d64 : JNZ 0x00566d9b
00566d66 : MOV EAX,dword ptr [EBX + 0x84]
00566d6c : PUSH -0x1
00566d6e : LEA EDX,[EAX + 0x8]
00566d71 : PUSH EDX
00566d72 : LEA ECX,[EAX + 0x1c]
00566d75 : CALL 0x00516820
00566d7a : MOV EAX,dword ptr [ESI + 0x14]
00566d7d : TEST EAX,EAX
00566d7f : JZ 0x00566d86
00566d81 : MOV EDI,dword ptr [EAX + 0x20]
00566d84 : JMP 0x00566d97
00566d86 : MOV EAX,dword ptr [ESI + 0x24]
00566d89 : MOV EAX,dword ptr [EAX + 0x20]
00566d8c : MOV EDI,dword ptr [EAX + 0x88]
00566d92 : ADD EAX,0x88
00566d97 : TEST EDI,EDI
00566d99 : JZ 0x00566d53
00566d9b : MOV dword ptr [ESP + 0x18],EDI
00566d9f : CMP dword ptr [EBX + 0x74],0x3
00566da3 : JNZ 0x00566daf
00566da5 : MOV ECX,dword ptr [ESI + 0x20]
00566da8 : MOV byte ptr [ECX + 0x84],0x1
00566daf : MOV ECX,EBP
00566db1 : CALL 0x005170a0
00566db6 : TEST EDI,EDI
00566db8 : JZ 0x0056757a
00566dbe : MOV EAX,dword ptr [ESI + 0x20]
00566dc1 : MOV DL,byte ptr [EAX + 0x84]
00566dc7 : TEST DL,DL
00566dc9 : JNZ 0x0056757a
00566dcf : MOV EAX,dword ptr [ESI + 0x10]
00566dd2 : MOV ECX,dword ptr [ESI + 0x20]
00566dd5 : MOV dword ptr [ESI + 0x14],EDI
00566dd8 : MOV dword ptr [ESP + 0x10],EAX
00566ddc : MOV EAX,dword ptr [ECX + 0x14]
00566ddf : MOV dword ptr [ESP + 0x24],EAX
00566de3 : TEST EAX,0x100000
00566de8 : JNZ 0x005670e2
00566dee : CMP dword ptr [EDI + 0xc],0x0
00566df2 : MOV EDX,dword ptr [EDI + 0x14]
00566df5 : MOV dword ptr [ESP + 0x14],EDX
00566df9 : MOV dword ptr [ESP + 0x20],0x0
00566e01 : JBE 0x005670e2
00566e07 : MOV EBX,EDX
00566e09 : MOV EAX,dword ptr [EBX + 0xc]
00566e0c : ADD EBX,0xc
00566e0f : MOV ECX,EAX
00566e11 : AND ECX,0xfffffffc
00566e14 : MOV ECX,dword ptr [ECX]
00566e16 : AND ECX,0x7fffffff
00566e1c : CMP ECX,0xe
00566e1f : JC 0x00566e7e
00566e21 : AND EAX,0xfffffffc
00566e24 : PUSH 0xb8cc50
00566e29 : LEA EDX,[EAX + ECX*0x1 + -0x6]
00566e2d : PUSH EDX
00566e2e : CALL 0x0051b280
00566e33 : TEST EAX,EAX
00566e35 : JNZ 0x00566e7e
00566e37 : MOV ECX,dword ptr [ESI + 0x20]
00566e3a : CALL 0x00561220
00566e3f : MOV EDI,EAX
00566e41 : TEST EDI,EDI
00566e43 : JZ 0x005670c1
00566e49 : MOV EAX,dword ptr [EDI + 0xc]
00566e4c : MOV EDX,dword ptr [EAX + 0xc]
00566e4f : LEA ECX,[EDI + 0xc]
00566e52 : PUSH 0x13
00566e54 : CALL EDX
00566e56 : MOV EBP,EAX
00566e58 : TEST EBP,EBP
00566e5a : JNZ 0x00566eb4
00566e5c : MOV EAX,dword ptr [ESP + 0x14]
00566e60 : CMP dword ptr [EAX + 0x4],EBP
00566e63 : JBE 0x00566e77
00566e65 : MOV ECX,EAX
00566e67 : MOV ECX,dword ptr [ECX]
00566e69 : PUSH 0xb8cca4
00566e6e : CALL 0x004ffbc0
00566e73 : TEST AL,AL
00566e75 : JNZ 0x00566eb4
00566e77 : MOV ECX,EDI
00566e79 : CALL 0x00524240
00566e7e : MOV ECX,dword ptr [ESP + 0x10]
00566e82 : CALL 0x005a1ea0
00566e87 : MOV EBP,dword ptr [ESP + 0x24]
00566e8b : MOV dword ptr [ESP + 0x1c],EAX
00566e8f : MOV EAX,dword ptr [ESI + 0x20]
00566e92 : MOV ECX,dword ptr [EAX + 0x10]
00566e95 : MOV EAX,dword ptr [ESI + 0x2c]
00566e98 : OR EBP,0x1
00566e9b : MOV dword ptr [ESP + 0x40],ECX
00566e9f : MOV dword ptr [ESP + 0x44],0x0
00566ea7 : TEST EAX,EAX
00566ea9 : JNZ 0x00566ed8
00566eab : LEA EDX,[ESP + 0x40]
00566eaf : MOV dword ptr [ESI + 0x2c],EDX
00566eb2 : JMP 0x00566ef0
00566eb4 : MOV EDX,dword ptr [ESP + 0x14]
00566eb8 : MOV ECX,dword ptr [ESI + 0x20]
00566ebb : PUSH EDX
00566ebc : CALL 0x00566560
00566ec1 : TEST EBP,EBP
00566ec3 : JZ 0x00566ecc
00566ec5 : MOV ECX,EBP
00566ec7 : CALL 0x004ff7e0
00566ecc : MOV ECX,EDI
00566ece : CALL 0x00524240
00566ed3 : JMP 0x005670c1
00566ed8 : CMP dword ptr [EAX + 0x4],0x0
00566edc : JZ 0x00566ee9
00566ede : MOV EDI,EDI
00566ee0 : MOV EAX,dword ptr [EAX + 0x4]
00566ee3 : CMP dword ptr [EAX + 0x4],0x0
00566ee7 : JNZ 0x00566ee0
00566ee9 : LEA ECX,[ESP + 0x40]
00566eed : MOV dword ptr [EAX + 0x4],ECX
00566ef0 : CMP byte ptr [ESI + 0x28],0x0
00566ef4 : JZ 0x00566f9b
00566efa : MOV EAX,dword ptr [EBX]
00566efc : MOV EDX,EAX
00566efe : AND EDX,0xfffffffc
00566f01 : MOV ECX,dword ptr [EDX]
00566f03 : AND ECX,0x7fffffff
00566f09 : CMP ECX,0x4
00566f0c : JBE 0x00566f9b
00566f12 : AND EAX,0xfffffffc
00566f15 : PUSH 0xb8cc9c
00566f1a : LEA EAX,[EAX + ECX*0x1 + 0x4]
00566f1e : PUSH EAX
00566f1f : CALL 0x0051b280
00566f24 : TEST EAX,EAX
00566f26 : JNZ 0x00566f9b
00566f28 : MOV ECX,dword ptr [ESP + 0x10]
00566f2c : ADD ECX,0x40
00566f2f : PUSH ECX
00566f30 : PUSH EBX
00566f31 : PUSH 0x1
00566f33 : LEA ECX,[ESP + 0x60]
00566f37 : CALL 0x00561320
00566f3c : LEA ECX,[ESP + 0x58]
00566f40 : CALL 0x0051bf30
00566f45 : MOV EAX,dword ptr [EBX]
00566f47 : AND EAX,0xfffffffc
00566f4a : MOV EDX,dword ptr [EAX]
00566f4c : AND EDX,0x7fffffff
00566f52 : SUB EDX,0x4
00566f55 : PUSH EDX
00566f56 : ADD EAX,0x8
00566f59 : PUSH EAX
00566f5a : LEA ECX,[ESP + 0x60]
00566f5e : CALL 0x0051b950
00566f63 : PUSH -0x1
00566f65 : PUSH 0xb8cc94
00566f6a : LEA ECX,[ESP + 0x60]
00566f6e : CALL 0x0051b950
00566f73 : MOV EAX,dword ptr [ESI + 0x2c]
00566f76 : MOV EDX,dword ptr [ESP + 0x1c]
00566f7a : PUSH 0x0
00566f7c : PUSH EAX
00566f7d : PUSH EBP
00566f7e : LEA ECX,[ESP + 0x60]
00566f82 : PUSH ECX
00566f83 : PUSH EDX
00566f84 : CALL 0x00514460
00566f89 : ADD ESP,0x14
00566f8c : LEA ECX,[ESP + 0x54]
00566f90 : MOV EDI,EAX
00566f92 : CALL 0x00512c60
00566f97 : TEST EDI,EDI
00566f99 : JNZ 0x00566fe2
00566f9b : PUSH EBX
00566f9c : LEA ECX,[ESP + 0x68]
00566fa0 : MOV dword ptr [ESP + 0x64],0x1
00566fa8 : CALL 0x0051c600
00566fad : MOV EAX,dword ptr [ESP + 0x10]
00566fb1 : ADD EAX,0x40
00566fb4 : PUSH EAX
00566fb5 : LEA ECX,[ESP + 0x6c]
00566fb9 : CALL 0x0051c600
00566fbe : MOV ECX,dword ptr [ESI + 0x2c]
00566fc1 : MOV EAX,dword ptr [ESP + 0x1c]
00566fc5 : PUSH 0x0
00566fc7 : PUSH ECX
00566fc8 : PUSH EBP
00566fc9 : LEA EDX,[ESP + 0x6c]
00566fcd : PUSH EDX
00566fce : PUSH EAX
00566fcf : CALL 0x00514460
00566fd4 : ADD ESP,0x14
00566fd7 : LEA ECX,[ESP + 0x60]
00566fdb : MOV EDI,EAX
00566fdd : CALL 0x00512c60
00566fe2 : MOV EAX,dword ptr [ESI + 0x2c]
00566fe5 : LEA ECX,[ESP + 0x40]
00566fe9 : CMP EAX,ECX
00566feb : JNZ 0x00566ff6
00566fed : MOV dword ptr [ESI + 0x2c],0x0
00566ff4 : JMP 0x0056701b
00566ff6 : CMP dword ptr [EAX + 0x4],0x0
00566ffa : JZ 0x0056701b
00566ffc : LEA ESP,[ESP]
00567000 : MOV ECX,dword ptr [EAX + 0x4]
00567003 : LEA EDX,[ESP + 0x40]
00567007 : CMP ECX,EDX
00567009 : JZ 0x00567015
0056700b : MOV EAX,ECX
0056700d : CMP dword ptr [EAX + 0x4],0x0
00567011 : JNZ 0x00567000
00567013 : JMP 0x0056701b
00567015 : MOV EDX,dword ptr [ECX + 0x4]
00567018 : MOV dword ptr [EAX + 0x4],EDX
0056701b : TEST EDI,EDI
0056701d : JZ 0x00567195
00567023 : MOV EAX,dword ptr [EDI + 0x1c]
00567026 : CMP EAX,dword ptr [ESI + 0x20]
00567029 : MOV EBP,dword ptr [ESP + 0x10]
0056702d : SETZ AL
00567030 : MOV byte ptr [ESP + 0x28],AL
00567034 : TEST AL,AL
00567036 : JZ 0x00567059
00567038 : MOV EAX,dword ptr [EBP + 0xc]
0056703b : TEST EAX,EAX
0056703d : JZ 0x00567059
0056703f : MOV ECX,dword ptr [EBX]
00567041 : AND ECX,0xfffffffc
00567044 : ADD ECX,0x8
00567047 : PUSH ECX
00567048 : ADD EAX,0xc
0056704b : PUSH 0xb8cc60
00567050 : PUSH EAX
00567051 : CALL 0x0050a9f0
00567056 : ADD ESP,0xc
00567059 : MOV EDX,dword ptr [ESP + 0x28]
0056705d : MOV EAX,dword ptr [ESP + 0x14]
00567061 : MOV ECX,dword ptr [ESI + 0x20]
00567064 : PUSH EDX
00567065 : PUSH EBP
00567066 : PUSH EDI
00567067 : PUSH EAX
00567068 : CALL 0x00566210
0056706d : MOV ECX,dword ptr [EBP + 0x8]
00567070 : MOV EAX,dword ptr [ECX + 0x14]
00567073 : MOV dword ptr [ESP + 0x2c],EAX
00567077 : TEST EAX,EAX
00567079 : JZ 0x005670aa
0056707b : MOV ECX,dword ptr [ESI + 0x20]
0056707e : CALL 0x00561220
00567083 : MOV EBP,EAX
00567085 : TEST EBP,EBP
00567087 : JZ 0x005670aa
00567089 : MOV EAX,dword ptr [EBX]
0056708b : MOV ECX,dword ptr [ESP + 0x2c]
0056708f : MOV EDX,dword ptr [ECX + 0xc]
00567092 : MOV EDX,dword ptr [EDX + 0x4]
00567095 : AND EAX,0xfffffffc
00567098 : ADD EAX,0x8
0056709b : PUSH EAX
0056709c : ADD ECX,0xc
0056709f : PUSH EDI
005670a0 : PUSH EBP
005670a1 : CALL EDX
005670a3 : MOV ECX,EBP
005670a5 : CALL 0x00524240
005670aa : MOV ECX,EDI
005670ac : CALL 0x00524240
005670b1 : CMP dword ptr [ESP + 0x1c],0x0
005670b6 : JZ 0x005670c1
005670b8 : MOV ECX,dword ptr [ESP + 0x1c]
005670bc : CALL 0x004ff7e0
005670c1 : MOV EAX,dword ptr [ESP + 0x20]
005670c5 : MOV ECX,dword ptr [ESP + 0x14]
005670c9 : MOV EBX,dword ptr [ECX + 0x18]
005670cc : MOV EDI,dword ptr [ESP + 0x18]
005670d0 : INC EAX
005670d1 : MOV dword ptr [ESP + 0x20],EAX
005670d5 : MOV dword ptr [ESP + 0x14],EBX
005670d9 : CMP EAX,dword ptr [EDI + 0xc]
005670dc : JC 0x00566e09
005670e2 : CMP dword ptr [EDI + 0x10],0x0
005670e6 : MOV EAX,dword ptr [ESI + 0x20]
005670e9 : MOV EBX,dword ptr [EDI + 0x1c]
005670ec : LEA EBP,[EAX + 0x18]
005670ef : MOV EAX,dword ptr [EAX + 0x8]
005670f2 : MOV dword ptr [ESP + 0x2c],EBP
005670f6 : MOV dword ptr [ESP + 0x18],EAX
005670fa : MOV dword ptr [ESP + 0x20],0x0
00567102 : JBE 0x0056720d
00567108 : MOV ECX,dword ptr [EBX]
0056710a : TEST ECX,ECX
0056710c : JZ 0x005671f8
00567112 : MOV EAX,dword ptr [ESP + 0x18]
00567116 : PUSH EAX
00567117 : MOV EAX,dword ptr [ESP + 0x14]
0056711b : PUSH EAX
0056711c : LEA EAX,[ESP + 0x38]
00567120 : PUSH EAX
00567121 : MOV EAX,dword ptr [EBX + 0x4]
00567124 : MOV dword ptr [ESP + 0x40],EBP
00567128 : MOV dword ptr [ESP + 0x3c],0x0
00567130 : MOV EDX,dword ptr [ECX]
00567132 : MOV EDX,dword ptr [EDX + 0xc]
00567135 : PUSH EAX
00567136 : CALL EDX
00567138 : TEST AL,AL
0056713a : JZ 0x005671ca
00567140 : CMP dword ptr [ESI + 0x1c],0x0
00567144 : JZ 0x005671db
0056714a : MOV ECX,dword ptr [ESP + 0x30]
0056714e : MOV EAX,dword ptr [ECX]
00567150 : MOV EDX,dword ptr [EAX + 0x8]
00567153 : CALL EDX
00567155 : AND EAX,0xff00
0056715a : CMP EAX,0x100
0056715f : JNZ 0x005671db
00567161 : MOV ECX,dword ptr [ESI + 0x30]
00567164 : LEA EAX,[EBX + 0x8]
00567167 : PUSH EAX
00567168 : CALL 0x00562fc0
0056716d : TEST EAX,EAX
0056716f : JNZ 0x005671db
00567171 : MOV ECX,dword ptr [ESP + 0x30]
00567175 : MOV EDX,dword ptr [ECX]
00567177 : MOV EAX,dword ptr [EDX + 0x8]
0056717a : CALL EAX
0056717c : CMP AL,0x1
0056717e : JNZ 0x005671db
00567180 : MOV EAX,dword ptr [ESP + 0x30]
00567184 : MOV ECX,dword ptr [ESI + 0x1c]
00567187 : MOV EAX,dword ptr [EAX + 0xc]
0056718a : MOV EDX,dword ptr [ECX]
0056718c : MOV EDX,dword ptr [EDX + 0x8]
0056718f : PUSH EAX
00567190 : PUSH EBX
00567191 : CALL EDX
00567193 : JMP 0x005671db
00567195 : MOV ECX,ESI
00567197 : CALL 0x00561960
0056719c : MOV EAX,dword ptr [ESI + 0x20]
0056719f : MOV EDX,dword ptr [EAX + 0x74]
005671a2 : AND EDX,0xfffffff4
005671a5 : OR EDX,0x4
005671a8 : PUSH EDX
005671a9 : MOV ECX,ESI
005671ab : CALL 0x00562150
005671b0 : MOV ECX,dword ptr [ESP + 0x1c]
005671b4 : TEST ECX,ECX
005671b6 : JZ 0x005671bd
005671b8 : CALL 0x004ff7e0
005671bd : MOV EAX,0x4
005671c2 : POP EDI
005671c3 : POP ESI
005671c4 : POP EBP
005671c5 : POP EBX
005671c6 : MOV ESP,EBP
005671c8 : POP EBP
005671c9 : RET
005671ca : MOV EAX,dword ptr [ESI + 0x20]
005671cd : MOV DL,byte ptr [EAX + 0x84]
005671d3 : TEST DL,DL
005671d5 : JNZ 0x0056729b
005671db : MOV ECX,dword ptr [EBX + 0x8]
005671de : LEA EAX,[ESP + 0x30]
005671e2 : PUSH EAX
005671e3 : PUSH ECX
005671e4 : MOV ECX,EBP
005671e6 : CALL 0x0056a050
005671eb : MOV ECX,dword ptr [ESP + 0x30]
005671ef : TEST ECX,ECX
005671f1 : JZ 0x005671f8
005671f3 : CALL 0x00524240
005671f8 : MOV EAX,dword ptr [ESP + 0x20]
005671fc : MOV EBX,dword ptr [EBX + 0xc]
005671ff : INC EAX
00567200 : MOV dword ptr [ESP + 0x20],EAX
00567204 : CMP EAX,dword ptr [EDI + 0x10]
00567207 : JC 0x00567108
0056720d : MOV EAX,dword ptr [EDI + 0x8]
00567210 : TEST EAX,EAX
00567212 : JZ 0x0056740f
00567218 : MOV EDX,dword ptr [EDI + 0x18]
0056721b : XOR ECX,ECX
0056721d : MOV dword ptr [ESP + 0x48],ECX
00567221 : MOV dword ptr [ESP + 0x4c],ECX
00567225 : MOV dword ptr [ESP + 0x50],ECX
00567229 : MOV dword ptr [ESP + 0x1c],EDX
0056722d : MOV dword ptr [ESP + 0x20],ECX
00567231 : CMP EAX,ECX
00567233 : JBE 0x00567405
00567239 : LEA ESP,[ESP]
00567240 : MOV ECX,dword ptr [ESP + 0x2c]
00567244 : MOV DL,byte ptr [ECX + 0x24]
00567247 : MOV EAX,dword ptr [ESP + 0x1c]
0056724b : MOV EAX,dword ptr [EAX + 0x8]
0056724e : XOR EBP,EBP
00567250 : MOV dword ptr [ESP + 0x38],EBP
00567254 : MOV dword ptr [ESP + 0x3c],EBP
00567258 : TEST DL,DL
0056725a : JZ 0x00567326
00567260 : MOV EDX,dword ptr [ECX + 0x4]
00567263 : CMP EAX,EDX
00567265 : JNC 0x00567326
0056726b : MOV ECX,dword ptr [ECX + 0x8]
0056726e : LEA EBX,[ECX + EAX*0x8]
00567271 : MOV ECX,dword ptr [EBX]
00567273 : CMP ECX,EBP
00567275 : JZ 0x00567289
00567277 : CALL 0x00523dd0
0056727c : MOV ECX,dword ptr [ESP + 0x38]
00567280 : CMP ECX,EBP
00567282 : JZ 0x00567289
00567284 : CALL 0x00524240
00567289 : MOV EDX,dword ptr [EBX]
0056728b : MOV dword ptr [ESP + 0x38],EDX
0056728f : MOV EAX,dword ptr [EBX + 0x4]
00567292 : MOV dword ptr [ESP + 0x3c],EAX
00567296 : JMP 0x00567331
0056729b : MOV ECX,dword ptr [ESI + 0x1c]
0056729e : TEST ECX,ECX
005672a0 : JZ 0x005672a9
005672a2 : MOV EDX,dword ptr [ECX]
005672a4 : MOV EAX,dword ptr [EDX + 0xc]
005672a7 : CALL EAX
005672a9 : MOV ECX,dword ptr [ESI + 0x20]
005672ac : MOV byte ptr [ECX + 0x3c],0x1
005672b0 : MOV EAX,dword ptr [ESI + 0x20]
005672b3 : MOV EDX,dword ptr [EAX + 0x74]
005672b6 : AND EDX,0xfffffff3
005672b9 : OR EDX,0x3
005672bc : PUSH EDX
005672bd : MOV ECX,ESI
005672bf : CALL 0x00562150
005672c4 : MOV EAX,dword ptr [ESI + 0x20]
005672c7 : MOV EBX,dword ptr [EAX + 0x78]
005672ca : TEST EBX,EBX
005672cc : JZ 0x005672d5
005672ce : MOV ECX,EBX
005672d0 : CALL 0x00523dd0
005672d5 : MOV ECX,dword ptr [ESI + 0x20]
005672d8 : TEST ECX,ECX
005672da : JZ 0x005672e1
005672dc : CALL 0x004ff7e0
005672e1 : MOV dword ptr [ESI + 0x20],0x0
005672e8 : LEA ESI,[EBX + 0x8]
005672eb : MOV ECX,ESI
005672ed : CALL 0x005162b0
005672f2 : LEA ECX,[EBX + 0x1c]
005672f5 : MOV byte ptr [EBX + 0x20],0x1
005672f9 : CALL 0x00516460
005672fe : MOV ECX,ESI
00567300 : CALL 0x005170a0
00567305 : MOV ECX,EBX
00567307 : CALL 0x004ff7e0
0056730c : MOV ECX,dword ptr [ESP + 0x30]
00567310 : TEST ECX,ECX
00567312 : JZ 0x00567319
00567314 : CALL 0x00524240
00567319 : MOV EAX,0x3
0056731e : POP EDI
0056731f : POP ESI
00567320 : POP EBP
00567321 : POP EBX
00567322 : MOV ESP,EBP
00567324 : POP EBP
00567325 : RET
00567326 : PUSH EAX
00567327 : LEA EDX,[ESP + 0x3c]
0056732b : PUSH EDX
0056732c : CALL 0x00569f80
00567331 : MOV EAX,dword ptr [ESP + 0x38]
00567335 : CMP EAX,EBP
00567337 : JZ 0x00567393
00567339 : MOV EBP,EAX
0056733b : MOV EAX,dword ptr [ESP + 0x4c]
0056733f : LEA EBX,[EAX + 0x1]
00567342 : CMP EBX,EAX
00567344 : JNC 0x00567358
00567346 : MOV EAX,dword ptr [ESP + 0x50]
0056734a : SHR EAX,0x1
0056734c : CMP EBX,EAX
0056734e : JNC 0x00567374
00567350 : PUSH EBX
00567351 : LEA ECX,[ESP + 0x4c]
00567355 : PUSH ECX
00567356 : JMP 0x0056736b
00567358 : CMP EBX,dword ptr [ESP + 0x50]
0056735c : JC 0x00567374
0056735e : MOV EDX,EBX
00567360 : SHR EDX,0x2
00567363 : ADD EDX,EBX
00567365 : PUSH EDX
00567366 : LEA EAX,[ESP + 0x4c]
0056736a : PUSH EAX
0056736b : LEA ECX,[ESP + 0x50]
0056736f : CALL 0x0057c3a0
00567374 : MOV ECX,dword ptr [ESP + 0x48]
00567378 : MOV dword ptr [ESP + 0x4c],EBX
0056737c : LEA EBX,[ECX + EBX*0x4 + -0x4]
00567380 : TEST EBX,EBX
00567382 : JZ 0x00567386
00567384 : MOV dword ptr [EBX],EBP
00567386 : MOV ECX,dword ptr [ESP + 0x38]
0056738a : TEST ECX,ECX
0056738c : JZ 0x00567393
0056738e : CALL 0x00524240
00567393 : MOV EAX,dword ptr [ESP + 0x20]
00567397 : MOV EDX,dword ptr [ESP + 0x1c]
0056739b : MOV ECX,dword ptr [EDX + 0xc]
0056739e : INC EAX
0056739f : MOV dword ptr [ESP + 0x20],EAX
005673a3 : MOV dword ptr [ESP + 0x1c],ECX
005673a7 : CMP EAX,dword ptr [EDI + 0x8]
005673aa : JC 0x00567240
005673b0 : CMP dword ptr [ESP + 0x4c],0x0
005673b5 : JZ 0x00567405
005673b7 : MOV EAX,dword ptr [ESP + 0x10]
005673bb : MOV EDX,dword ptr [EAX + 0x8]
005673be : CMP dword ptr [EDX + 0x1c],0x0
005673c2 : JZ 0x00567405
005673c4 : CMP byte ptr [EAX + 0x44],0x0
005673c8 : JNZ 0x005673d4
005673ca : CMP dword ptr [EAX + 0x18],0x0
005673ce : JNZ 0x005673d4
005673d0 : XOR ECX,ECX
005673d2 : JMP 0x005673d9
005673d4 : MOV ECX,0x1
005673d9 : PUSH ECX
005673da : MOV ECX,dword ptr [ESP + 0x1c]
005673de : PUSH ECX
005673df : MOV EDX,EAX
005673e1 : MOV EAX,dword ptr [EDX + 0x8]
005673e4 : LEA ECX,[ESI + 0x18]
005673e7 : PUSH ECX
005673e8 : MOV ECX,dword ptr [EDX + 0xc]
005673eb : MOV EDX,dword ptr [EDX + 0x20]
005673ee : PUSH ECX
005673ef : MOV ECX,dword ptr [EAX + 0x10]
005673f2 : MOV EAX,dword ptr [EAX + 0x1c]
005673f5 : PUSH EDX
005673f6 : PUSH ECX
005673f7 : LEA EDX,[ESP + 0x60]
005673fb : PUSH EDX
005673fc : PUSH EAX
005673fd : CALL 0x005ebf20
00567402 : ADD ESP,0x20
00567405 : MOV ECX,dword ptr [ESP + 0x48]
00567409 : PUSH ECX
0056740a : CALL 0x00515cf0
0056740f : MOV EAX,dword ptr [ESI + 0x20]
00567412 : MOV EDX,dword ptr [EDI + 0x4]
00567415 : MOV dword ptr [EAX + 0x80],EDX
0056741b : MOV ECX,dword ptr [ESI + 0x20]
0056741e : MOV EAX,dword ptr [ECX + 0x7c]
00567421 : INC EAX
00567422 : PUSH EAX
00567423 : ADD ECX,0x7c
00567426 : PUSH ECX
00567427 : CALL dword ptr [0x00b85108]
0056742d : MOV EAX,dword ptr [ESI + 0x20]
00567430 : MOV ECX,dword ptr [EAX + 0x7c]
00567433 : CMP ECX,0x1
00567436 : JNZ 0x0056746d
00567438 : MOV EAX,dword ptr [ESI + 0x20]
0056743b : MOV EDI,dword ptr [EAX + 0x74]
0056743e : MOV EBX,dword ptr [ESI + 0x20]
00567441 : OR EDI,0x100
00567447 : TEST EBX,EBX
00567449 : JZ 0x0056746d
0056744b : MOV EBP,dword ptr [EBX + 0x78]
0056744e : ADD EBP,0x8
00567451 : MOV ECX,EBP
00567453 : CALL 0x005162b0
00567458 : MOV ECX,dword ptr [EBX + 0x78]
0056745b : ADD ECX,0x1c
0056745e : MOV dword ptr [EBX + 0x74],EDI
00567461 : CALL 0x00516460
00567466 : MOV ECX,EBP
00567468 : CALL 0x005170a0
0056746d : MOV ECX,dword ptr [ESI + 0x24]
00567470 : MOV EDX,dword ptr [ECX]
00567472 : MOV EAX,dword ptr [EDX + 0x28]
00567475 : MOV EDI,dword ptr [ESI + 0x20]
00567478 : CALL EAX
0056747a : MOV ECX,dword ptr [EDI + 0x7c]
0056747d : CMP ECX,EAX
0056747f : JNZ 0x005674e0
00567481 : MOV EDX,dword ptr [ESI + 0x24]
00567484 : MOV EAX,dword ptr [EDX + 0x20]
00567487 : MOV ECX,dword ptr [EAX + 0x28]
0056748a : MOV EDX,dword ptr [ESI + 0x20]
0056748d : MOV dword ptr [EDX + 0x80],ECX
00567493 : MOV ECX,dword ptr [ESI + 0x1c]
00567496 : TEST ECX,ECX
00567498 : JZ 0x005674a1
0056749a : MOV EAX,dword ptr [ECX]
0056749c : MOV EDX,dword ptr [EAX + 0xc]
0056749f : CALL EDX
005674a1 : MOV EAX,dword ptr [ESI + 0x20]
005674a4 : MOV byte ptr [EAX + 0x3c],0x1
005674a8 : MOV EAX,dword ptr [ESI + 0x20]
005674ab : MOV EBX,dword ptr [EAX + 0x74]
005674ae : MOV EBP,dword ptr [ESI + 0x20]
005674b1 : AND EBX,0xfffffff2
005674b4 : OR EBX,0x202
005674ba : TEST EBP,EBP
005674bc : JZ 0x005674e0
005674be : MOV EDI,dword ptr [EBP + 0x78]
005674c1 : ADD EDI,0x8
005674c4 : MOV ECX,EDI
005674c6 : CALL 0x005162b0
005674cb : MOV ECX,dword ptr [EBP + 0x78]
005674ce : ADD ECX,0x1c
005674d1 : MOV dword ptr [EBP + 0x74],EBX
005674d4 : CALL 0x00516460
005674d9 : MOV ECX,EDI
005674db : CALL 0x005170a0
005674e0 : MOV ECX,dword ptr [ESP + 0x10]
005674e4 : MOV EBP,dword ptr [ECX + 0x14]
005674e7 : TEST EBP,EBP
005674e9 : JZ 0x00567569
005674eb : MOV EDI,dword ptr [ESI + 0x20]
005674ee : MOV ECX,dword ptr [EDI + 0xc]
005674f1 : MOV EBX,dword ptr [ECX + 0x20]
005674f4 : MOV EDX,dword ptr [EBX + 0x28]
005674f7 : MOV EAX,dword ptr [ECX]
005674f9 : MOV dword ptr [ESP + 0x2c],EDX
005674fd : MOV EDX,dword ptr [EAX + 0x28]
00567500 : CALL EDX
00567502 : MOV dword ptr [ESP + 0x24],EAX
00567506 : MOV EAX,dword ptr [EDI + 0x7c]
00567509 : MOV EDI,dword ptr [EDI + 0x80]
0056750f : ADD EBX,0x24
00567512 : PUSH EBX
00567513 : LEA ECX,[ESP + 0x70]
00567517 : MOV dword ptr [ESP + 0x2c],EAX
0056751b : CALL 0x0051c600
00567520 : MOV EDX,dword ptr [ESP + 0x28]
00567524 : MOV EAX,dword ptr [ESP + 0x24]
00567528 : MOV ECX,dword ptr [ESP + 0x2c]
0056752c : MOV dword ptr [ESP + 0x78],EDX
00567530 : MOV EDX,dword ptr [EBP]
00567533 : MOV EDX,dword ptr [EDX + 0x4]
00567536 : MOV dword ptr [ESP + 0x7c],EAX
0056753a : LEA EAX,[ESP + 0x6c]
0056753e : MOV dword ptr [ESP + 0x74],ECX
00567542 : PUSH EAX
00567543 : MOV ECX,EBP
00567545 : MOV dword ptr [ESP + 0x74],EDI
00567549 : CALL EDX
0056754b : MOV EDI,dword ptr [ESP + 0x6c]
0056754f : AND EDI,0xfffffffc
00567552 : PUSH -0x1
00567554 : LEA EAX,[EDI + 0x4]
00567557 : PUSH EAX
00567558 : CALL dword ptr [0x00b851cc]
0056755e : SUB EAX,0x1
00567561 : JNZ 0x00567569
00567563 : PUSH EDI
00567564 : CALL 0x00515cf0
00567569 : MOV ESI,dword ptr [ESI + 0x20]
0056756c : MOV EAX,dword ptr [ESI + 0x74]
0056756f : AND EAX,0xf
00567572 : POP EDI
00567573 : POP ESI
00567574 : POP EBP
00567575 : POP EBX
00567576 : MOV ESP,EBP
00567578 : POP EBP
00567579 : RET
0056757a : MOV ECX,dword ptr [ESI + 0x1c]
0056757d : TEST ECX,ECX
0056757f : JZ 0x00567588
00567581 : MOV EDX,dword ptr [ECX]
00567583 : MOV EAX,dword ptr [EDX + 0xc]
00567586 : CALL EAX
00567588 : MOV ECX,dword ptr [ESI + 0x20]
0056758b : MOV byte ptr [ECX + 0x3c],0x1
0056758f : MOV EAX,dword ptr [ESI + 0x20]
00567592 : MOV DL,byte ptr [EAX + 0x84]
00567598 : XOR EAX,EAX
0056759a : TEST DL,DL
0056759c : SETZ AL
0056759f : ADD EAX,0x3
005675a2 : MOV EDI,EAX
005675a4 : MOV EAX,dword ptr [ESI + 0x20]
005675a7 : MOV EBX,dword ptr [EAX + 0x74]
005675aa : MOV EBP,dword ptr [ESI + 0x20]
005675ad : AND EBX,0xfffffff0
005675b0 : OR EBX,EDI
005675b2 : MOV dword ptr [ESP + 0x2c],EDI
005675b6 : TEST EBP,EBP
005675b8 : JZ 0x005675e0
005675ba : MOV EDI,dword ptr [EBP + 0x78]
005675bd : ADD EDI,0x8
005675c0 : MOV ECX,EDI
005675c2 : CALL 0x005162b0
005675c7 : MOV ECX,dword ptr [EBP + 0x78]
005675ca : ADD ECX,0x1c
005675cd : MOV dword ptr [EBP + 0x74],EBX
005675d0 : CALL 0x00516460
005675d5 : MOV ECX,EDI
005675d7 : CALL 0x005170a0
005675dc : MOV EDI,dword ptr [ESP + 0x2c]
005675e0 : MOV ECX,dword ptr [ESI + 0x20]
005675e3 : MOV EBX,dword ptr [ECX + 0x78]
005675e6 : TEST EBX,EBX
005675e8 : JZ 0x005675f1
005675ea : MOV ECX,EBX
005675ec : CALL 0x00523dd0
005675f1 : MOV ECX,dword ptr [ESI + 0x20]
005675f4 : TEST ECX,ECX
005675f6 : JZ 0x005675fd
005675f8 : CALL 0x004ff7e0
005675fd : MOV dword ptr [ESI + 0x20],0x0
00567604 : LEA ESI,[EBX + 0x8]
00567607 : MOV ECX,ESI
00567609 : CALL 0x005162b0
0056760e : LEA ECX,[EBX + 0x1c]
00567611 : MOV byte ptr [EBX + 0x20],0x1
00567615 : CALL 0x00516460
0056761a : MOV ECX,ESI
0056761c : CALL 0x005170a0
00567621 : MOV ECX,EBX
00567623 : CALL 0x004ff7e0
00567628 : MOV EAX,EDI
0056762a : POP EDI
0056762b : POP ESI
0056762c : POP EBP
0056762d : POP EBX
0056762e : MOV ESP,EBP
00567630 : POP EBP
00567631 : RET
