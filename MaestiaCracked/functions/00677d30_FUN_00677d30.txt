PROGRAM  : Maestia.exe
FUNCTION : FUN_00677d30
ENTRY    : 00677d30
BODY     : [[00677d30, 00677e07] [00677e10, 00677e37]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00677d30(byte *param_1,int param_2,int param_3,int param_4,undefined4 param_5,int param_6)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  int in_ECX;
  char *pcVar4;
  uint uVar5;
  byte *pbVar6;
  int iVar7;
  uint uVar8;
  
  iVar1 = param_2;
  uVar5 = param_2 * param_3;
  *(int *)(param_6 + 0x14) = param_2;
  *(int *)(param_6 + 0x18) = param_3;
  *(int *)(param_6 + 0x1c) = -param_4;
  *(undefined4 *)(param_6 + 0x20) = param_5;
  if (uVar5 < *(uint *)(param_6 + 0xc)) {
    uVar8 = uVar5;
    if (*(uint *)(param_6 + 0x10) >> 1 <= uVar5) goto LAB_00677d89;
  }
  else {
    if (uVar5 < *(uint *)(param_6 + 0x10)) goto LAB_00677d89;
    uVar8 = (uVar5 >> 2) + uVar5;
  }
  FUN_005da1e0((undefined4 *)(param_6 + 8),uVar8);
LAB_00677d89:
  *(uint *)(param_6 + 0xc) = uVar5;
  pcVar4 = *(char **)(param_6 + 8);
  if (*(int *)(*(int *)(in_ECX + 0x1c) + 0x10) == 1) {
    iVar3 = param_2 + 0x1f;
    if (0 < param_3) {
      param_2 = param_3;
      do {
        bVar2 = 0x80;
        pbVar6 = param_1;
        iVar7 = iVar1;
        if (0 < iVar1) {
          do {
            *pcVar4 = -((*pbVar6 & bVar2) != 0);
            pcVar4 = pcVar4 + 1;
            bVar2 = bVar2 >> 1;
            if (bVar2 == 0) {
              pbVar6 = pbVar6 + 1;
              bVar2 = 0x80;
            }
            iVar7 = iVar7 + -1;
          } while (iVar7 != 0);
        }
        param_1 = param_1 + (iVar3 >> 3 & 0xfffffffc);
        param_2 = param_2 + -1;
      } while (param_2 != 0);
      return;
    }
  }
  else {
    uVar5 = param_2 + 3;
    if (0 < param_3) {
      param_2 = param_3;
      do {
        iVar3 = 0;
        if (0 < iVar1) {
          do {
            *pcVar4 = *(char *)(param_1[iVar3] + 0x14 + *(int *)(in_ECX + 0x1c));
            iVar3 = iVar3 + 1;
            pcVar4 = pcVar4 + 1;
          } while (iVar3 < iVar1);
        }
        param_1 = param_1 + (uVar5 & 0xfffffffc);
        param_2 = param_2 + -1;
      } while (param_2 != 0);
    }
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00677d30 : PUSH ECX
00677d31 : MOV EAX,dword ptr [ESP + 0x1c]
00677d35 : MOV EDX,dword ptr [ESP + 0x18]
00677d39 : PUSH EBX
00677d3a : MOV EBX,dword ptr [ESP + 0x14]
00677d3e : PUSH EBP
00677d3f : MOV EBP,dword ptr [ESP + 0x14]
00677d43 : PUSH ESI
00677d44 : MOV ESI,EBP
00677d46 : IMUL ESI,EBX
00677d49 : MOV dword ptr [ESP + 0xc],ECX
00677d4d : MOV ECX,dword ptr [ESP + 0x20]
00677d51 : NEG ECX
00677d53 : PUSH EDI
00677d54 : LEA EDI,[EAX + 0x8]
00677d57 : MOV dword ptr [EAX + 0x14],EBP
00677d5a : MOV dword ptr [EAX + 0x18],EBX
00677d5d : MOV dword ptr [EAX + 0x1c],ECX
00677d60 : MOV dword ptr [EAX + 0x20],EDX
00677d63 : CMP ESI,dword ptr [EDI + 0x4]
00677d66 : JNC 0x00677d74
00677d68 : MOV EAX,dword ptr [EDI + 0x8]
00677d6b : SHR EAX,0x1
00677d6d : CMP ESI,EAX
00677d6f : JNC 0x00677d89
00677d71 : PUSH ESI
00677d72 : JMP 0x00677d81
00677d74 : CMP ESI,dword ptr [EDI + 0x8]
00677d77 : JC 0x00677d89
00677d79 : MOV ECX,ESI
00677d7b : SHR ECX,0x2
00677d7e : ADD ECX,ESI
00677d80 : PUSH ECX
00677d81 : PUSH EDI
00677d82 : MOV ECX,EDI
00677d84 : CALL 0x005da1e0
00677d89 : MOV EAX,dword ptr [ESP + 0x10]
00677d8d : MOV EDX,dword ptr [ESP + 0x18]
00677d91 : MOV dword ptr [EDI + 0x4],ESI
00677d94 : MOV EAX,dword ptr [EAX + 0x1c]
00677d97 : CMP dword ptr [EAX + 0x10],0x1
00677d9b : MOV ECX,dword ptr [EDI]
00677d9d : JNZ 0x00677dee
00677d9f : LEA EDI,[EBP + 0x1f]
00677da2 : SAR EDI,0x3
00677da5 : AND EDI,0xfffffffc
00677da8 : MOV dword ptr [ESP + 0x2c],EDI
00677dac : TEST EBX,EBX
00677dae : JLE 0x00677e30
00677db4 : MOV dword ptr [ESP + 0x1c],EBX
00677db8 : MOV ESI,EDX
00677dba : MOV AL,0x80
00677dbc : TEST EBP,EBP
00677dbe : JLE 0x00677ddd
00677dc0 : MOV EDI,EBP
00677dc2 : MOV BL,byte ptr [ESI]
00677dc4 : AND BL,AL
00677dc6 : NEG BL
00677dc8 : SBB BL,BL
00677dca : MOV byte ptr [ECX],BL
00677dcc : INC ECX
00677dcd : SHR AL,0x1
00677dcf : JNZ 0x00677dd4
00677dd1 : INC ESI
00677dd2 : MOV AL,0x80
00677dd4 : SUB EDI,0x1
00677dd7 : JNZ 0x00677dc2
00677dd9 : MOV EDI,dword ptr [ESP + 0x2c]
00677ddd : ADD EDX,EDI
00677ddf : SUB dword ptr [ESP + 0x1c],0x1
00677de4 : JNZ 0x00677db8
00677de6 : POP EDI
00677de7 : POP ESI
00677de8 : POP EBP
00677de9 : POP EBX
00677dea : POP ECX
00677deb : RET 0x18
00677dee : LEA ESI,[EBP + 0x3]
00677df1 : AND ESI,0xfffffffc
00677df4 : TEST EBX,EBX
00677df6 : JLE 0x00677e30
00677df8 : MOV dword ptr [ESP + 0x1c],EBX
00677dfc : LEA ESP,[ESP]
00677e00 : XOR EAX,EAX
00677e02 : TEST EBP,EBP
00677e04 : JLE 0x00677e27
00677e06 : JMP 0x00677e10
00677e10 : MOVZX EDI,byte ptr [EAX + EDX*0x1]
00677e14 : MOV EBX,dword ptr [ESP + 0x10]
00677e18 : MOV EBX,dword ptr [EBX + 0x1c]
00677e1b : MOV BL,byte ptr [EDI + EBX*0x1 + 0x14]
00677e1f : MOV byte ptr [ECX],BL
00677e21 : INC EAX
00677e22 : INC ECX
00677e23 : CMP EAX,EBP
00677e25 : JL 0x00677e10
00677e27 : ADD EDX,ESI
00677e29 : SUB dword ptr [ESP + 0x1c],0x1
00677e2e : JNZ 0x00677e00
00677e30 : POP EDI
00677e31 : POP ESI
00677e32 : POP EBP
00677e33 : POP EBX
00677e34 : POP ECX
00677e35 : RET 0x18
