PROGRAM  : Maestia.exe
FUNCTION : FUN_006a6850
ENTRY    : 006a6850
BODY     : [[006a6850, 006a6cb4]]

============================================================
DECOMPILED C CODE
============================================================

int FUN_006a6850(int param_1,byte *param_2,byte *param_3)

{
  uint *puVar1;
  byte bVar2;
  undefined4 uVar3;
  byte *pbVar4;
  int iVar5;
  byte *pbVar6;
  uint *puVar7;
  uint uVar8;
  int extraout_EDX;
  uint uVar9;
  byte *pbVar10;
  uint uVar11;
  byte *pbVar12;
  uint uVar13;
  int local_34;
  uint local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  uint local_20 [2];
  undefined1 local_18 [16];
  uint local_8;
  uint local_4;
  
  pbVar6 = param_2 + 1;
  local_34 = 0;
  if (param_3 < pbVar6) {
    return 8;
  }
  bVar2 = *param_2;
  local_24 = (uint)bVar2;
  if ((char)bVar2 < '\0') {
    return 8;
  }
  local_30 = 0;
  local_2c = 0;
  if ((bVar2 & 4) == 0) {
    pbVar12 = pbVar6;
    if ((bVar2 & 2) != 0) {
      pbVar12 = param_2 + 2;
      if (param_3 < pbVar12) {
        return 8;
      }
      local_30 = (uint)*pbVar6;
    }
    param_2 = pbVar12;
    if ((bVar2 & 1) == 0) goto LAB_006a68f5;
    param_2 = pbVar12 + 1;
    if (param_3 < param_2) {
      return 8;
    }
    bVar2 = *pbVar12;
  }
  else {
    param_2 = param_2 + 2;
    if (param_3 < param_2) {
      return 8;
    }
    local_30 = *pbVar6 & 0xf;
    bVar2 = *pbVar6 >> 4;
  }
  local_2c = (uint)bVar2;
LAB_006a68f5:
  uVar13 = local_2c + local_30;
  local_28 = uVar13;
  if (*(uint *)(param_1 + 4) < uVar13) {
    uVar11 = uVar13 + 7 & 0xfffffff8;
    uVar3 = FUN_0068a220(**(undefined4 **)(param_1 + 0x1c),4,*(uint *)(param_1 + 4),uVar11,
                         *(undefined4 *)(param_1 + 8),&local_34);
    *(undefined4 *)(param_1 + 8) = uVar3;
    if (local_34 != 0) {
      return local_34;
    }
    *(uint *)(param_1 + 4) = uVar11;
  }
  *(uint *)(param_1 + 0xc) = *(int *)(param_1 + 8) + local_30 * 4;
  uVar9 = 0;
  uVar11 = 0;
  uVar8 = 0;
  if (uVar13 != 0) {
    pbVar6 = param_2 + 1;
    pbVar12 = param_2 + 2;
    do {
      if ((uVar8 & 7) == 0) {
        if (param_3 < pbVar6) {
          return 8;
        }
        uVar9 = (uint)*param_2;
        param_2 = param_2 + 1;
        pbVar12 = pbVar12 + 1;
        pbVar6 = pbVar6 + 1;
      }
      if ((uVar9 & 1) == 0) {
        if (param_3 < pbVar6) {
          return 8;
        }
        uVar11 = uVar11 + *param_2;
        param_2 = param_2 + 1;
        pbVar12 = pbVar12 + 1;
        pbVar6 = pbVar6 + 1;
      }
      else {
        if (param_3 < pbVar12) {
          return 8;
        }
        bVar2 = *param_2;
        pbVar4 = param_2 + 1;
        param_2 = param_2 + 2;
        pbVar12 = pbVar12 + 2;
        pbVar6 = pbVar6 + 2;
        uVar11 = (int)(short)((short)(char)bVar2 << 8) | (uint)*pbVar4;
      }
      *(uint *)(*(int *)(param_1 + 8) + uVar8 * 4) = uVar11;
      uVar8 = uVar8 + 1;
      uVar9 = uVar9 >> 1;
    } while (uVar8 < local_28);
  }
  if (((local_24 & 8) != 0) && (local_34 = FUN_006a6590(), local_34 != 0)) {
    return local_34;
  }
  FUN_006a5560();
  local_20[1] = 0;
  uVar13 = 0;
  local_4 = 0;
  pbVar6 = param_2 + 1;
  local_20[0] = 0;
  local_8 = 0;
  iVar5 = extraout_EDX;
  pbVar12 = param_2;
  if (param_3 < pbVar6) {
    return 8;
  }
  do {
    param_2 = (byte *)0x0;
    local_24 = (uint)(*pbVar12 >> 4);
    uVar11 = *pbVar12 & 0xf;
    switch(local_24) {
    case 0:
      uVar8 = 0;
      break;
    case 1:
    case 4:
    case 5:
      uVar8 = 1;
      param_2 = (byte *)uVar11;
      break;
    case 2:
      if (local_30 < uVar11) {
        return 8;
      }
      uVar13 = *(uint *)(*(int *)(iVar5 + 8) + uVar11 * 4);
      local_20[0] = uVar13;
      local_20[1] = local_4;
      local_8 = uVar13;
      uVar8 = 0;
      break;
    case 3:
      if (local_2c < uVar11) {
        return 8;
      }
      local_20[1] = *(uint *)(*(int *)(iVar5 + 0xc) + uVar11 * 4);
      local_20[0] = uVar13;
      local_8 = uVar13;
      local_4 = local_20[1];
      uVar8 = 0;
      break;
    case 6:
      param_2 = (byte *)0xb8e;
      uVar8 = 3;
      break;
    case 7:
      param_2 = (byte *)0xe2b;
      uVar8 = 3;
      break;
    default:
      uVar8 = 4;
      param_2 = (byte *)uVar11;
    }
    puVar7 = local_20;
    local_28 = 0;
    pbVar12 = pbVar6;
    if (uVar8 != 0) {
      pbVar4 = pbVar6 + 1;
      pbVar10 = pbVar6 + 2;
      do {
        uVar11 = (uint)param_2 & 3;
        if (uVar11 == 0) {
          if (param_3 < pbVar4) {
            return 8;
          }
          bVar2 = *pbVar6;
          pbVar6 = pbVar6 + 1;
          pbVar10 = pbVar10 + 1;
          pbVar4 = pbVar4 + 1;
          if (local_30 < bVar2) {
            return 8;
          }
          uVar13 = *(uint *)(*(int *)(param_1 + 8) + (uint)bVar2 * 4);
LAB_006a6b4d:
          *puVar7 = uVar13;
        }
        else {
          if (uVar11 == 1) {
            if (param_3 < pbVar10) {
              return 8;
            }
            bVar2 = *pbVar6;
            pbVar12 = pbVar6 + 1;
            pbVar6 = pbVar6 + 2;
            pbVar10 = pbVar10 + 2;
            pbVar4 = pbVar4 + 2;
            uVar13 = (int)(short)((short)(char)bVar2 << 8) | (uint)*pbVar12;
            goto LAB_006a6b4d;
          }
          if (uVar11 == 2) {
            if (param_3 < pbVar4) {
              return 8;
            }
            bVar2 = *pbVar6;
            pbVar6 = pbVar6 + 1;
            pbVar10 = pbVar10 + 1;
            pbVar4 = pbVar4 + 1;
            uVar13 = (int)(char)bVar2 + uVar13;
            goto LAB_006a6b4d;
          }
          *puVar7 = uVar13;
        }
        uVar13 = (uint)param_2 >> 2 & 3;
        if (uVar13 == 0) {
          if (param_3 < pbVar4) {
            return 8;
          }
          bVar2 = *pbVar6;
          pbVar6 = pbVar6 + 1;
          pbVar10 = pbVar10 + 1;
          pbVar4 = pbVar4 + 1;
          if (local_2c < bVar2) {
            return 8;
          }
          local_4 = *(uint *)(*(int *)(param_1 + 0xc) + (uint)bVar2 * 4);
        }
        else if (uVar13 == 1) {
          if (param_3 < pbVar10) {
            return 8;
          }
          bVar2 = *pbVar6;
          pbVar12 = pbVar6 + 1;
          pbVar6 = pbVar6 + 2;
          pbVar10 = pbVar10 + 2;
          pbVar4 = pbVar4 + 2;
          local_4 = (int)(short)((short)(char)bVar2 << 8) | (uint)*pbVar12;
        }
        else if (uVar13 == 2) {
          if (param_3 < pbVar4) {
            return 8;
          }
          bVar2 = *pbVar6;
          pbVar6 = pbVar6 + 1;
          pbVar10 = pbVar10 + 1;
          pbVar4 = pbVar4 + 1;
          local_4 = (int)(char)bVar2 + local_4;
        }
        puVar7[1] = local_4;
        if ((local_28 == 0) && (uVar8 == 4)) {
          if (param_3 < pbVar4) {
            return 8;
          }
          param_2 = (byte *)(uint)*pbVar6;
          pbVar6 = pbVar6 + 1;
          pbVar10 = pbVar10 + 1;
          pbVar4 = pbVar4 + 1;
          uVar8 = 3;
        }
        else {
          param_2 = (byte *)((uint)param_2 >> 4);
        }
        uVar13 = *puVar7;
        local_28 = local_28 + 1;
        local_8 = uVar13;
        puVar1 = puVar7 + 1;
        puVar7 = puVar7 + 2;
        local_4 = *puVar1;
        pbVar12 = pbVar6;
      } while (local_28 < uVar8);
    }
    switch(local_24) {
    case 0:
      FUN_006a56c0();
      return local_34;
    case 1:
    case 2:
    case 3:
      iVar5 = FUN_006a5570();
      break;
    case 4:
    case 5:
      iVar5 = FUN_006a5660(local_20);
      break;
    default:
      iVar5 = FUN_006a55d0(local_20,local_18);
    }
    if (iVar5 != 0) {
      return iVar5;
    }
    pbVar6 = pbVar12 + 1;
    local_34 = 0;
    iVar5 = param_1;
    if (param_3 < pbVar6) {
      return 8;
    }
  } while( true );
}



============================================================
DISASSEMBLY
============================================================
006a6850 : SUB ESP,0x34
006a6853 : MOV EAX,dword ptr [ESP + 0x3c]
006a6857 : PUSH EBX
006a6858 : MOV EBX,dword ptr [ESP + 0x3c]
006a685c : MOV EDX,dword ptr [EBX + 0x1c]
006a685f : PUSH EBP
006a6860 : PUSH ESI
006a6861 : MOV ESI,dword ptr [ESP + 0x4c]
006a6865 : XOR ECX,ECX
006a6867 : LEA EBP,[EAX + 0x1]
006a686a : MOV dword ptr [ESP + 0xc],ECX
006a686e : MOV EDX,dword ptr [EDX]
006a6870 : PUSH EDI
006a6871 : CMP EBP,ESI
006a6873 : JA 0x006a6c95
006a6879 : MOVZX EAX,byte ptr [EAX]
006a687c : MOV dword ptr [ESP + 0x20],EAX
006a6880 : MOV dword ptr [ESP + 0x4c],EBP
006a6884 : TEST AL,AL
006a6886 : JS 0x006a6c95
006a688c : MOV dword ptr [ESP + 0x14],ECX
006a6890 : MOV dword ptr [ESP + 0x18],ECX
006a6894 : TEST AL,0x4
006a6896 : JZ 0x006a68bb
006a6898 : LEA ECX,[EBP + 0x1]
006a689b : CMP ECX,ESI
006a689d : JA 0x006a6c95
006a68a3 : MOVZX EAX,byte ptr [EBP]
006a68a7 : MOV EBP,ECX
006a68a9 : MOV ECX,EAX
006a68ab : AND ECX,0xf
006a68ae : SHR EAX,0x4
006a68b1 : MOV dword ptr [ESP + 0x14],ECX
006a68b5 : MOV dword ptr [ESP + 0x18],EAX
006a68b9 : JMP 0x006a68f1
006a68bb : TEST AL,0x2
006a68bd : JZ 0x006a68d8
006a68bf : LEA ECX,[EBP + 0x1]
006a68c2 : CMP ECX,ESI
006a68c4 : JA 0x006a6c95
006a68ca : MOVZX EDI,byte ptr [EBP]
006a68ce : MOV EBP,ECX
006a68d0 : MOV dword ptr [ESP + 0x14],EDI
006a68d4 : MOV dword ptr [ESP + 0x4c],EBP
006a68d8 : TEST AL,0x1
006a68da : JZ 0x006a68f5
006a68dc : LEA EAX,[EBP + 0x1]
006a68df : CMP EAX,ESI
006a68e1 : JA 0x006a6c95
006a68e7 : MOVZX ECX,byte ptr [EBP]
006a68eb : MOV dword ptr [ESP + 0x18],ECX
006a68ef : MOV EBP,EAX
006a68f1 : MOV dword ptr [ESP + 0x4c],EBP
006a68f5 : MOV EAX,dword ptr [ESP + 0x18]
006a68f9 : MOV ECX,dword ptr [ESP + 0x14]
006a68fd : LEA EDI,[EAX + ECX*0x1]
006a6900 : MOV EAX,dword ptr [EBX + 0x4]
006a6903 : MOV dword ptr [ESP + 0x1c],EDI
006a6907 : CMP EDI,EAX
006a6909 : JBE 0x006a6939
006a690b : LEA ECX,[ESP + 0x10]
006a690f : PUSH ECX
006a6910 : MOV ECX,dword ptr [EBX + 0x8]
006a6913 : PUSH ECX
006a6914 : LEA ESI,[EDI + 0x7]
006a6917 : AND ESI,0xfffffff8
006a691a : PUSH ESI
006a691b : PUSH EAX
006a691c : PUSH 0x4
006a691e : PUSH EDX
006a691f : CALL 0x0068a220
006a6924 : MOV dword ptr [EBX + 0x8],EAX
006a6927 : MOV EAX,dword ptr [ESP + 0x28]
006a692b : ADD ESP,0x18
006a692e : TEST EAX,EAX
006a6930 : JNZ 0x006a6cad
006a6936 : MOV dword ptr [EBX + 0x4],ESI
006a6939 : MOV EDX,dword ptr [EBX + 0x8]
006a693c : MOV EAX,dword ptr [ESP + 0x14]
006a6940 : LEA ECX,[EDX + EAX*0x4]
006a6943 : MOV dword ptr [EBX + 0xc],ECX
006a6946 : XOR EBX,EBX
006a6948 : XOR EAX,EAX
006a694a : XOR EDX,EDX
006a694c : TEST EDI,EDI
006a694e : JBE 0x006a69be
006a6950 : LEA ECX,[EBP + 0x1]
006a6953 : LEA ESI,[EBP + 0x2]
006a6956 : MOV EDI,dword ptr [ESP + 0x50]
006a695a : TEST DL,0x7
006a695d : JNZ 0x006a696e
006a695f : CMP ECX,EDI
006a6961 : JA 0x006a6c91
006a6967 : MOVZX EBX,byte ptr [EBP]
006a696b : INC EBP
006a696c : INC ESI
006a696d : INC ECX
006a696e : TEST BL,0x1
006a6971 : JZ 0x006a6996
006a6973 : CMP ESI,EDI
006a6975 : JA 0x006a6c91
006a697b : MOVSX AX,byte ptr [EBP]
006a6980 : MOVZX EDI,byte ptr [EBP + 0x1]
006a6984 : ADD EBP,0x2
006a6987 : SHL AX,0x8
006a698b : CWDE
006a698c : ADD ESI,0x2
006a698f : ADD ECX,0x2
006a6992 : OR EAX,EDI
006a6994 : JMP 0x006a69a7
006a6996 : CMP ECX,EDI
006a6998 : JA 0x006a6c91
006a699e : MOVZX EDI,byte ptr [EBP]
006a69a2 : ADD EAX,EDI
006a69a4 : INC EBP
006a69a5 : INC ESI
006a69a6 : INC ECX
006a69a7 : MOV EDI,dword ptr [ESP + 0x48]
006a69ab : MOV EDI,dword ptr [EDI + 0x8]
006a69ae : MOV dword ptr [EDI + EDX*0x4],EAX
006a69b1 : INC EDX
006a69b2 : SHR EBX,0x1
006a69b4 : CMP EDX,dword ptr [ESP + 0x1c]
006a69b8 : JC 0x006a6956
006a69ba : MOV dword ptr [ESP + 0x4c],EBP
006a69be : TEST byte ptr [ESP + 0x20],0x8
006a69c3 : JZ 0x006a69e2
006a69c5 : MOV EBX,dword ptr [ESP + 0x50]
006a69c9 : LEA EAX,[ESP + 0x4c]
006a69cd : CALL 0x006a6590
006a69d2 : MOV dword ptr [ESP + 0x10],EAX
006a69d6 : TEST EAX,EAX
006a69d8 : JNZ 0x006a6cad
006a69de : MOV EBP,dword ptr [ESP + 0x4c]
006a69e2 : MOV EDX,dword ptr [ESP + 0x48]
006a69e6 : MOV EAX,EDX
006a69e8 : CALL 0x006a5560
006a69ed : XOR EAX,EAX
006a69ef : MOV dword ptr [ESP + 0x28],EAX
006a69f3 : XOR ESI,ESI
006a69f5 : MOV dword ptr [ESP + 0x40],EAX
006a69f9 : MOV dword ptr [ESP + 0x4c],EAX
006a69fd : LEA EAX,[EBP + 0x1]
006a6a00 : MOV dword ptr [ESP + 0x24],ESI
006a6a04 : MOV dword ptr [ESP + 0x3c],ESI
006a6a08 : CMP EAX,dword ptr [ESP + 0x50]
006a6a0c : JA 0x006a6c95
006a6a12 : JMP 0x006a6a18
006a6a14 : MOV EDX,dword ptr [ESP + 0x48]
006a6a18 : MOVZX ECX,byte ptr [EBP]
006a6a1c : MOV EBP,EAX
006a6a1e : MOV EBX,ECX
006a6a20 : MOV EAX,ECX
006a6a22 : SHR EBX,0x4
006a6a25 : AND EAX,0xf
006a6a28 : MOV dword ptr [ESP + 0x20],EBX
006a6a2c : CMP EBX,0x7
006a6a2f : JA 0x006a6aaf
006a6a31 : JMP dword ptr [EBX*0x4 + 0x6a6cb8]
006a6a38 : XOR EDI,EDI
006a6a3a : JMP 0x006a6ab8
006a6a3c : MOV EDI,0x1
006a6a41 : JMP 0x006a6ab4
006a6a43 : CMP EAX,dword ptr [ESP + 0x14]
006a6a47 : JA 0x006a6c95
006a6a4d : MOV ECX,dword ptr [EDX + 0x8]
006a6a50 : MOV EAX,dword ptr [ECX + EAX*0x4]
006a6a53 : MOV ECX,dword ptr [ESP + 0x40]
006a6a57 : MOV ESI,EAX
006a6a59 : MOV dword ptr [ESP + 0x24],EAX
006a6a5d : MOV dword ptr [ESP + 0x28],ECX
006a6a61 : MOV dword ptr [ESP + 0x3c],ESI
006a6a65 : MOV dword ptr [ESP + 0x40],ECX
006a6a69 : XOR EDI,EDI
006a6a6b : JMP 0x006a6ab8
006a6a6d : CMP EAX,dword ptr [ESP + 0x18]
006a6a71 : JA 0x006a6c95
006a6a77 : MOV ECX,dword ptr [EDX + 0xc]
006a6a7a : MOV EAX,dword ptr [ECX + EAX*0x4]
006a6a7d : MOV dword ptr [ESP + 0x24],ESI
006a6a81 : MOV dword ptr [ESP + 0x28],EAX
006a6a85 : MOV dword ptr [ESP + 0x3c],ESI
006a6a89 : MOV dword ptr [ESP + 0x40],EAX
006a6a8d : XOR EDI,EDI
006a6a8f : JMP 0x006a6ab8
006a6a91 : MOV dword ptr [ESP + 0x4c],0xb8e
006a6a99 : MOV EDI,0x3
006a6a9e : JMP 0x006a6ab8
006a6aa0 : MOV dword ptr [ESP + 0x4c],0xe2b
006a6aa8 : MOV EDI,0x3
006a6aad : JMP 0x006a6ab8
006a6aaf : MOV EDI,0x4
006a6ab4 : MOV dword ptr [ESP + 0x4c],EAX
006a6ab8 : LEA ECX,[ESP + 0x24]
006a6abc : MOV dword ptr [ESP + 0x1c],0x0
006a6ac4 : TEST EDI,EDI
006a6ac6 : JBE 0x006a6c29
006a6acc : LEA EAX,[EBP + 0x1]
006a6acf : LEA EBX,[EBP + 0x2]
006a6ad2 : MOV EDX,dword ptr [ESP + 0x4c]
006a6ad6 : AND EDX,0x3
006a6ad9 : SUB EDX,0x0
006a6adc : JZ 0x006a6b28
006a6ade : SUB EDX,0x1
006a6ae1 : JZ 0x006a6b01
006a6ae3 : SUB EDX,0x1
006a6ae6 : JZ 0x006a6aec
006a6ae8 : MOV dword ptr [ECX],ESI
006a6aea : JMP 0x006a6b4f
006a6aec : CMP EAX,dword ptr [ESP + 0x50]
006a6af0 : JA 0x006a6c95
006a6af6 : MOVSX EDX,byte ptr [EBP]
006a6afa : INC EBP
006a6afb : INC EBX
006a6afc : INC EAX
006a6afd : ADD EDX,ESI
006a6aff : JMP 0x006a6b4d
006a6b01 : CMP EBX,dword ptr [ESP + 0x50]
006a6b05 : JA 0x006a6c95
006a6b0b : MOVSX DX,byte ptr [EBP]
006a6b10 : MOVZX ESI,byte ptr [EBP + 0x1]
006a6b14 : ADD EBP,0x2
006a6b17 : SHL DX,0x8
006a6b1b : MOVSX EDX,DX
006a6b1e : ADD EBX,0x2
006a6b21 : ADD EAX,0x2
006a6b24 : OR EDX,ESI
006a6b26 : JMP 0x006a6b4d
006a6b28 : CMP EAX,dword ptr [ESP + 0x50]
006a6b2c : JA 0x006a6c95
006a6b32 : MOVZX EDX,byte ptr [EBP]
006a6b36 : INC EBP
006a6b37 : INC EBX
006a6b38 : INC EAX
006a6b39 : CMP EDX,dword ptr [ESP + 0x14]
006a6b3d : JA 0x006a6c95
006a6b43 : MOV ESI,dword ptr [ESP + 0x48]
006a6b47 : MOV ESI,dword ptr [ESI + 0x8]
006a6b4a : MOV EDX,dword ptr [ESI + EDX*0x4]
006a6b4d : MOV dword ptr [ECX],EDX
006a6b4f : MOV EDX,dword ptr [ESP + 0x4c]
006a6b53 : SHR EDX,0x2
006a6b56 : AND EDX,0x3
006a6b59 : SUB EDX,0x0
006a6b5c : JZ 0x006a6bae
006a6b5e : SUB EDX,0x1
006a6b61 : JZ 0x006a6b87
006a6b63 : SUB EDX,0x1
006a6b66 : JZ 0x006a6b6e
006a6b68 : MOV EDX,dword ptr [ESP + 0x40]
006a6b6c : JMP 0x006a6bd3
006a6b6e : CMP EAX,dword ptr [ESP + 0x50]
006a6b72 : JA 0x006a6c95
006a6b78 : MOVSX EDX,byte ptr [EBP]
006a6b7c : MOV ESI,dword ptr [ESP + 0x40]
006a6b80 : INC EBP
006a6b81 : INC EBX
006a6b82 : INC EAX
006a6b83 : ADD EDX,ESI
006a6b85 : JMP 0x006a6bd3
006a6b87 : CMP EBX,dword ptr [ESP + 0x50]
006a6b8b : JA 0x006a6c95
006a6b91 : MOVSX DX,byte ptr [EBP]
006a6b96 : MOVZX ESI,byte ptr [EBP + 0x1]
006a6b9a : ADD EBP,0x2
006a6b9d : SHL DX,0x8
006a6ba1 : MOVSX EDX,DX
006a6ba4 : ADD EBX,0x2
006a6ba7 : ADD EAX,0x2
006a6baa : OR EDX,ESI
006a6bac : JMP 0x006a6bd3
006a6bae : CMP EAX,dword ptr [ESP + 0x50]
006a6bb2 : JA 0x006a6c95
006a6bb8 : MOVZX EDX,byte ptr [EBP]
006a6bbc : INC EBP
006a6bbd : INC EBX
006a6bbe : INC EAX
006a6bbf : CMP EDX,dword ptr [ESP + 0x18]
006a6bc3 : JA 0x006a6c95
006a6bc9 : MOV ESI,dword ptr [ESP + 0x48]
006a6bcd : MOV ESI,dword ptr [ESI + 0xc]
006a6bd0 : MOV EDX,dword ptr [ESI + EDX*0x4]
006a6bd3 : CMP dword ptr [ESP + 0x1c],0x0
006a6bd8 : MOV dword ptr [ECX + 0x4],EDX
006a6bdb : JNZ 0x006a6bfe
006a6bdd : CMP EDI,0x4
006a6be0 : JNZ 0x006a6bfe
006a6be2 : CMP EAX,dword ptr [ESP + 0x50]
006a6be6 : JA 0x006a6c95
006a6bec : MOVZX EDX,byte ptr [EBP]
006a6bf0 : INC EBP
006a6bf1 : INC EBX
006a6bf2 : MOV dword ptr [ESP + 0x4c],EDX
006a6bf6 : INC EAX
006a6bf7 : MOV EDI,0x3
006a6bfc : JMP 0x006a6c03
006a6bfe : SHR dword ptr [ESP + 0x4c],0x4
006a6c03 : MOV ESI,dword ptr [ECX]
006a6c05 : INC dword ptr [ESP + 0x1c]
006a6c09 : MOV dword ptr [ESP + 0x3c],ESI
006a6c0d : MOV EDX,dword ptr [ECX + 0x4]
006a6c10 : ADD ECX,0x8
006a6c13 : MOV dword ptr [ESP + 0x40],EDX
006a6c17 : CMP dword ptr [ESP + 0x1c],EDI
006a6c1b : JC 0x006a6ad2
006a6c21 : MOV EBX,dword ptr [ESP + 0x20]
006a6c25 : MOV EDX,dword ptr [ESP + 0x48]
006a6c29 : CMP EBX,0x5
006a6c2c : JA 0x006a6c53
006a6c2e : JMP dword ptr [EBX*0x4 + 0x6a6cd8]
006a6c35 : LEA ECX,[ESP + 0x24]
006a6c39 : MOV EAX,EDX
006a6c3b : CALL 0x006a5570
006a6c40 : JMP 0x006a6c6b
006a6c42 : LEA EAX,[ESP + 0x24]
006a6c46 : PUSH EAX
006a6c47 : MOV EDI,EDX
006a6c49 : CALL 0x006a5660
006a6c4e : ADD ESP,0x4
006a6c51 : JMP 0x006a6c6b
006a6c53 : LEA ECX,[ESP + 0x2c]
006a6c57 : PUSH ECX
006a6c58 : LEA EAX,[ESP + 0x28]
006a6c5c : PUSH EAX
006a6c5d : LEA EBX,[ESP + 0x3c]
006a6c61 : MOV EAX,EDX
006a6c63 : CALL 0x006a55d0
006a6c68 : ADD ESP,0x8
006a6c6b : MOV dword ptr [ESP + 0x10],EAX
006a6c6f : TEST EAX,EAX
006a6c71 : JNZ 0x006a6cad
006a6c73 : MOV dword ptr [ESP + 0x4c],EAX
006a6c77 : LEA EAX,[EBP + 0x1]
006a6c7a : CMP EAX,dword ptr [ESP + 0x50]
006a6c7e : JBE 0x006a6a14
006a6c84 : POP EDI
006a6c85 : POP ESI
006a6c86 : POP EBP
006a6c87 : MOV EAX,0x8
006a6c8c : POP EBX
006a6c8d : ADD ESP,0x34
006a6c90 : RET
006a6c91 : MOV dword ptr [ESP + 0x4c],EBP
006a6c95 : POP EDI
006a6c96 : POP ESI
006a6c97 : POP EBP
006a6c98 : MOV EAX,0x8
006a6c9d : POP EBX
006a6c9e : ADD ESP,0x34
006a6ca1 : RET
006a6ca2 : MOV ESI,EDX
006a6ca4 : CALL 0x006a56c0
006a6ca9 : MOV EAX,dword ptr [ESP + 0x10]
006a6cad : POP EDI
006a6cae : POP ESI
006a6caf : POP EBP
006a6cb0 : POP EBX
006a6cb1 : ADD ESP,0x34
006a6cb4 : RET
