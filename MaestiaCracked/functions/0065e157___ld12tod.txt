PROGRAM  : Maestia.exe
FUNCTION : __ld12tod
ENTRY    : 0065e157
BODY     : [[0065e157, 0065e69a]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    __ld12tod
   
   Library: Visual Studio 2008 Release */

INTRNCVT_STATUS __cdecl __ld12tod(_LDBL12 *_Ifp,_CRT_DOUBLE *_D)

{
  undefined4 uVar1;
  int iVar2;
  INTRNCVT_STATUS IVar3;
  int iVar4;
  byte bVar5;
  uint *puVar6;
  uint *puVar7;
  uint uVar8;
  _LDBL12 *p_Var9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  bool bVar14;
  uint local_24 [4];
  uint local_14;
  uint local_10;
  int local_c;
  _LDBL12 *local_8;
  
  local_24[3] = *(ushort *)(_Ifp->ld12 + 10) & 0x8000;
  uVar10 = *(uint *)(_Ifp->ld12 + 6);
  local_24[0] = uVar10;
  uVar1 = *(undefined4 *)(_Ifp->ld12 + 2);
  uVar11 = *(ushort *)(_Ifp->ld12 + 10) & 0x7fff;
  iVar12 = uVar11 - 0x3fff;
  iVar2 = (uint)*(ushort *)_Ifp->ld12 << 0x10;
  local_24[1] = uVar1;
  local_24[2] = iVar2;
  if (iVar12 == -0x3fff) {
    iVar12 = 0;
    iVar2 = 0;
    do {
      if (local_24[iVar2] != 0) {
        local_24[0] = 0;
        local_24[1] = 0;
        IVar3 = INTRNCVT_UNDERFLOW;
        goto LAB_0065e658;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < 3);
    IVar3 = INTRNCVT_OK;
  }
  else {
    _Ifp = (_LDBL12 *)0x0;
    iVar13 = DAT_00d683bc - 1;
    iVar4 = (int)(DAT_00d683bc + ((int)DAT_00d683bc >> 0x1f & 0x1fU)) >> 5;
    uVar8 = DAT_00d683bc & 0x8000001f;
    local_14 = iVar12;
    local_10 = iVar4;
    if ((int)uVar8 < 0) {
      uVar8 = (uVar8 - 1 | 0xffffffe0) + 1;
    }
    puVar7 = local_24 + iVar4;
    bVar5 = (byte)(0x1f - uVar8);
    local_c = 0x1f - uVar8;
    if ((*puVar7 & 1 << (bVar5 & 0x1f)) != 0) {
      uVar8 = local_24[iVar4] & ~(-1 << (bVar5 & 0x1f));
      while( true ) {
        if (uVar8 != 0) {
          iVar4 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
          local_8 = (_LDBL12 *)0x0;
          p_Var9 = (_LDBL12 *)(1 << (0x1f - ((byte)iVar13 & 0x1f) & 0x1f));
          puVar6 = local_24 + iVar4;
          _Ifp = (_LDBL12 *)(p_Var9->ld12 + *puVar6);
          if (_Ifp < (_LDBL12 *)*puVar6) goto LAB_0065e28c;
          bVar14 = _Ifp < p_Var9;
          do {
            local_8 = (_LDBL12 *)0x0;
            if (!bVar14) goto LAB_0065e293;
LAB_0065e28c:
            do {
              local_8 = (_LDBL12 *)0x1;
LAB_0065e293:
              iVar4 = iVar4 + -1;
              *puVar6 = (uint)_Ifp;
              if ((iVar4 < 0) || (local_8 == (_LDBL12 *)0x0)) {
                _Ifp = local_8;
                goto LAB_0065e2a1;
              }
              local_8 = (_LDBL12 *)0x0;
              puVar6 = local_24 + iVar4;
              _Ifp = (_LDBL12 *)(((_LDBL12 *)*puVar6)->ld12 + 1);
            } while (_Ifp < (_LDBL12 *)*puVar6);
            bVar14 = _Ifp == (_LDBL12 *)0x0;
          } while( true );
        }
        iVar4 = iVar4 + 1;
        if (2 < iVar4) break;
        uVar8 = local_24[iVar4];
      }
    }
LAB_0065e2a1:
    *puVar7 = *puVar7 & -1 << ((byte)local_c & 0x1f);
    iVar4 = local_10 + 1;
    if (iVar4 < 3) {
      puVar7 = local_24 + iVar4;
      for (iVar13 = 3 - iVar4; iVar13 != 0; iVar13 = iVar13 + -1) {
        *puVar7 = 0;
        puVar7 = puVar7 + 1;
      }
    }
    if (_Ifp != (_LDBL12 *)0x0) {
      iVar12 = uVar11 - 0x3ffe;
    }
    if (iVar12 < (int)(DAT_00d683b8 - DAT_00d683bc)) {
      local_24[0] = 0;
      local_24[1] = 0;
    }
    else {
      if (DAT_00d683b8 < iVar12) {
        if (iVar12 < DAT_00d683b4) {
          local_24[0] = local_24[0] & 0x7fffffff;
          iVar12 = iVar12 + DAT_00d683c8;
          iVar2 = (int)(DAT_00d683c0 + ((int)DAT_00d683c0 >> 0x1f & 0x1fU)) >> 5;
          uVar10 = DAT_00d683c0 & 0x8000001f;
          if ((int)uVar10 < 0) {
            uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
          }
          local_10 = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar10);
          do {
            local_14 = local_24[(int)_Ifp] & ~(-1 << ((byte)uVar10 & 0x1f));
            local_24[(int)_Ifp] = local_24[(int)_Ifp] >> ((byte)uVar10 & 0x1f) | local_10;
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_10 = local_14 << ((byte)(0x20 - uVar10) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar4 = 2;
          puVar7 = local_24 + (2 - iVar2);
          do {
            if (iVar4 < iVar2) {
              local_24[iVar4] = 0;
            }
            else {
              local_24[iVar4] = *puVar7;
            }
            iVar4 = iVar4 + -1;
            puVar7 = puVar7 + -1;
          } while (-1 < iVar4);
          IVar3 = INTRNCVT_OK;
        }
        else {
          local_24[1] = 0;
          local_24[2] = 0;
          local_24[0] = 0x80000000;
          iVar12 = (int)(DAT_00d683c0 + ((int)DAT_00d683c0 >> 0x1f & 0x1fU)) >> 5;
          uVar10 = DAT_00d683c0 & 0x8000001f;
          if ((int)uVar10 < 0) {
            uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
          }
          local_10 = 0;
          _Ifp = (_LDBL12 *)0x0;
          local_8 = (_LDBL12 *)(0x20 - uVar10);
          do {
            uVar11 = local_24[(int)_Ifp];
            local_14 = uVar11 & ~(-1 << ((byte)uVar10 & 0x1f));
            local_24[(int)_Ifp] = uVar11 >> ((byte)uVar10 & 0x1f) | local_10;
            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
            local_10 = local_14 << ((byte)(0x20 - uVar10) & 0x1f);
          } while ((int)_Ifp < 3);
          iVar2 = 2;
          puVar7 = local_24 + (2 - iVar12);
          do {
            if (iVar2 < iVar12) {
              local_24[iVar2] = 0;
            }
            else {
              local_24[iVar2] = *puVar7;
            }
            iVar2 = iVar2 + -1;
            puVar7 = puVar7 + -1;
          } while (-1 < iVar2);
          iVar12 = DAT_00d683c8 + DAT_00d683b4;
          IVar3 = INTRNCVT_OVERFLOW;
        }
        goto LAB_0065e658;
      }
      local_14 = DAT_00d683b8 - local_14;
      local_24[0] = uVar10;
      local_24[1] = uVar1;
      iVar12 = (int)(local_14 + ((int)local_14 >> 0x1f & 0x1fU)) >> 5;
      uVar10 = local_14 & 0x8000001f;
      if ((int)uVar10 < 0) {
        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
      }
      local_10 = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar10);
      do {
        uVar11 = local_24[(int)_Ifp];
        local_14 = uVar11 & ~(-1 << ((byte)uVar10 & 0x1f));
        local_24[(int)_Ifp] = uVar11 >> ((byte)uVar10 & 0x1f) | local_10;
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_10 = local_14 << ((byte)(0x20 - uVar10) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar2 = 2;
      puVar7 = local_24 + (2 - iVar12);
      do {
        if (iVar2 < iVar12) {
          local_24[iVar2] = 0;
        }
        else {
          local_24[iVar2] = *puVar7;
        }
        iVar2 = iVar2 + -1;
        puVar7 = puVar7 + -1;
      } while (-1 < iVar2);
      iVar2 = DAT_00d683bc - 1;
      iVar12 = (int)(DAT_00d683bc + ((int)DAT_00d683bc >> 0x1f & 0x1fU)) >> 5;
      uVar10 = DAT_00d683bc & 0x8000001f;
      local_10 = iVar12;
      if ((int)uVar10 < 0) {
        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
      }
      bVar5 = (byte)(0x1f - uVar10);
      puVar7 = local_24 + iVar12;
      local_14 = 0x1f - uVar10;
      if ((*puVar7 & 1 << (bVar5 & 0x1f)) != 0) {
        uVar10 = local_24[iVar12] & ~(-1 << (bVar5 & 0x1f));
        while (uVar10 == 0) {
          iVar12 = iVar12 + 1;
          if (2 < iVar12) goto LAB_0065e444;
          uVar10 = local_24[iVar12];
        }
        iVar12 = (int)(iVar2 + (iVar2 >> 0x1f & 0x1fU)) >> 5;
        bVar14 = false;
        uVar8 = 1 << (0x1f - ((byte)iVar2 & 0x1f) & 0x1f);
        uVar11 = local_24[iVar12];
        uVar10 = uVar11 + uVar8;
        if ((uVar10 < uVar11) || (uVar10 < uVar8)) {
          bVar14 = true;
        }
        local_24[iVar12] = uVar10;
        while ((iVar12 = iVar12 + -1, -1 < iVar12 && (bVar14))) {
          uVar11 = local_24[iVar12];
          uVar10 = uVar11 + 1;
          bVar14 = false;
          if ((uVar10 < uVar11) || (uVar10 == 0)) {
            bVar14 = true;
          }
          local_24[iVar12] = uVar10;
        }
      }
LAB_0065e444:
      *puVar7 = *puVar7 & -1 << ((byte)local_14 & 0x1f);
      iVar12 = local_10 + 1;
      if (iVar12 < 3) {
        puVar7 = local_24 + iVar12;
        for (iVar2 = 3 - iVar12; iVar2 != 0; iVar2 = iVar2 + -1) {
          *puVar7 = 0;
          puVar7 = puVar7 + 1;
        }
      }
      uVar10 = DAT_00d683c0 + 1;
      iVar12 = (int)(uVar10 + ((int)uVar10 >> 0x1f & 0x1fU)) >> 5;
      uVar10 = uVar10 & 0x8000001f;
      if ((int)uVar10 < 0) {
        uVar10 = (uVar10 - 1 | 0xffffffe0) + 1;
      }
      local_10 = 0;
      _Ifp = (_LDBL12 *)0x0;
      local_8 = (_LDBL12 *)(0x20 - uVar10);
      do {
        uVar11 = local_24[(int)_Ifp];
        local_14 = uVar11 & ~(-1 << ((byte)uVar10 & 0x1f));
        local_24[(int)_Ifp] = uVar11 >> ((byte)uVar10 & 0x1f) | local_10;
        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1);
        local_10 = local_14 << ((byte)(0x20 - uVar10) & 0x1f);
      } while ((int)_Ifp < 3);
      iVar2 = 2;
      puVar7 = local_24 + (2 - iVar12);
      do {
        if (iVar2 < iVar12) {
          local_24[iVar2] = 0;
        }
        else {
          local_24[iVar2] = *puVar7;
        }
        iVar2 = iVar2 + -1;
        puVar7 = puVar7 + -1;
      } while (-1 < iVar2);
    }
    iVar12 = 0;
    IVar3 = INTRNCVT_UNDERFLOW;
  }
LAB_0065e658:
  local_24[0] = iVar12 << (0x1fU - (char)DAT_00d683c0 & 0x1f) |
                -(uint)(local_24[3] != 0) & 0x80000000 | local_24[0];
  if (DAT_00d683c4 == 0x40) {
    *(uint *)((int)&_D->x + 4) = local_24[0];
    *(uint *)&_D->x = local_24[1];
  }
  else if (DAT_00d683c4 == 0x20) {
    *(uint *)&_D->x = local_24[0];
  }
  return IVar3;
}



============================================================
DISASSEMBLY
============================================================
0065e157 : MOV EDI,EDI
0065e159 : PUSH EBP
0065e15a : MOV EBP,ESP
0065e15c : SUB ESP,0x2c
0065e15f : MOV EAX,dword ptr [EBP + 0x8]
0065e162 : MOVZX ECX,word ptr [EAX + 0xa]
0065e166 : PUSH EBX
0065e167 : MOV EBX,ECX
0065e169 : AND ECX,0x8000
0065e16f : MOV dword ptr [EBP + -0x14],ECX
0065e172 : MOV ECX,dword ptr [EAX + 0x6]
0065e175 : MOV dword ptr [EBP + -0x20],ECX
0065e178 : MOV ECX,dword ptr [EAX + 0x2]
0065e17b : MOVZX EAX,word ptr [EAX]
0065e17e : AND EBX,0x7fff
0065e184 : SUB EBX,0x3fff
0065e18a : SHL EAX,0x10
0065e18d : PUSH EDI
0065e18e : MOV dword ptr [EBP + -0x1c],ECX
0065e191 : MOV dword ptr [EBP + -0x18],EAX
0065e194 : CMP EBX,0xffffc001
0065e19a : JNZ 0x0065e1c3
0065e19c : XOR EBX,EBX
0065e19e : XOR EAX,EAX
0065e1a0 : CMP dword ptr [EBP + EAX*0x4 + -0x20],EBX
0065e1a4 : JNZ 0x0065e1b3
0065e1a6 : INC EAX
0065e1a7 : CMP EAX,0x3
0065e1aa : JL 0x0065e1a0
0065e1ac : XOR EAX,EAX
0065e1ae : JMP 0x0065e658
0065e1b3 : XOR EAX,EAX
0065e1b5 : LEA EDI,[EBP + -0x20]
0065e1b8 : STOSD ES:EDI
0065e1b9 : STOSD ES:EDI
0065e1ba : PUSH 0x2
0065e1bc : STOSD ES:EDI
0065e1bd : POP EAX
0065e1be : JMP 0x0065e658
0065e1c3 : AND dword ptr [EBP + 0x8],0x0
0065e1c7 : PUSH ESI
0065e1c8 : LEA ESI,[EBP + -0x20]
0065e1cb : LEA EDI,[EBP + -0x2c]
0065e1ce : MOVSD ES:EDI,ESI
0065e1cf : MOVSD ES:EDI,ESI
0065e1d0 : MOVSD ES:EDI,ESI
0065e1d1 : MOV ESI,dword ptr [0x00d683bc]
0065e1d7 : DEC ESI
0065e1d8 : LEA ECX,[ESI + 0x1]
0065e1db : MOV EAX,ECX
0065e1dd : CDQ
0065e1de : AND EDX,0x1f
0065e1e1 : ADD EAX,EDX
0065e1e3 : SAR EAX,0x5
0065e1e6 : MOV EDX,ECX
0065e1e8 : AND EDX,0x8000001f
0065e1ee : MOV dword ptr [EBP + -0x10],EBX
0065e1f1 : MOV dword ptr [EBP + -0xc],EAX
0065e1f4 : JNS 0x0065e1fb
0065e1f6 : DEC EDX
0065e1f7 : OR EDX,0xffffffe0
0065e1fa : INC EDX
0065e1fb : LEA EDI,[EBP + EAX*0x4 + -0x20]
0065e1ff : PUSH 0x1f
0065e201 : XOR EAX,EAX
0065e203 : POP ECX
0065e204 : SUB ECX,EDX
0065e206 : INC EAX
0065e207 : SHL EAX,CL
0065e209 : MOV dword ptr [EBP + -0x8],ECX
0065e20c : TEST dword ptr [EDI],EAX
0065e20e : JZ 0x0065e2a1
0065e214 : MOV EAX,dword ptr [EBP + -0xc]
0065e217 : OR EDX,0xffffffff
0065e21a : SHL EDX,CL
0065e21c : NOT EDX
0065e21e : TEST dword ptr [EBP + EAX*0x4 + -0x20],EDX
0065e222 : JMP 0x0065e229
0065e224 : CMP dword ptr [EBP + EAX*0x4 + -0x20],0x0
0065e229 : JNZ 0x0065e233
0065e22b : INC EAX
0065e22c : CMP EAX,0x3
0065e22f : JL 0x0065e224
0065e231 : JMP 0x0065e2a1
0065e233 : MOV EAX,ESI
0065e235 : CDQ
0065e236 : PUSH 0x1f
0065e238 : POP ECX
0065e239 : AND EDX,ECX
0065e23b : ADD EAX,EDX
0065e23d : SAR EAX,0x5
0065e240 : AND ESI,0x8000001f
0065e246 : JNS 0x0065e24d
0065e248 : DEC ESI
0065e249 : OR ESI,0xffffffe0
0065e24c : INC ESI
0065e24d : AND dword ptr [EBP + -0x4],0x0
0065e251 : SUB ECX,ESI
0065e253 : XOR EDX,EDX
0065e255 : INC EDX
0065e256 : SHL EDX,CL
0065e258 : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e25c : MOV ESI,dword ptr [ECX]
0065e25e : ADD ESI,EDX
0065e260 : MOV dword ptr [EBP + 0x8],ESI
0065e263 : MOV ESI,dword ptr [ECX]
0065e265 : CMP dword ptr [EBP + 0x8],ESI
0065e268 : JC 0x0065e28c
0065e26a : CMP dword ptr [EBP + 0x8],EDX
0065e26d : JMP 0x0065e28a
0065e26f : TEST ECX,ECX
0065e271 : JZ 0x0065e29e
0065e273 : AND dword ptr [EBP + -0x4],0x0
0065e277 : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e27b : MOV EDX,dword ptr [ECX]
0065e27d : LEA ESI,[EDX + 0x1]
0065e280 : MOV dword ptr [EBP + 0x8],ESI
0065e283 : CMP ESI,EDX
0065e285 : JC 0x0065e28c
0065e287 : CMP ESI,0x1
0065e28a : JNC 0x0065e293
0065e28c : MOV dword ptr [EBP + -0x4],0x1
0065e293 : DEC EAX
0065e294 : MOV EDX,dword ptr [EBP + 0x8]
0065e297 : MOV dword ptr [ECX],EDX
0065e299 : MOV ECX,dword ptr [EBP + -0x4]
0065e29c : JNS 0x0065e26f
0065e29e : MOV dword ptr [EBP + 0x8],ECX
0065e2a1 : MOV ECX,dword ptr [EBP + -0x8]
0065e2a4 : OR EAX,0xffffffff
0065e2a7 : SHL EAX,CL
0065e2a9 : AND dword ptr [EDI],EAX
0065e2ab : MOV EAX,dword ptr [EBP + -0xc]
0065e2ae : INC EAX
0065e2af : CMP EAX,0x3
0065e2b2 : JGE 0x0065e2c1
0065e2b4 : PUSH 0x3
0065e2b6 : POP ECX
0065e2b7 : LEA EDI,[EBP + EAX*0x4 + -0x20]
0065e2bb : SUB ECX,EAX
0065e2bd : XOR EAX,EAX
0065e2bf : STOSD.REP ES:EDI
0065e2c1 : CMP dword ptr [EBP + 0x8],0x0
0065e2c5 : JZ 0x0065e2c8
0065e2c7 : INC EBX
0065e2c8 : MOV EAX,[0x00d683b8]
0065e2cd : MOV ECX,EAX
0065e2cf : SUB ECX,dword ptr [0x00d683bc]
0065e2d5 : CMP EBX,ECX
0065e2d7 : JGE 0x0065e2e6
0065e2d9 : XOR EAX,EAX
0065e2db : LEA EDI,[EBP + -0x20]
0065e2de : STOSD ES:EDI
0065e2df : STOSD ES:EDI
0065e2e0 : STOSD ES:EDI
0065e2e1 : JMP 0x0065e4f3
0065e2e6 : CMP EBX,EAX
0065e2e8 : JG 0x0065e4fd
0065e2ee : SUB EAX,dword ptr [EBP + -0x10]
0065e2f1 : LEA ESI,[EBP + -0x2c]
0065e2f4 : MOV ECX,EAX
0065e2f6 : LEA EDI,[EBP + -0x20]
0065e2f9 : MOVSD ES:EDI,ESI
0065e2fa : CDQ
0065e2fb : AND EDX,0x1f
0065e2fe : ADD EAX,EDX
0065e300 : MOVSD ES:EDI,ESI
0065e301 : MOV EDX,ECX
0065e303 : SAR EAX,0x5
0065e306 : AND EDX,0x8000001f
0065e30c : MOVSD ES:EDI,ESI
0065e30d : JNS 0x0065e314
0065e30f : DEC EDX
0065e310 : OR EDX,0xffffffe0
0065e313 : INC EDX
0065e314 : AND dword ptr [EBP + -0xc],0x0
0065e318 : AND dword ptr [EBP + 0x8],0x0
0065e31c : OR EDI,0xffffffff
0065e31f : MOV ECX,EDX
0065e321 : SHL EDI,CL
0065e323 : MOV dword ptr [EBP + -0x4],0x20
0065e32a : SUB dword ptr [EBP + -0x4],EDX
0065e32d : NOT EDI
0065e32f : MOV EBX,dword ptr [EBP + 0x8]
0065e332 : LEA EBX,[EBP + EBX*0x4 + -0x20]
0065e336 : MOV ESI,dword ptr [EBX]
0065e338 : MOV ECX,ESI
0065e33a : AND ECX,EDI
0065e33c : MOV dword ptr [EBP + -0x10],ECX
0065e33f : MOV ECX,EDX
0065e341 : SHR ESI,CL
0065e343 : MOV ECX,dword ptr [EBP + -0x4]
0065e346 : OR ESI,dword ptr [EBP + -0xc]
0065e349 : MOV dword ptr [EBX],ESI
0065e34b : MOV ESI,dword ptr [EBP + -0x10]
0065e34e : SHL ESI,CL
0065e350 : INC dword ptr [EBP + 0x8]
0065e353 : CMP dword ptr [EBP + 0x8],0x3
0065e357 : MOV dword ptr [EBP + -0xc],ESI
0065e35a : JL 0x0065e32f
0065e35c : MOV ESI,EAX
0065e35e : PUSH 0x2
0065e360 : SHL ESI,0x2
0065e363 : LEA ECX,[EBP + -0x18]
0065e366 : POP EDX
0065e367 : SUB ECX,ESI
0065e369 : CMP EDX,EAX
0065e36b : JL 0x0065e375
0065e36d : MOV ESI,dword ptr [ECX]
0065e36f : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065e373 : JMP 0x0065e37a
0065e375 : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065e37a : DEC EDX
0065e37b : SUB ECX,0x4
0065e37e : TEST EDX,EDX
0065e380 : JGE 0x0065e369
0065e382 : MOV ESI,dword ptr [0x00d683bc]
0065e388 : DEC ESI
0065e389 : LEA ECX,[ESI + 0x1]
0065e38c : MOV EAX,ECX
0065e38e : CDQ
0065e38f : AND EDX,0x1f
0065e392 : ADD EAX,EDX
0065e394 : SAR EAX,0x5
0065e397 : MOV EDX,ECX
0065e399 : AND EDX,0x8000001f
0065e39f : MOV dword ptr [EBP + -0xc],EAX
0065e3a2 : JNS 0x0065e3a9
0065e3a4 : DEC EDX
0065e3a5 : OR EDX,0xffffffe0
0065e3a8 : INC EDX
0065e3a9 : PUSH 0x1f
0065e3ab : POP ECX
0065e3ac : SUB ECX,EDX
0065e3ae : XOR EDX,EDX
0065e3b0 : INC EDX
0065e3b1 : SHL EDX,CL
0065e3b3 : LEA EBX,[EBP + EAX*0x4 + -0x20]
0065e3b7 : MOV dword ptr [EBP + -0x10],ECX
0065e3ba : TEST dword ptr [EBX],EDX
0065e3bc : JZ 0x0065e444
0065e3c2 : OR EDX,0xffffffff
0065e3c5 : SHL EDX,CL
0065e3c7 : NOT EDX
0065e3c9 : TEST dword ptr [EBP + EAX*0x4 + -0x20],EDX
0065e3cd : JMP 0x0065e3d4
0065e3cf : CMP dword ptr [EBP + EAX*0x4 + -0x20],0x0
0065e3d4 : JNZ 0x0065e3de
0065e3d6 : INC EAX
0065e3d7 : CMP EAX,0x3
0065e3da : JL 0x0065e3cf
0065e3dc : JMP 0x0065e444
0065e3de : MOV EAX,ESI
0065e3e0 : CDQ
0065e3e1 : PUSH 0x1f
0065e3e3 : POP ECX
0065e3e4 : AND EDX,ECX
0065e3e6 : ADD EAX,EDX
0065e3e8 : SAR EAX,0x5
0065e3eb : AND ESI,0x8000001f
0065e3f1 : JNS 0x0065e3f8
0065e3f3 : DEC ESI
0065e3f4 : OR ESI,0xffffffe0
0065e3f7 : INC ESI
0065e3f8 : AND dword ptr [EBP + 0x8],0x0
0065e3fc : XOR EDX,EDX
0065e3fe : SUB ECX,ESI
0065e400 : INC EDX
0065e401 : SHL EDX,CL
0065e403 : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e407 : MOV ESI,dword ptr [ECX]
0065e409 : LEA EDI,[ESI + EDX*0x1]
0065e40c : CMP EDI,ESI
0065e40e : JC 0x0065e414
0065e410 : CMP EDI,EDX
0065e412 : JNC 0x0065e41b
0065e414 : MOV dword ptr [EBP + 0x8],0x1
0065e41b : MOV dword ptr [ECX],EDI
0065e41d : MOV ECX,dword ptr [EBP + 0x8]
0065e420 : JMP 0x0065e441
0065e422 : TEST ECX,ECX
0065e424 : JZ 0x0065e444
0065e426 : LEA ECX,[EBP + EAX*0x4 + -0x20]
0065e42a : MOV EDX,dword ptr [ECX]
0065e42c : LEA ESI,[EDX + 0x1]
0065e42f : XOR EDI,EDI
0065e431 : CMP ESI,EDX
0065e433 : JC 0x0065e43a
0065e435 : CMP ESI,0x1
0065e438 : JNC 0x0065e43d
0065e43a : XOR EDI,EDI
0065e43c : INC EDI
0065e43d : MOV dword ptr [ECX],ESI
0065e43f : MOV ECX,EDI
0065e441 : DEC EAX
0065e442 : JNS 0x0065e422
0065e444 : MOV ECX,dword ptr [EBP + -0x10]
0065e447 : OR EAX,0xffffffff
0065e44a : SHL EAX,CL
0065e44c : AND dword ptr [EBX],EAX
0065e44e : MOV EAX,dword ptr [EBP + -0xc]
0065e451 : INC EAX
0065e452 : CMP EAX,0x3
0065e455 : JGE 0x0065e464
0065e457 : PUSH 0x3
0065e459 : POP ECX
0065e45a : LEA EDI,[EBP + EAX*0x4 + -0x20]
0065e45e : SUB ECX,EAX
0065e460 : XOR EAX,EAX
0065e462 : STOSD.REP ES:EDI
0065e464 : MOV ECX,dword ptr [0x00d683c0]
0065e46a : INC ECX
0065e46b : MOV EAX,ECX
0065e46d : CDQ
0065e46e : AND EDX,0x1f
0065e471 : ADD EAX,EDX
0065e473 : MOV EDX,ECX
0065e475 : SAR EAX,0x5
0065e478 : AND EDX,0x8000001f
0065e47e : JNS 0x0065e485
0065e480 : DEC EDX
0065e481 : OR EDX,0xffffffe0
0065e484 : INC EDX
0065e485 : AND dword ptr [EBP + -0xc],0x0
0065e489 : AND dword ptr [EBP + 0x8],0x0
0065e48d : OR EDI,0xffffffff
0065e490 : MOV ECX,EDX
0065e492 : SHL EDI,CL
0065e494 : MOV dword ptr [EBP + -0x4],0x20
0065e49b : SUB dword ptr [EBP + -0x4],EDX
0065e49e : NOT EDI
0065e4a0 : MOV EBX,dword ptr [EBP + 0x8]
0065e4a3 : LEA EBX,[EBP + EBX*0x4 + -0x20]
0065e4a7 : MOV ESI,dword ptr [EBX]
0065e4a9 : MOV ECX,ESI
0065e4ab : AND ECX,EDI
0065e4ad : MOV dword ptr [EBP + -0x10],ECX
0065e4b0 : MOV ECX,EDX
0065e4b2 : SHR ESI,CL
0065e4b4 : MOV ECX,dword ptr [EBP + -0x4]
0065e4b7 : OR ESI,dword ptr [EBP + -0xc]
0065e4ba : MOV dword ptr [EBX],ESI
0065e4bc : MOV ESI,dword ptr [EBP + -0x10]
0065e4bf : SHL ESI,CL
0065e4c1 : INC dword ptr [EBP + 0x8]
0065e4c4 : CMP dword ptr [EBP + 0x8],0x3
0065e4c8 : MOV dword ptr [EBP + -0xc],ESI
0065e4cb : JL 0x0065e4a0
0065e4cd : MOV ESI,EAX
0065e4cf : PUSH 0x2
0065e4d1 : SHL ESI,0x2
0065e4d4 : LEA ECX,[EBP + -0x18]
0065e4d7 : POP EDX
0065e4d8 : SUB ECX,ESI
0065e4da : CMP EDX,EAX
0065e4dc : JL 0x0065e4e6
0065e4de : MOV ESI,dword ptr [ECX]
0065e4e0 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065e4e4 : JMP 0x0065e4eb
0065e4e6 : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065e4eb : DEC EDX
0065e4ec : SUB ECX,0x4
0065e4ef : TEST EDX,EDX
0065e4f1 : JGE 0x0065e4da
0065e4f3 : PUSH 0x2
0065e4f5 : XOR EBX,EBX
0065e4f7 : POP EAX
0065e4f8 : JMP 0x0065e657
0065e4fd : CMP EBX,dword ptr [0x00d683b4]
0065e503 : MOV ECX,dword ptr [0x00d683c0]
0065e509 : JL 0x0065e5bc
0065e50f : XOR EAX,EAX
0065e511 : LEA EDI,[EBP + -0x20]
0065e514 : STOSD ES:EDI
0065e515 : STOSD ES:EDI
0065e516 : STOSD ES:EDI
0065e517 : OR dword ptr [EBP + -0x20],0x80000000
0065e51e : MOV EAX,ECX
0065e520 : CDQ
0065e521 : AND EDX,0x1f
0065e524 : ADD EAX,EDX
0065e526 : MOV EDX,ECX
0065e528 : SAR EAX,0x5
0065e52b : AND EDX,0x8000001f
0065e531 : JNS 0x0065e538
0065e533 : DEC EDX
0065e534 : OR EDX,0xffffffe0
0065e537 : INC EDX
0065e538 : AND dword ptr [EBP + -0xc],0x0
0065e53c : AND dword ptr [EBP + 0x8],0x0
0065e540 : OR EDI,0xffffffff
0065e543 : MOV ECX,EDX
0065e545 : SHL EDI,CL
0065e547 : MOV dword ptr [EBP + -0x4],0x20
0065e54e : SUB dword ptr [EBP + -0x4],EDX
0065e551 : NOT EDI
0065e553 : MOV EBX,dword ptr [EBP + 0x8]
0065e556 : LEA EBX,[EBP + EBX*0x4 + -0x20]
0065e55a : MOV ESI,dword ptr [EBX]
0065e55c : MOV ECX,ESI
0065e55e : AND ECX,EDI
0065e560 : MOV dword ptr [EBP + -0x10],ECX
0065e563 : MOV ECX,EDX
0065e565 : SHR ESI,CL
0065e567 : MOV ECX,dword ptr [EBP + -0x4]
0065e56a : OR ESI,dword ptr [EBP + -0xc]
0065e56d : MOV dword ptr [EBX],ESI
0065e56f : MOV ESI,dword ptr [EBP + -0x10]
0065e572 : SHL ESI,CL
0065e574 : INC dword ptr [EBP + 0x8]
0065e577 : CMP dword ptr [EBP + 0x8],0x3
0065e57b : MOV dword ptr [EBP + -0xc],ESI
0065e57e : JL 0x0065e553
0065e580 : MOV ESI,EAX
0065e582 : PUSH 0x2
0065e584 : SHL ESI,0x2
0065e587 : LEA ECX,[EBP + -0x18]
0065e58a : POP EDX
0065e58b : SUB ECX,ESI
0065e58d : CMP EDX,EAX
0065e58f : JL 0x0065e599
0065e591 : MOV ESI,dword ptr [ECX]
0065e593 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065e597 : JMP 0x0065e59e
0065e599 : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065e59e : DEC EDX
0065e59f : SUB ECX,0x4
0065e5a2 : TEST EDX,EDX
0065e5a4 : JGE 0x0065e58d
0065e5a6 : MOV EAX,[0x00d683b4]
0065e5ab : MOV ECX,dword ptr [0x00d683c8]
0065e5b1 : LEA EBX,[ECX + EAX*0x1]
0065e5b4 : XOR EAX,EAX
0065e5b6 : INC EAX
0065e5b7 : JMP 0x0065e657
0065e5bc : MOV EAX,[0x00d683c8]
0065e5c1 : AND dword ptr [EBP + -0x20],0x7fffffff
0065e5c8 : ADD EBX,EAX
0065e5ca : MOV EAX,ECX
0065e5cc : CDQ
0065e5cd : AND EDX,0x1f
0065e5d0 : ADD EAX,EDX
0065e5d2 : MOV EDX,ECX
0065e5d4 : SAR EAX,0x5
0065e5d7 : AND EDX,0x8000001f
0065e5dd : JNS 0x0065e5e4
0065e5df : DEC EDX
0065e5e0 : OR EDX,0xffffffe0
0065e5e3 : INC EDX
0065e5e4 : AND dword ptr [EBP + -0xc],0x0
0065e5e8 : AND dword ptr [EBP + 0x8],0x0
0065e5ec : OR ESI,0xffffffff
0065e5ef : MOV ECX,EDX
0065e5f1 : SHL ESI,CL
0065e5f3 : MOV dword ptr [EBP + -0x4],0x20
0065e5fa : SUB dword ptr [EBP + -0x4],EDX
0065e5fd : NOT ESI
0065e5ff : MOV ECX,dword ptr [EBP + 0x8]
0065e602 : MOV EDI,dword ptr [EBP + ECX*0x4 + -0x20]
0065e606 : MOV ECX,EDI
0065e608 : AND ECX,ESI
0065e60a : MOV dword ptr [EBP + -0x10],ECX
0065e60d : MOV ECX,EDX
0065e60f : SHR EDI,CL
0065e611 : MOV ECX,dword ptr [EBP + 0x8]
0065e614 : OR EDI,dword ptr [EBP + -0xc]
0065e617 : MOV dword ptr [EBP + ECX*0x4 + -0x20],EDI
0065e61b : MOV EDI,dword ptr [EBP + -0x10]
0065e61e : MOV ECX,dword ptr [EBP + -0x4]
0065e621 : SHL EDI,CL
0065e623 : INC dword ptr [EBP + 0x8]
0065e626 : CMP dword ptr [EBP + 0x8],0x3
0065e62a : MOV dword ptr [EBP + -0xc],EDI
0065e62d : JL 0x0065e5ff
0065e62f : MOV ESI,EAX
0065e631 : PUSH 0x2
0065e633 : SHL ESI,0x2
0065e636 : LEA ECX,[EBP + -0x18]
0065e639 : POP EDX
0065e63a : SUB ECX,ESI
0065e63c : CMP EDX,EAX
0065e63e : JL 0x0065e648
0065e640 : MOV ESI,dword ptr [ECX]
0065e642 : MOV dword ptr [EBP + EDX*0x4 + -0x20],ESI
0065e646 : JMP 0x0065e64d
0065e648 : AND dword ptr [EBP + EDX*0x4 + -0x20],0x0
0065e64d : DEC EDX
0065e64e : SUB ECX,0x4
0065e651 : TEST EDX,EDX
0065e653 : JGE 0x0065e63c
0065e655 : XOR EAX,EAX
0065e657 : POP ESI
0065e658 : PUSH 0x1f
0065e65a : POP ECX
0065e65b : SUB ECX,dword ptr [0x00d683c0]
0065e661 : SHL EBX,CL
0065e663 : MOV ECX,dword ptr [EBP + -0x14]
0065e666 : NEG ECX
0065e668 : SBB ECX,ECX
0065e66a : AND ECX,0x80000000
0065e670 : OR EBX,ECX
0065e672 : MOV ECX,dword ptr [0x00d683c4]
0065e678 : OR EBX,dword ptr [EBP + -0x20]
0065e67b : CMP ECX,0x40
0065e67e : JNZ 0x0065e68d
0065e680 : MOV ECX,dword ptr [EBP + 0xc]
0065e683 : MOV EDX,dword ptr [EBP + -0x1c]
0065e686 : MOV dword ptr [ECX + 0x4],EBX
0065e689 : MOV dword ptr [ECX],EDX
0065e68b : JMP 0x0065e697
0065e68d : CMP ECX,0x20
0065e690 : JNZ 0x0065e697
0065e692 : MOV ECX,dword ptr [EBP + 0xc]
0065e695 : MOV dword ptr [ECX],EBX
0065e697 : POP EDI
0065e698 : POP EBX
0065e699 : LEAVE
0065e69a : RET
