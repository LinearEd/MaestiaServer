PROGRAM  : Maestia.exe
FUNCTION : FUN_005ae280
ENTRY    : 005ae280
BODY     : [[005ae280, 005ae4f3]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_005ae280(void)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  uint3 uVar4;
  int in_ECX;
  int iVar5;
  uint uVar6;
  void *_Dst;
  char *pcVar7;
  bool bVar8;
  
  if (*(char *)(in_ECX + 8) == '\0') {
    puVar1 = (uint *)(in_ECX + 0x10);
    if (((*(byte *)(in_ECX + 0x10) & 0x1f) != 0) ||
       (*(int *)(in_ECX + 0x28) != 0 || *(int *)(in_ECX + 0x2c) != 0)) {
      if ((*(byte *)(in_ECX + 0x20) & 2) == 0) {
        if ((*(byte *)(in_ECX + 0x20) & 1) == 0) {
          uVar3 = *(uint *)(in_ECX + 0x1c);
          iVar2 = *(int *)(in_ECX + 0x28);
        }
        else {
          iVar2 = *(int *)(in_ECX + 0x28);
          if (iVar2 < 0) {
            iVar2 = -iVar2;
          }
          uVar3 = *(uint *)(in_ECX + 0x1c);
        }
        FUN_005adb40(in_ECX + 0x30,iVar2,1,uVar3 & 0x1f);
      }
      else {
        iVar2 = *(int *)(in_ECX + 0x2c);
        iVar5 = *(int *)(in_ECX + 0x28);
        if (iVar2 < 0) {
          bVar8 = iVar5 != 0;
          iVar5 = -iVar5;
          iVar2 = -(iVar2 + (uint)bVar8);
        }
        FUN_005ada90(in_ECX + 0x30,iVar5,iVar2,1,*(uint *)(in_ECX + 0x1c) & 0x1f);
      }
    }
    uVar3 = (in_ECX - *(int *)(in_ECX + 0x18)) + 0x4c;
    if (uVar3 < (*puVar1 & 0x1f)) {
      do {
        *(int *)(in_ECX + 0x18) = *(int *)(in_ECX + 0x18) + -1;
        **(undefined1 **)(in_ECX + 0x18) = 0x30;
        uVar3 = uVar3 + 1;
      } while (uVar3 < (*puVar1 & 0x1f));
    }
    if (((*(byte *)puVar1 & 0x1f) == 0) ||
       (uVar3 = *(uint *)(in_ECX + 0x28) | *(uint *)(in_ECX + 0x2c), uVar3 == 0)) {
      *(byte *)(in_ECX + 0x14) = *(byte *)(in_ECX + 0x14) & 0xa0 | 0x20;
    }
    uVar6 = *(uint *)(in_ECX + 0x1c) & 0x1f;
    if (uVar6 == 10) {
      if ((*(byte *)(in_ECX + 0x14) & 0x7f) == 0x30) {
        uVar3 = (in_ECX - *(int *)(in_ECX + 0x18)) + 0x4c;
        while( true ) {
          if (((*(byte *)(in_ECX + 0x15) & 0x80) == 0) && ((*(byte *)(in_ECX + 0x16) & 2) == 0)) {
            iVar2 = 0;
          }
          else {
            iVar2 = 1;
          }
          if ((*puVar1 >> 5 & 0x1f) - iVar2 <= uVar3) break;
          *(int *)(in_ECX + 0x18) = *(int *)(in_ECX + 0x18) + -1;
          **(char **)(in_ECX + 0x18) = (char)(*(char *)(in_ECX + 0x14) * '\x02') >> 1;
          uVar3 = uVar3 + 1;
        }
      }
      uVar4 = (uint3)(uVar3 >> 8);
      if ((*(int *)(in_ECX + 0x2c) < 1) && (*(int *)(in_ECX + 0x2c) < 0)) {
        FUN_005adbe0(CONCAT31(uVar4,1));
      }
      else {
        FUN_005adbe0((uint)uVar4 << 8);
      }
    }
    else if ((((uVar6 == 8) || (uVar6 == 0x10)) &&
             (*(int *)(in_ECX + 0x28) != 0 || *(int *)(in_ECX + 0x2c) != 0)) &&
            ((*(byte *)(in_ECX + 0x16) & 8) != 0)) {
      if (uVar6 == 0x10) {
        *(int *)(in_ECX + 0x18) = *(int *)(in_ECX + 0x18) + -1;
        **(byte **)(in_ECX + 0x18) = (~*(byte *)(in_ECX + 0x16) & 1) << 5 | 0x58;
      }
      *(int *)(in_ECX + 0x18) = *(int *)(in_ECX + 0x18) + -1;
      **(undefined1 **)(in_ECX + 0x18) = 0x30;
    }
    if (((((*(byte *)(in_ECX + 0x16) & 2) != 0) && ((*(byte *)(in_ECX + 0x15) & 0x80) == 0)) &&
        (*(byte *)(in_ECX + 0x14) = *(byte *)(in_ECX + 0x14) & 0xa0 | 0x20,
        (*(byte *)(in_ECX + 0x20) & 1) != 0)) && (-1 < *(int *)(in_ECX + 0x2c))) {
      *(int *)(in_ECX + 0x18) = *(int *)(in_ECX + 0x18) + -1;
      **(undefined1 **)(in_ECX + 0x18) = 0x20;
    }
    uVar3 = (in_ECX - (int)*(void **)(in_ECX + 0x18)) + 0x4c;
    if ((*(byte *)(in_ECX + 0x16) & 4) == 0) {
      if (uVar3 < (*puVar1 >> 5 & 0x1f)) {
        do {
          *(int *)(in_ECX + 0x18) = *(int *)(in_ECX + 0x18) + -1;
          if (((byte)*(undefined4 *)(in_ECX + 0x1c) & 0x1f) == 10) {
            **(char **)(in_ECX + 0x18) = ' ';
          }
          else {
            **(char **)(in_ECX + 0x18) = (char)(*(char *)(in_ECX + 0x14) * '\x02') >> 1;
          }
          uVar3 = uVar3 + 1;
        } while (uVar3 < (*puVar1 >> 5 & 0x1f));
      }
    }
    else {
      uVar6 = *puVar1 >> 5 & 0x1f;
      if (uVar3 < uVar6) {
        _Dst = (void *)((in_ECX - uVar6) + 0x4c);
        _memmove(_Dst,*(void **)(in_ECX + 0x18),uVar3);
        *(void **)(in_ECX + 0x18) = _Dst;
        pcVar7 = (char *)((int)_Dst + uVar3);
        if (uVar3 < (*puVar1 >> 5 & 0x1f)) {
          do {
            if (((byte)*(undefined4 *)(in_ECX + 0x1c) & 0x1f) == 10) {
              *pcVar7 = ' ';
            }
            else {
              *pcVar7 = (char)(*(char *)(in_ECX + 0x14) * '\x02') >> 1;
            }
            uVar3 = uVar3 + 1;
            pcVar7 = pcVar7 + 1;
          } while (uVar3 < (*puVar1 >> 5 & 0x1f));
          *(undefined1 *)(in_ECX + 8) = 1;
          return;
        }
      }
    }
    *(undefined1 *)(in_ECX + 8) = 1;
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
005ae280 : PUSH ESI
005ae281 : MOV ESI,ECX
005ae283 : CMP byte ptr [ESI + 0x8],0x0
005ae287 : JNZ 0x005ae4f2
005ae28d : TEST byte ptr [ESI + 0x10],0x1f
005ae291 : PUSH EBX
005ae292 : LEA EBX,[ESI + 0x10]
005ae295 : PUSH EBP
005ae296 : PUSH EDI
005ae297 : JNZ 0x005ae2a1
005ae299 : MOV EAX,dword ptr [ESI + 0x28]
005ae29c : OR EAX,dword ptr [ESI + 0x2c]
005ae29f : JZ 0x005ae308
005ae2a1 : MOV AL,byte ptr [ESI + 0x20]
005ae2a4 : TEST AL,0x2
005ae2a6 : JZ 0x005ae2d7
005ae2a8 : MOV EAX,dword ptr [ESI + 0x2c]
005ae2ab : MOV ECX,dword ptr [ESI + 0x28]
005ae2ae : TEST EAX,EAX
005ae2b0 : JL 0x005ae2b8
005ae2b2 : JG 0x005ae2bf
005ae2b4 : TEST ECX,ECX
005ae2b6 : JNC 0x005ae2bf
005ae2b8 : NEG ECX
005ae2ba : ADC EAX,0x0
005ae2bd : NEG EAX
005ae2bf : MOV EDX,dword ptr [ESI + 0x1c]
005ae2c2 : AND EDX,0x1f
005ae2c5 : PUSH EDX
005ae2c6 : PUSH 0x1
005ae2c8 : PUSH EAX
005ae2c9 : PUSH ECX
005ae2ca : LEA EAX,[ESI + 0x30]
005ae2cd : PUSH EAX
005ae2ce : MOV ECX,EBX
005ae2d0 : CALL 0x005ada90
005ae2d5 : JMP 0x005ae308
005ae2d7 : TEST AL,0x1
005ae2d9 : JZ 0x005ae2f0
005ae2db : MOV EAX,dword ptr [ESI + 0x28]
005ae2de : TEST EAX,EAX
005ae2e0 : JGE 0x005ae2e4
005ae2e2 : NEG EAX
005ae2e4 : MOV ECX,dword ptr [ESI + 0x1c]
005ae2e7 : AND ECX,0x1f
005ae2ea : PUSH ECX
005ae2eb : PUSH 0x1
005ae2ed : PUSH EAX
005ae2ee : JMP 0x005ae2fd
005ae2f0 : MOV EAX,dword ptr [ESI + 0x1c]
005ae2f3 : MOV ECX,dword ptr [ESI + 0x28]
005ae2f6 : AND EAX,0x1f
005ae2f9 : PUSH EAX
005ae2fa : PUSH 0x1
005ae2fc : PUSH ECX
005ae2fd : LEA EDX,[ESI + 0x30]
005ae300 : PUSH EDX
005ae301 : MOV ECX,EBX
005ae303 : CALL 0x005adb40
005ae308 : MOV ECX,dword ptr [EBX]
005ae30a : MOV EAX,ESI
005ae30c : SUB EAX,dword ptr [ESI + 0x18]
005ae30f : AND ECX,0x1f
005ae312 : ADD EAX,0x4c
005ae315 : OR EDI,0xffffffff
005ae318 : CMP EAX,ECX
005ae31a : JNC 0x005ae333
005ae31c : LEA ESP,[ESP]
005ae320 : ADD dword ptr [ESI + 0x18],EDI
005ae323 : MOV ECX,dword ptr [ESI + 0x18]
005ae326 : MOV byte ptr [ECX],0x30
005ae329 : MOV EDX,dword ptr [EBX]
005ae32b : INC EAX
005ae32c : AND EDX,0x1f
005ae32f : CMP EAX,EDX
005ae331 : JC 0x005ae320
005ae333 : TEST byte ptr [EBX],0x1f
005ae336 : JZ 0x005ae340
005ae338 : MOV EAX,dword ptr [ESI + 0x28]
005ae33b : OR EAX,dword ptr [ESI + 0x2c]
005ae33e : JNZ 0x005ae34c
005ae340 : MOV CL,byte ptr [ESI + 0x14]
005ae343 : AND CL,0xa0
005ae346 : OR CL,0x20
005ae349 : MOV byte ptr [ESI + 0x14],CL
005ae34c : MOV ECX,dword ptr [ESI + 0x1c]
005ae34f : AND ECX,0x1f
005ae352 : CMP ECX,0xa
005ae355 : JNZ 0x005ae3cb
005ae357 : MOV DL,byte ptr [ESI + 0x14]
005ae35a : AND DL,0x7f
005ae35d : CMP DL,0x30
005ae360 : JNZ 0x005ae3a5
005ae362 : MOV EAX,ESI
005ae364 : SUB EAX,dword ptr [ESI + 0x18]
005ae367 : ADD EAX,0x4c
005ae36a : LEA EBX,[EBX]
005ae370 : TEST byte ptr [ESI + 0x15],0x80
005ae374 : JNZ 0x005ae380
005ae376 : TEST byte ptr [ESI + 0x16],0x2
005ae37a : JNZ 0x005ae380
005ae37c : XOR ECX,ECX
005ae37e : JMP 0x005ae385
005ae380 : MOV ECX,0x1
005ae385 : MOV EDX,dword ptr [EBX]
005ae387 : SHR EDX,0x5
005ae38a : AND EDX,0x1f
005ae38d : SUB EDX,ECX
005ae38f : CMP EAX,EDX
005ae391 : JNC 0x005ae3a5
005ae393 : MOV DL,byte ptr [ESI + 0x14]
005ae396 : ADD dword ptr [ESI + 0x18],EDI
005ae399 : MOV ECX,dword ptr [ESI + 0x18]
005ae39c : ADD DL,DL
005ae39e : SAR DL,0x1
005ae3a0 : MOV byte ptr [ECX],DL
005ae3a2 : INC EAX
005ae3a3 : JMP 0x005ae370
005ae3a5 : CMP dword ptr [ESI + 0x2c],0x0
005ae3a9 : JG 0x005ae3bf
005ae3ab : JL 0x005ae3b3
005ae3ad : CMP dword ptr [ESI + 0x28],0x0
005ae3b1 : JNC 0x005ae3bf
005ae3b3 : MOV AL,0x1
005ae3b5 : MOV ECX,ESI
005ae3b7 : PUSH EAX
005ae3b8 : CALL 0x005adbe0
005ae3bd : JMP 0x005ae403
005ae3bf : XOR AL,AL
005ae3c1 : MOV ECX,ESI
005ae3c3 : PUSH EAX
005ae3c4 : CALL 0x005adbe0
005ae3c9 : JMP 0x005ae403
005ae3cb : CMP ECX,0x8
005ae3ce : JZ 0x005ae3d5
005ae3d0 : CMP ECX,0x10
005ae3d3 : JNZ 0x005ae403
005ae3d5 : MOV EAX,dword ptr [ESI + 0x28]
005ae3d8 : OR EAX,dword ptr [ESI + 0x2c]
005ae3db : JZ 0x005ae403
005ae3dd : MOV AL,byte ptr [ESI + 0x16]
005ae3e0 : TEST AL,0x8
005ae3e2 : JZ 0x005ae403
005ae3e4 : CMP ECX,0x10
005ae3e7 : JNZ 0x005ae3fa
005ae3e9 : ADD dword ptr [ESI + 0x18],EDI
005ae3ec : MOV ECX,dword ptr [ESI + 0x18]
005ae3ef : NOT AL
005ae3f1 : AND AL,0x1
005ae3f3 : SHL AL,0x5
005ae3f6 : OR AL,0x58
005ae3f8 : MOV byte ptr [ECX],AL
005ae3fa : ADD dword ptr [ESI + 0x18],EDI
005ae3fd : MOV EAX,dword ptr [ESI + 0x18]
005ae400 : MOV byte ptr [EAX],0x30
005ae403 : TEST byte ptr [ESI + 0x16],0x2
005ae407 : JZ 0x005ae438
005ae409 : TEST byte ptr [ESI + 0x15],0x80
005ae40d : JNZ 0x005ae438
005ae40f : MOV CL,byte ptr [ESI + 0x14]
005ae412 : AND CL,0xa0
005ae415 : OR CL,0x20
005ae418 : TEST byte ptr [ESI + 0x20],0x1
005ae41c : MOV byte ptr [ESI + 0x14],CL
005ae41f : JZ 0x005ae438
005ae421 : CMP dword ptr [ESI + 0x2c],0x0
005ae425 : JL 0x005ae438
005ae427 : JG 0x005ae42f
005ae429 : CMP dword ptr [ESI + 0x28],0x0
005ae42d : JC 0x005ae438
005ae42f : ADD dword ptr [ESI + 0x18],EDI
005ae432 : MOV EAX,dword ptr [ESI + 0x18]
005ae435 : MOV byte ptr [EAX],0x20
005ae438 : MOV ECX,dword ptr [ESI + 0x18]
005ae43b : MOV EBP,ESI
005ae43d : SUB EBP,ECX
005ae43f : ADD EBP,0x4c
005ae442 : TEST byte ptr [ESI + 0x16],0x4
005ae446 : JZ 0x005ae4b0
005ae448 : MOV EAX,dword ptr [EBX]
005ae44a : SHR EAX,0x5
005ae44d : AND EAX,0x1f
005ae450 : CMP EBP,EAX
005ae452 : JNC 0x005ae4eb
005ae458 : MOV EDI,ESI
005ae45a : SUB EDI,EAX
005ae45c : PUSH EBP
005ae45d : PUSH ECX
005ae45e : ADD EDI,0x4c
005ae461 : PUSH EDI
005ae462 : CALL 0x00636880
005ae467 : MOV EDX,dword ptr [EBX]
005ae469 : SHR EDX,0x5
005ae46c : MOV dword ptr [ESI + 0x18],EDI
005ae46f : AND EDX,0x1f
005ae472 : ADD ESP,0xc
005ae475 : ADD EDI,EBP
005ae477 : MOV EAX,EBP
005ae479 : CMP EBP,EDX
005ae47b : JNC 0x005ae4eb
005ae47d : LEA ECX,[ECX]
005ae480 : MOV ECX,dword ptr [ESI + 0x1c]
005ae483 : AND ECX,0x1f
005ae486 : CMP CL,0xa
005ae489 : JZ 0x005ae496
005ae48b : MOV DL,byte ptr [ESI + 0x14]
005ae48e : ADD DL,DL
005ae490 : SAR DL,0x1
005ae492 : MOV byte ptr [EDI],DL
005ae494 : JMP 0x005ae499
005ae496 : MOV byte ptr [EDI],0x20
005ae499 : MOV ECX,dword ptr [EBX]
005ae49b : SHR ECX,0x5
005ae49e : INC EAX
005ae49f : AND ECX,0x1f
005ae4a2 : INC EDI
005ae4a3 : CMP EAX,ECX
005ae4a5 : JC 0x005ae480
005ae4a7 : POP EDI
005ae4a8 : POP EBP
005ae4a9 : POP EBX
005ae4aa : MOV byte ptr [ESI + 0x8],0x1
005ae4ae : POP ESI
005ae4af : RET
005ae4b0 : MOV EDX,dword ptr [EBX]
005ae4b2 : SHR EDX,0x5
005ae4b5 : AND EDX,0x1f
005ae4b8 : CMP EBP,EDX
005ae4ba : JNC 0x005ae4eb
005ae4bc : LEA ESP,[ESP]
005ae4c0 : MOV EAX,dword ptr [ESI + 0x1c]
005ae4c3 : ADD dword ptr [ESI + 0x18],EDI
005ae4c6 : AND EAX,0x1f
005ae4c9 : CMP AL,0xa
005ae4cb : MOV EAX,dword ptr [ESI + 0x18]
005ae4ce : JZ 0x005ae4db
005ae4d0 : MOV CL,byte ptr [ESI + 0x14]
005ae4d3 : ADD CL,CL
005ae4d5 : SAR CL,0x1
005ae4d7 : MOV byte ptr [EAX],CL
005ae4d9 : JMP 0x005ae4de
005ae4db : MOV byte ptr [EAX],0x20
005ae4de : MOV EDX,dword ptr [EBX]
005ae4e0 : SHR EDX,0x5
005ae4e3 : INC EBP
005ae4e4 : AND EDX,0x1f
005ae4e7 : CMP EBP,EDX
005ae4e9 : JC 0x005ae4c0
005ae4eb : POP EDI
005ae4ec : POP EBP
005ae4ed : MOV byte ptr [ESI + 0x8],0x1
005ae4f1 : POP EBX
005ae4f2 : POP ESI
005ae4f3 : RET
