PROGRAM  : Maestia.exe
FUNCTION : setSBUpLow
ENTRY    : 00650ec8
BODY     : [[00650ec8, 0065105a]]

============================================================
DECOMPILED C CODE
============================================================

/* Library Function - Single Match
    void __cdecl setSBUpLow(struct threadmbcinfostruct *)
   
   Library: Visual Studio 2008 Release */

void __cdecl setSBUpLow(threadmbcinfostruct *param_1)

{
  byte *pbVar1;
  char *pcVar2;
  BOOL BVar3;
  uint uVar4;
  CHAR CVar5;
  char cVar6;
  BYTE *pBVar7;
  int unaff_ESI;
  _cpinfo local_51c;
  WORD local_508 [256];
  CHAR local_308 [256];
  CHAR local_208 [256];
  CHAR local_108 [256];
  uint local_8;
  
  local_8 = DAT_00d66fa0 ^ (uint)&stack0xfffffffc;
  BVar3 = GetCPInfo(*(UINT *)(unaff_ESI + 4),&local_51c);
  if (BVar3 == 0) {
    uVar4 = 0;
    do {
      pcVar2 = (char *)(unaff_ESI + 0x11d + uVar4);
      if (pcVar2 + (-0x61 - (unaff_ESI + 0x11d)) + 0x20 < (char *)0x1a) {
        pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
        *pbVar1 = *pbVar1 | 0x10;
        cVar6 = (char)uVar4 + ' ';
LAB_00651041:
        *pcVar2 = cVar6;
      }
      else {
        if (pcVar2 + (-0x61 - (unaff_ESI + 0x11d)) < (char *)0x1a) {
          pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
          *pbVar1 = *pbVar1 | 0x20;
          cVar6 = (char)uVar4 + -0x20;
          goto LAB_00651041;
        }
        *pcVar2 = '\0';
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (CHAR)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    local_108[0] = ' ';
    if (local_51c.LeadByte[0] != 0) {
      pBVar7 = local_51c.LeadByte + 1;
      do {
        uVar4 = (uint)local_51c.LeadByte[0];
        if (uVar4 <= *pBVar7) {
          _memset(local_108 + uVar4,0x20,(*pBVar7 - uVar4) + 1);
        }
        local_51c.LeadByte[0] = pBVar7[1];
        pBVar7 = pBVar7 + 2;
      } while (local_51c.LeadByte[0] != 0);
    }
    ___crtGetStringTypeA
              ((_locale_t)0x0,1,local_108,0x100,local_508,*(int *)(unaff_ESI + 4),
               *(BOOL *)(unaff_ESI + 0xc));
    ___crtLCMapStringA((_locale_t)0x0,*(LPCWSTR *)(unaff_ESI + 0xc),0x100,local_108,0x100,local_208,
                       0x100,*(int *)(unaff_ESI + 4),0);
    ___crtLCMapStringA((_locale_t)0x0,*(LPCWSTR *)(unaff_ESI + 0xc),0x200,local_108,0x100,local_308,
                       0x100,*(int *)(unaff_ESI + 4),0);
    uVar4 = 0;
    do {
      if ((local_508[uVar4] & 1) == 0) {
        if ((local_508[uVar4] & 2) != 0) {
          pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
          *pbVar1 = *pbVar1 | 0x20;
          CVar5 = local_308[uVar4];
          goto LAB_00650fdf;
        }
        *(undefined1 *)(unaff_ESI + 0x11d + uVar4) = 0;
      }
      else {
        pbVar1 = (byte *)(unaff_ESI + 0x1d + uVar4);
        *pbVar1 = *pbVar1 | 0x10;
        CVar5 = local_208[uVar4];
LAB_00650fdf:
        *(CHAR *)(unaff_ESI + 0x11d + uVar4) = CVar5;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  __security_check_cookie(local_8 ^ (uint)&stack0xfffffffc);
  return;
}



============================================================
DISASSEMBLY
============================================================
00650ec8 : MOV EDI,EDI
00650eca : PUSH EBP
00650ecb : MOV EBP,ESP
00650ecd : SUB ESP,0x51c
00650ed3 : MOV EAX,[0x00d66fa0]
00650ed8 : XOR EAX,EBP
00650eda : MOV dword ptr [EBP + -0x4],EAX
00650edd : PUSH EBX
00650ede : PUSH EDI
00650edf : LEA EAX,[EBP + 0xfffffae8]
00650ee5 : PUSH EAX
00650ee6 : PUSH dword ptr [ESI + 0x4]
00650ee9 : CALL dword ptr [0x00b8529c]
00650eef : MOV EDI,0x100
00650ef4 : TEST EAX,EAX
00650ef6 : JZ 0x00650ff7
00650efc : XOR EAX,EAX
00650efe : MOV byte ptr [EBP + EAX*0x1 + 0xfffffefc],AL
00650f05 : INC EAX
00650f06 : CMP EAX,EDI
00650f08 : JC 0x00650efe
00650f0a : MOV AL,byte ptr [EBP + 0xfffffaee]
00650f10 : MOV byte ptr [EBP + 0xfffffefc],0x20
00650f17 : TEST AL,AL
00650f19 : JZ 0x00650f49
00650f1b : LEA EBX,[EBP + 0xfffffaef]
00650f21 : MOVZX ECX,AL
00650f24 : MOVZX EAX,byte ptr [EBX]
00650f27 : CMP ECX,EAX
00650f29 : JA 0x00650f41
00650f2b : SUB EAX,ECX
00650f2d : INC EAX
00650f2e : PUSH EAX
00650f2f : LEA EDX,[EBP + ECX*0x1 + 0xfffffefc]
00650f36 : PUSH 0x20
00650f38 : PUSH EDX
00650f39 : CALL 0x0063b700
00650f3e : ADD ESP,0xc
00650f41 : INC EBX
00650f42 : MOV AL,byte ptr [EBX]
00650f44 : INC EBX
00650f45 : TEST AL,AL
00650f47 : JNZ 0x00650f21
00650f49 : PUSH 0x0
00650f4b : PUSH dword ptr [ESI + 0xc]
00650f4e : LEA EAX,[EBP + 0xfffffafc]
00650f54 : PUSH dword ptr [ESI + 0x4]
00650f57 : PUSH EAX
00650f58 : PUSH EDI
00650f59 : LEA EAX,[EBP + 0xfffffefc]
00650f5f : PUSH EAX
00650f60 : PUSH 0x1
00650f62 : PUSH 0x0
00650f64 : CALL 0x00655d21
00650f69 : XOR EBX,EBX
00650f6b : PUSH EBX
00650f6c : PUSH dword ptr [ESI + 0x4]
00650f6f : LEA EAX,[EBP + 0xfffffdfc]
00650f75 : PUSH EDI
00650f76 : PUSH EAX
00650f77 : PUSH EDI
00650f78 : LEA EAX,[EBP + 0xfffffefc]
00650f7e : PUSH EAX
00650f7f : PUSH EDI
00650f80 : PUSH dword ptr [ESI + 0xc]
00650f83 : PUSH EBX
00650f84 : CALL 0x00643b47
00650f89 : ADD ESP,0x44
00650f8c : PUSH EBX
00650f8d : PUSH dword ptr [ESI + 0x4]
00650f90 : LEA EAX,[EBP + 0xfffffcfc]
00650f96 : PUSH EDI
00650f97 : PUSH EAX
00650f98 : PUSH EDI
00650f99 : LEA EAX,[EBP + 0xfffffefc]
00650f9f : PUSH EAX
00650fa0 : PUSH 0x200
00650fa5 : PUSH dword ptr [ESI + 0xc]
00650fa8 : PUSH EBX
00650fa9 : CALL 0x00643b47
00650fae : ADD ESP,0x24
00650fb1 : XOR EAX,EAX
00650fb3 : MOVZX ECX,word ptr [EBP + EAX*0x2 + 0xfffffafc]
00650fbb : TEST CL,0x1
00650fbe : JZ 0x00650fce
00650fc0 : OR byte ptr [ESI + EAX*0x1 + 0x1d],0x10
00650fc5 : MOV CL,byte ptr [EBP + EAX*0x1 + 0xfffffdfc]
00650fcc : JMP 0x00650fdf
00650fce : TEST CL,0x2
00650fd1 : JZ 0x00650fe8
00650fd3 : OR byte ptr [ESI + EAX*0x1 + 0x1d],0x20
00650fd8 : MOV CL,byte ptr [EBP + EAX*0x1 + 0xfffffcfc]
00650fdf : MOV byte ptr [ESI + EAX*0x1 + 0x11d],CL
00650fe6 : JMP 0x00650ff0
00650fe8 : MOV byte ptr [ESI + EAX*0x1 + 0x11d],0x0
00650ff0 : INC EAX
00650ff1 : CMP EAX,EDI
00650ff3 : JC 0x00650fb3
00650ff5 : JMP 0x0065104d
00650ff7 : LEA EAX,[ESI + 0x11d]
00650ffd : MOV dword ptr [EBP + 0xfffffae4],0xffffff9f
00651007 : XOR ECX,ECX
00651009 : SUB dword ptr [EBP + 0xfffffae4],EAX
0065100f : MOV EDX,dword ptr [EBP + 0xfffffae4]
00651015 : LEA EAX,[ESI + ECX*0x1 + 0x11d]
0065101c : ADD EDX,EAX
0065101e : LEA EBX,[EDX + 0x20]
00651021 : CMP EBX,0x19
00651024 : JA 0x00651032
00651026 : OR byte ptr [ESI + ECX*0x1 + 0x1d],0x10
0065102b : MOV DL,CL
0065102d : ADD DL,0x20
00651030 : JMP 0x00651041
00651032 : CMP EDX,0x19
00651035 : JA 0x00651045
00651037 : OR byte ptr [ESI + ECX*0x1 + 0x1d],0x20
0065103c : MOV DL,CL
0065103e : SUB DL,0x20
00651041 : MOV byte ptr [EAX],DL
00651043 : JMP 0x00651048
00651045 : MOV byte ptr [EAX],0x0
00651048 : INC ECX
00651049 : CMP ECX,EDI
0065104b : JC 0x0065100f
0065104d : MOV ECX,dword ptr [EBP + -0x4]
00651050 : POP EDI
00651051 : XOR ECX,EBP
00651053 : POP EBX
00651054 : CALL 0x00633e6b
00651059 : LEAVE
0065105a : RET
