PROGRAM  : Maestia.exe
FUNCTION : _Getmfld
ENTRY    : 006314a7
BODY     : [[006314a7, 00631caa]]

============================================================
DECOMPILED C CODE
============================================================

/* WARNING: Function: __EH_prolog3_GS replaced with injection: EH_prolog3 */
/* Library Function - Single Match
    private: class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
   __thiscall std::money_get<char,class std::istreambuf_iterator<char,struct std::char_traits<char>
   > >::_Getmfld(class std::istreambuf_iterator<char,struct std::char_traits<char> > &,class
   std::istreambuf_iterator<char,struct std::char_traits<char> > &,bool,class std::ios_base &)const 
   
   Library: Visual Studio 2008 Release */

void __thiscall
std::money_get<char,class_std::istreambuf_iterator<char,struct_std::char_traits<char>_>_>::_Getmfld
          (money_get<char,class_std::istreambuf_iterator<char,struct_std::char_traits<char>_>_>
           *this,istreambuf_iterator<char,struct_std::char_traits<char>_> *param_1,
          istreambuf_iterator<char,struct_std::char_traits<char>_> *param_2,bool param_3,
          ios_base *param_4)

{
  istreambuf_iterator<char,struct_std::char_traits<char>_> *this_00;
  char cVar1;
  byte bVar2;
  bool bVar3;
  char cVar4;
  undefined4 uVar5;
  int *piVar6;
  int iVar7;
  byte ****ppppbVar8;
  byte *pbVar9;
  undefined4 *puVar10;
  char *pcVar11;
  char ****ppppcVar12;
  undefined3 in_stack_0000000d;
  int in_stack_00000014;
  undefined1 local_180 [28];
  undefined1 local_164 [28];
  undefined1 local_148 [28];
  undefined1 local_12c [28];
  undefined1 local_110 [28];
  undefined1 local_f4 [28];
  undefined1 local_d8 [8];
  undefined1 local_d0 [8];
  undefined1 local_c8 [8];
  undefined1 local_c0 [4];
  undefined1 local_bc [4];
  char local_b8 [4];
  undefined4 local_b4;
  undefined4 local_b0;
  undefined4 local_ac;
  int local_a8;
  undefined4 local_a4;
  undefined4 local_a0;
  uint local_9c;
  istreambuf_iterator<char,struct_std::char_traits<char>_> *local_98;
  int *local_94;
  undefined4 local_90;
  undefined4 local_8c;
  int local_88;
  int local_84;
  istreambuf_iterator<char,struct_std::char_traits<char>_> *local_80;
  char local_79;
  istreambuf_iterator<char,struct_std::char_traits<char>_> *local_78;
  char local_71;
  uint local_70;
  char local_69;
  uint local_54;
  undefined1 local_4c [4];
  byte ***local_48 [4];
  int local_38;
  uint local_34;
  undefined1 local_30 [4];
  char ***local_2c [5];
  uint local_18;
  undefined4 local_8;
  undefined4 uStack_4;
  
  uStack_4 = 0x170;
  local_8 = 0x6314b6;
  local_70 = 0;
  local_78 = _param_3;
  local_80 = param_1;
  local_98 = param_2;
  local_88 = in_stack_00000014;
  if ((char)param_4 == '\0') {
    uVar5 = FUN_004d0b70(local_c0);
    local_8 = 2;
    piVar6 = (int *)::use_facet<>(uVar5);
  }
  else {
    uVar5 = FUN_004d0b70(local_bc);
    local_8 = 1;
    piVar6 = (int *)::use_facet<>(uVar5);
  }
  local_94 = piVar6;
  FUN_00451310();
  local_69 = '\0';
  local_79 = '\0';
  FUN_0040eea0();
  local_8 = 3;
  FUN_0040eea0();
  local_70 = 1;
  (**(code **)(*piVar6 + 0x24))(local_b8);
  local_9c = 0;
  do {
    if (3 < local_9c) break;
    cVar4 = local_b8[local_9c];
    if (cVar4 == ' ') {
LAB_006315b4:
      if (local_9c != 3) {
        uVar5 = FUN_004d0b70(&local_8c);
        local_8._0_1_ = 0xd;
        iVar7 = FUN_004d3ca0(uVar5);
        local_8 = CONCAT31(local_8._1_3_,3);
        FUN_00451310();
        while ((bVar3 = operator!=<char,struct_std::char_traits<char>_>(param_2,local_78), bVar3 &&
               (bVar2 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2)
               , (*(byte *)(*(int *)(iVar7 + 0x10) + (uint)bVar2 * 2) & 0x48) != 0))) {
          istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_2);
        }
      }
      goto LAB_00631ba5;
    }
    if (cVar4 == '$') {
      curr_symbol(local_30);
      local_8._0_1_ = 4;
      if ((*(byte *)(local_88 + 0x10) & 8) == 0) {
        ppppcVar12 = (char ****)local_2c[0];
        if (local_18 < 0x10) {
          ppppcVar12 = local_2c;
        }
        cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
        if (cVar4 == *(char *)ppppcVar12) goto LAB_00631a8d;
LAB_00631ac1:
        FUN_00404de0(0,0xffffffff);
      }
      else {
LAB_00631a8d:
        if ((local_9c == 3) && (local_54 < 2)) {
          bVar3 = istreambuf_iterator<char,struct_std::char_traits<char>_>::equal(param_2,local_78);
          if (!bVar3) {
            ppppcVar12 = (char ****)local_2c[0];
            if (local_18 < 0x10) {
              ppppcVar12 = local_2c;
            }
            cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
            if (cVar4 == *(char *)ppppcVar12) goto LAB_00631acd;
          }
          goto LAB_00631ac1;
        }
      }
LAB_00631acd:
      puVar10 = (undefined4 *)FUN_00438b10(local_d8);
      local_a4 = *puVar10;
      local_a0 = puVar10[1];
      while (bVar3 = operator!=<char,struct_std::char_traits<char>_>(param_2,local_78), bVar3) {
        uVar5 = FUN_00435d10(local_d0);
        cVar4 = FID_conflict_operator__(uVar5);
        if (cVar4 == '\0') break;
        pcVar11 = (char *)FUN_00412cf0();
        cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
        if (cVar4 != *pcVar11) break;
        _String_const_iterator<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
        operator++((_String_const_iterator<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                    *)&local_a4);
        istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_2);
      }
      uVar5 = FUN_00435d10(local_c8);
      cVar4 = FID_conflict_operator__(uVar5);
      if (cVar4 != '\0') {
        local_69 = '\x01';
      }
LAB_00631b6f:
      local_8 = CONCAT31(local_8._1_3_,3);
      FUN_00405260(1,0);
    }
    else {
      if (cVar4 == '+') {
        bVar3 = istreambuf_iterator<char,struct_std::char_traits<char>_>::equal(param_2,local_78);
        if (bVar3) goto LAB_00631ba5;
        iVar7 = positive_sign(local_12c);
        local_70 = local_70 | 2;
        local_8 = CONCAT31(local_8._1_3_,5);
        if (*(int *)(iVar7 + 0x14) == 0) {
LAB_0063190c:
          local_71 = '\0';
        }
        else {
          positive_sign(local_f4);
          local_70 = local_70 | 4;
          local_8 = 6;
          pcVar11 = (char *)FUN_004d3b30(0);
          cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
          local_71 = '\x01';
          if (*pcVar11 != cVar4) goto LAB_0063190c;
        }
        if ((local_70 & 4) != 0) {
          local_70 = local_70 & 0xfffffffb;
          FUN_00405260(1,0);
        }
        local_8 = 3;
        if ((local_70 & 2) != 0) {
          local_70 = local_70 & 0xfffffffd;
          FUN_00405260(1,0);
        }
        if (local_71 == '\0') {
          iVar7 = negative_sign(local_148);
          local_70 = local_70 | 8;
          local_8 = CONCAT31(local_8._1_3_,8);
          if (*(int *)(iVar7 + 0x14) == 0) {
LAB_006319ce:
            bVar3 = false;
          }
          else {
            negative_sign(local_110);
            local_70 = local_70 | 0x10;
            local_8 = 9;
            pcVar11 = (char *)FUN_004d3b30(0);
            cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
            if (*pcVar11 != cVar4) goto LAB_006319ce;
            bVar3 = true;
          }
          if ((local_70 & 0x10) != 0) {
            local_70 = local_70 & 0xffffffef;
            FUN_00405260(1,0);
          }
          local_8 = 3;
          if ((local_70 & 8) != 0) {
            local_70 = local_70 & 0xfffffff7;
            FUN_00405260(1,0);
          }
          if (bVar3) {
            istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(local_98);
            uVar5 = negative_sign(local_180);
            local_8._0_1_ = 10;
            FUN_00405110(uVar5,0,0xffffffff);
            local_8 = CONCAT31(local_8._1_3_,3);
            FUN_00405260(1,0);
            local_79 = '\x01';
          }
          goto LAB_00631ba5;
        }
        istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_2);
        uVar5 = positive_sign(local_164);
        local_8._0_1_ = 7;
        FUN_00405110(uVar5,0,0xffffffff);
        goto LAB_00631b6f;
      }
      if (cVar4 == 'v') {
        local_84 = 0;
        local_a8 = (**(code **)(*piVar6 + 0x1c))();
        grouping(local_4c);
        local_8._0_1_ = 0xb;
        if (local_38 == 0) {
LAB_006317bc:
          while (((bVar3 = operator!=<char,struct_std::char_traits<char>_>(param_2,local_78), bVar3
                  && (cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*
                                        (param_2), '/' < cVar4)) &&
                 (cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*
                                    (param_2), cVar4 < ':'))) {
            cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
            local_b0 = CONCAT31(local_b0._1_3_,cVar4);
            FUN_004d12b0(1,local_b0);
            istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_2);
          }
        }
        else {
          local_71 = (**(code **)(*piVar6 + 8))();
          if (local_71 == '\0') goto LAB_006317bc;
          ppppbVar8 = (byte ****)local_48[0];
          if (local_34 < 0x10) {
            ppppbVar8 = local_48;
          }
          if (0x7e < *(byte *)ppppbVar8) goto LAB_006317bc;
          FUN_004d1280(1,0);
          local_8._0_1_ = 0xc;
          iVar7 = 0;
          bVar3 = operator!=<char,struct_std::char_traits<char>_>(param_2,local_78);
          if (bVar3) {
            do {
              cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
              if ((cVar4 < '0') ||
                 (cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*
                                    (param_2), '9' < cVar4)) {
                pcVar11 = (char *)FUN_004d3b30(iVar7);
                if ((*pcVar11 == '\0') ||
                   (cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*
                                      (param_2), cVar4 != local_71)) break;
                FUN_004d12b0(1,0);
                iVar7 = iVar7 + 1;
              }
              else {
                cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2)
                ;
                local_ac = CONCAT31(local_ac._1_3_,cVar4);
                FUN_004d12b0(1,local_ac);
                pcVar11 = (char *)FUN_004d3b30(iVar7);
                if (*pcVar11 != '\x7f') {
                  pcVar11 = (char *)FUN_004d3b30(iVar7);
                  *pcVar11 = *pcVar11 + '\x01';
                }
              }
              istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_2);
              bVar3 = operator!=<char,struct_std::char_traits<char>_>(param_2,local_78);
            } while (bVar3);
            if (iVar7 != 0) {
              pcVar11 = (char *)FUN_004d3b30(iVar7);
              if (*pcVar11 < '\x01') {
                local_69 = '\x01';
              }
              else {
                iVar7 = iVar7 + 1;
              }
            }
          }
          ppppbVar8 = (byte ****)local_48[0];
          if (local_34 < 0x10) {
            ppppbVar8 = local_48;
          }
          if (local_69 != '\0') {
LAB_0063175c:
            FUN_00405260(1,0);
            goto LAB_00631b6f;
          }
          while ((iVar7 != 0 && (*(byte *)ppppbVar8 != 0x7f))) {
            iVar7 = iVar7 + -1;
            if (((iVar7 != 0) &&
                (pbVar9 = (byte *)FUN_004d3b30(iVar7), *(byte *)ppppbVar8 != *pbVar9)) ||
               ((iVar7 == 0 &&
                (pcVar11 = (char *)FUN_004d3b30(0), (char)*(byte *)ppppbVar8 < *pcVar11)))) {
              local_69 = '\x01';
              goto LAB_0063175c;
            }
            if ('\0' < (char)*(byte *)((int)ppppbVar8 + 1)) {
              ppppbVar8 = (byte ****)((int)ppppbVar8 + 1);
            }
          }
          local_8._0_1_ = 0xb;
          FUN_00405260(1,0);
        }
        cVar4 = (**(code **)(*local_94 + 4))();
        this_00 = local_98;
        bVar3 = operator!=<char,struct_std::char_traits<char>_>(local_98,local_78);
        iVar7 = local_a8;
        if (((bVar3) && (cVar4 != '\0')) &&
           (cVar1 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(this_00),
           iVar7 = local_a8, cVar1 == cVar4)) {
          istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(this_00);
          bVar3 = operator!=<char,struct_std::char_traits<char>_>(this_00,local_78);
          iVar7 = local_a8;
          while (bVar3 != false) {
            if (iVar7 <= local_84) goto LAB_0063187a;
            cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(this_00);
            if ((cVar4 < '0') ||
               (cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(this_00)
               , '9' < cVar4)) break;
            cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(this_00);
            local_b4 = CONCAT31(local_b4._1_3_,cVar4);
            FUN_004d12b0(1,local_b4);
            local_84 = local_84 + 1;
            istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(this_00);
            bVar3 = operator!=<char,struct_std::char_traits<char>_>(this_00,local_78);
          }
          if (local_84 < iVar7) {
            local_69 = '\x01';
          }
        }
LAB_0063187a:
        if (*(int *)(local_80 + 0x14) == 0) {
          local_69 = '\x01';
        }
        else if (local_84 < iVar7) {
          iVar7 = iVar7 - local_84;
          do {
            FUN_004d12b0(1,0x30);
            iVar7 = iVar7 + -1;
          } while (iVar7 != 0);
        }
        goto LAB_00631b6f;
      }
      if (cVar4 == 'x') goto LAB_006315b4;
    }
LAB_00631ba5:
    local_9c = local_9c + 1;
    param_2 = local_98;
    piVar6 = local_94;
  } while (local_69 == '\0');
  if (local_69 == '\0') {
    if (1 < local_54) {
      local_90 = 0;
      local_8c = 0;
      puVar10 = (undefined4 *)FUN_00438b10(local_c8);
      local_90 = *puVar10;
      local_8c = puVar10[1];
      while( true ) {
        uVar5 = FUN_00435d10(&local_a4);
        _String_const_iterator<char,struct_std::char_traits<char>,class_std::allocator<char>_>::
        operator++((_String_const_iterator<char,struct_std::char_traits<char>,class_std::allocator<char>_>
                    *)&local_90);
        cVar4 = FID_conflict_operator__(uVar5);
        if ((cVar4 == '\0') ||
           (bVar3 = operator!=<char,struct_std::char_traits<char>_>(param_2,local_78), !bVar3))
        break;
        pcVar11 = (char *)FUN_00412cf0();
        cVar4 = istreambuf_iterator<char,struct_std::char_traits<char>_>::operator*(param_2);
        if (cVar4 != *pcVar11) break;
        istreambuf_iterator<char,struct_std::char_traits<char>_>::_Inc(param_2);
      }
      uVar5 = FUN_00435d10(local_c8);
      cVar4 = FID_conflict_operator__(uVar5);
      if (cVar4 != '\0') goto LAB_00631c72;
    }
    if (local_79 != '\0') {
      FUN_004360a0(0,1,0x2d);
    }
  }
  else {
LAB_00631c72:
    FUN_00404de0(0,0xffffffff);
  }
  FUN_00405260(1,0);
  FUN_00640ed0();
  return;
}



============================================================
DISASSEMBLY
============================================================
006314a7 : PUSH 0x170
006314ac : MOV EAX,0xb0c2ef
006314b1 : CALL 0x00640e86
006314b6 : MOV EAX,dword ptr [EBP + 0x10]
006314b9 : MOV ESI,dword ptr [EBP + 0x8]
006314bc : MOV EBX,dword ptr [EBP + 0xc]
006314bf : AND dword ptr [EBP + -0x6c],0x0
006314c3 : CMP byte ptr [EBP + 0x14],0x0
006314c7 : MOV dword ptr [EBP + -0x74],EAX
006314ca : MOV EAX,dword ptr [EBP + 0x18]
006314cd : MOV dword ptr [EBP + -0x7c],ESI
006314d0 : MOV dword ptr [EBP + 0xffffff6c],EBX
006314d6 : MOV dword ptr [EBP + 0xffffff7c],EAX
006314dc : MOV ECX,EAX
006314de : JZ 0x0063150a
006314e0 : LEA EAX,[EBP + 0xffffff48]
006314e6 : PUSH EAX
006314e7 : CALL 0x004d0b70
006314ec : PUSH EAX
006314ed : MOV dword ptr [EBP + -0x4],0x1
006314f4 : CALL 0x0063136d
006314f9 : MOV EDI,EAX
006314fb : POP ECX
006314fc : MOV dword ptr [EBP + 0xffffff70],EDI
00631502 : LEA ECX,[EBP + 0xffffff48]
00631508 : JMP 0x00631532
0063150a : LEA EAX,[EBP + 0xffffff44]
00631510 : PUSH EAX
00631511 : CALL 0x004d0b70
00631516 : PUSH EAX
00631517 : MOV dword ptr [EBP + -0x4],0x2
0063151e : CALL 0x006312d0
00631523 : POP ECX
00631524 : MOV EDI,EAX
00631526 : MOV dword ptr [EBP + 0xffffff70],EAX
0063152c : LEA ECX,[EBP + 0xffffff44]
00631532 : CALL 0x00451310
00631537 : LEA ECX,[EBP + -0x64]
0063153a : MOV byte ptr [EBP + -0x65],0x0
0063153e : MOV byte ptr [EBP + -0x75],0x0
00631542 : CALL 0x0040eea0
00631547 : MOV ECX,ESI
00631549 : MOV dword ptr [EBP + -0x4],0x3
00631550 : CALL 0x0040eea0
00631555 : MOV EAX,dword ptr [EDI]
00631557 : LEA ECX,[EBP + 0xffffff4c]
0063155d : PUSH ECX
0063155e : MOV ECX,EDI
00631560 : MOV dword ptr [EBP + -0x6c],0x1
00631567 : CALL dword ptr [EAX + 0x24]
0063156a : AND dword ptr [EBP + 0xffffff68],0x0
00631571 : JMP 0x00631579
00631573 : MOV EDI,dword ptr [EBP + 0xffffff70]
00631579 : MOV ECX,dword ptr [EBP + 0xffffff68]
0063157f : CMP ECX,0x4
00631582 : JNC 0x00631bbb
00631588 : MOVSX EAX,byte ptr [EBP + ECX*0x1 + 0xffffff4c]
00631590 : SUB EAX,0x20
00631593 : JZ 0x006315b4
00631595 : SUB EAX,0x4
00631598 : JZ 0x00631a5b
0063159e : SUB EAX,0x7
006315a1 : JZ 0x006318ab
006315a7 : SUB EAX,0x4b
006315aa : JZ 0x006315f0
006315ac : DEC EAX
006315ad : DEC EAX
006315ae : JNZ 0x00631ba5
006315b4 : CMP ECX,0x3
006315b7 : JZ 0x00631ba5
006315bd : MOV ECX,dword ptr [EBP + 0xffffff7c]
006315c3 : LEA EAX,[EBP + 0xffffff78]
006315c9 : PUSH EAX
006315ca : CALL 0x004d0b70
006315cf : PUSH EAX
006315d0 : MOV byte ptr [EBP + -0x4],0xd
006315d4 : CALL 0x004d3ca0
006315d9 : POP ECX
006315da : LEA ECX,[EBP + 0xffffff78]
006315e0 : MOV ESI,EAX
006315e2 : MOV byte ptr [EBP + -0x4],0x3
006315e6 : CALL 0x00451310
006315eb : JMP 0x00631b96
006315f0 : MOV EAX,dword ptr [EDI]
006315f2 : XOR ESI,ESI
006315f4 : MOV ECX,EDI
006315f6 : MOV dword ptr [EBP + -0x80],ESI
006315f9 : CALL dword ptr [EAX + 0x1c]
006315fc : MOV dword ptr [EBP + 0xffffff5c],EAX
00631602 : LEA EAX,[EBP + -0x48]
00631605 : PUSH EAX
00631606 : MOV ECX,EDI
00631608 : CALL 0x006269c7
0063160d : MOV byte ptr [EBP + -0x4],0xb
00631611 : CMP dword ptr [EBP + -0x34],ESI
00631614 : JZ 0x006317bc
0063161a : MOV EAX,dword ptr [EDI]
0063161c : MOV ECX,EDI
0063161e : CALL dword ptr [EAX + 0x8]
00631621 : MOV byte ptr [EBP + -0x6d],AL
00631624 : TEST AL,AL
00631626 : JZ 0x006317bc
0063162c : CMP dword ptr [EBP + -0x30],0x10
00631630 : MOV EAX,dword ptr [EBP + -0x44]
00631633 : JNC 0x00631638
00631635 : LEA EAX,[EBP + -0x44]
00631638 : CMP byte ptr [EAX],0x7f
0063163b : JNC 0x006317bc
00631641 : PUSH ESI
00631642 : PUSH 0x1
00631644 : LEA ECX,[EBP + -0x2c]
00631647 : CALL 0x004d1280
0063164c : PUSH dword ptr [EBP + -0x74]
0063164f : MOV byte ptr [EBP + -0x4],0xc
00631653 : PUSH EBX
00631654 : XOR EDI,EDI
00631656 : CALL 0x0062318f
0063165b : POP ECX
0063165c : POP ECX
0063165d : TEST AL,AL
0063165f : JZ 0x0063170c
00631665 : MOV ECX,EBX
00631667 : CALL 0x0062317a
0063166c : CMP AL,0x30
0063166e : JL 0x006316b3
00631670 : MOV ECX,EBX
00631672 : CALL 0x0062317a
00631677 : CMP AL,0x39
00631679 : JG 0x006316b3
0063167b : MOV ECX,EBX
0063167d : CALL 0x0062317a
00631682 : MOV ECX,dword ptr [EBP + -0x7c]
00631685 : MOV byte ptr [EBP + 0xffffff58],AL
0063168b : PUSH dword ptr [EBP + 0xffffff58]
00631691 : PUSH 0x1
00631693 : CALL 0x004d12b0
00631698 : PUSH EDI
00631699 : LEA ECX,[EBP + -0x2c]
0063169c : CALL 0x004d3b30
006316a1 : CMP byte ptr [EAX],0x7f
006316a4 : JZ 0x006316d9
006316a6 : PUSH EDI
006316a7 : LEA ECX,[EBP + -0x2c]
006316aa : CALL 0x004d3b30
006316af : INC byte ptr [EAX]
006316b1 : JMP 0x006316d9
006316b3 : PUSH EDI
006316b4 : LEA ECX,[EBP + -0x2c]
006316b7 : CALL 0x004d3b30
006316bc : CMP byte ptr [EAX],0x0
006316bf : JZ 0x006316f3
006316c1 : MOV ECX,EBX
006316c3 : CALL 0x0062317a
006316c8 : CMP AL,byte ptr [EBP + -0x6d]
006316cb : JNZ 0x006316f3
006316cd : PUSH ESI
006316ce : PUSH 0x1
006316d0 : LEA ECX,[EBP + -0x2c]
006316d3 : CALL 0x004d12b0
006316d8 : INC EDI
006316d9 : MOV ECX,EBX
006316db : CALL 0x006230d9
006316e0 : PUSH dword ptr [EBP + -0x74]
006316e3 : PUSH EBX
006316e4 : CALL 0x0062318f
006316e9 : POP ECX
006316ea : POP ECX
006316eb : TEST AL,AL
006316ed : JNZ 0x00631665
006316f3 : CMP EDI,ESI
006316f5 : JZ 0x0063170c
006316f7 : PUSH EDI
006316f8 : LEA ECX,[EBP + -0x2c]
006316fb : CALL 0x004d3b30
00631700 : CMP byte ptr [EAX],0x0
00631703 : JLE 0x00631708
00631705 : INC EDI
00631706 : JMP 0x0063170c
00631708 : MOV byte ptr [EBP + -0x65],0x1
0063170c : CMP dword ptr [EBP + -0x30],0x10
00631710 : MOV ESI,dword ptr [EBP + -0x44]
00631713 : JNC 0x00631718
00631715 : LEA ESI,[EBP + -0x44]
00631718 : CMP byte ptr [EBP + -0x65],0x0
0063171c : JNZ 0x0063175c
0063171e : TEST EDI,EDI
00631720 : JBE 0x00631770
00631722 : CMP byte ptr [ESI],0x7f
00631725 : JZ 0x00631770
00631727 : DEC EDI
00631728 : JZ 0x00631739
0063172a : PUSH EDI
0063172b : LEA ECX,[EBP + -0x2c]
0063172e : CALL 0x004d3b30
00631733 : MOV CL,byte ptr [ESI]
00631735 : CMP CL,byte ptr [EAX]
00631737 : JNZ 0x00631758
00631739 : TEST EDI,EDI
0063173b : JNZ 0x0063174c
0063173d : PUSH EDI
0063173e : LEA ECX,[EBP + -0x2c]
00631741 : CALL 0x004d3b30
00631746 : MOV CL,byte ptr [ESI]
00631748 : CMP CL,byte ptr [EAX]
0063174a : JL 0x00631758
0063174c : LEA EAX,[ESI + 0x1]
0063174f : CMP byte ptr [EAX],0x0
00631752 : JLE 0x0063171e
00631754 : MOV ESI,EAX
00631756 : JMP 0x0063171e
00631758 : MOV byte ptr [EBP + -0x65],0x1
0063175c : PUSH 0x0
0063175e : PUSH 0x1
00631760 : LEA ECX,[EBP + -0x2c]
00631763 : CALL 0x00405260
00631768 : LEA ECX,[EBP + -0x48]
0063176b : JMP 0x00631b6d
00631770 : PUSH 0x0
00631772 : PUSH 0x1
00631774 : LEA ECX,[EBP + -0x2c]
00631777 : MOV byte ptr [EBP + -0x4],0xb
0063177b : CALL 0x00405260
00631780 : JMP 0x006317cb
00631782 : MOV ECX,EBX
00631784 : CALL 0x0062317a
00631789 : CMP AL,0x30
0063178b : JL 0x006317cb
0063178d : MOV ECX,EBX
0063178f : CALL 0x0062317a
00631794 : CMP AL,0x39
00631796 : JG 0x006317cb
00631798 : MOV ECX,EBX
0063179a : CALL 0x0062317a
0063179f : MOV ECX,dword ptr [EBP + -0x7c]
006317a2 : MOV byte ptr [EBP + 0xffffff54],AL
006317a8 : PUSH dword ptr [EBP + 0xffffff54]
006317ae : PUSH 0x1
006317b0 : CALL 0x004d12b0
006317b5 : MOV ECX,EBX
006317b7 : CALL 0x006230d9
006317bc : PUSH dword ptr [EBP + -0x74]
006317bf : PUSH EBX
006317c0 : CALL 0x0062318f
006317c5 : POP ECX
006317c6 : POP ECX
006317c7 : TEST AL,AL
006317c9 : JNZ 0x00631782
006317cb : MOV ECX,dword ptr [EBP + 0xffffff70]
006317d1 : MOV EAX,dword ptr [ECX]
006317d3 : CALL dword ptr [EAX + 0x4]
006317d6 : PUSH dword ptr [EBP + -0x74]
006317d9 : MOV ESI,dword ptr [EBP + 0xffffff6c]
006317df : PUSH ESI
006317e0 : MOV BL,AL
006317e2 : CALL 0x0062318f
006317e7 : POP ECX
006317e8 : POP ECX
006317e9 : TEST AL,AL
006317eb : JZ 0x00631874
006317f1 : TEST BL,BL
006317f3 : JZ 0x00631874
006317f5 : MOV ECX,ESI
006317f7 : CALL 0x0062317a
006317fc : CMP AL,BL
006317fe : JNZ 0x00631874
00631800 : MOV ECX,ESI
00631802 : CALL 0x006230d9
00631807 : PUSH dword ptr [EBP + -0x74]
0063180a : PUSH ESI
0063180b : CALL 0x0062318f
00631810 : MOV EDI,dword ptr [EBP + 0xffffff5c]
00631816 : POP ECX
00631817 : POP ECX
00631818 : TEST AL,AL
0063181a : JZ 0x00631869
0063181c : CMP dword ptr [EBP + -0x80],EDI
0063181f : JGE 0x0063187a
00631821 : MOV ECX,ESI
00631823 : CALL 0x0062317a
00631828 : CMP AL,0x30
0063182a : JL 0x00631869
0063182c : MOV ECX,ESI
0063182e : CALL 0x0062317a
00631833 : CMP AL,0x39
00631835 : JG 0x00631869
00631837 : MOV ECX,ESI
00631839 : CALL 0x0062317a
0063183e : MOV ECX,dword ptr [EBP + -0x7c]
00631841 : MOV byte ptr [EBP + 0xffffff50],AL
00631847 : PUSH dword ptr [EBP + 0xffffff50]
0063184d : PUSH 0x1
0063184f : CALL 0x004d12b0
00631854 : INC dword ptr [EBP + -0x80]
00631857 : MOV ECX,ESI
00631859 : CALL 0x006230d9
0063185e : PUSH dword ptr [EBP + -0x74]
00631861 : PUSH ESI
00631862 : CALL 0x0062318f
00631867 : JMP 0x00631816
00631869 : CMP dword ptr [EBP + -0x80],EDI
0063186c : JGE 0x0063187a
0063186e : MOV byte ptr [EBP + -0x65],0x1
00631872 : JMP 0x0063187a
00631874 : MOV EDI,dword ptr [EBP + 0xffffff5c]
0063187a : MOV ESI,dword ptr [EBP + -0x7c]
0063187d : CMP dword ptr [ESI + 0x14],0x0
00631881 : JNZ 0x0063188c
00631883 : MOV byte ptr [EBP + -0x65],0x1
00631887 : JMP 0x00631768
0063188c : CMP dword ptr [EBP + -0x80],EDI
0063188f : JGE 0x00631768
00631895 : SUB EDI,dword ptr [EBP + -0x80]
00631898 : PUSH 0x30
0063189a : PUSH 0x1
0063189c : MOV ECX,ESI
0063189e : CALL 0x004d12b0
006318a3 : DEC EDI
006318a4 : JNZ 0x00631898
006318a6 : JMP 0x00631768
006318ab : PUSH dword ptr [EBP + -0x74]
006318ae : MOV ECX,EBX
006318b0 : CALL 0x00623123
006318b5 : TEST AL,AL
006318b7 : JNZ 0x00631ba5
006318bd : LEA EAX,[EBP + 0xfffffed8]
006318c3 : PUSH EAX
006318c4 : MOV ECX,EDI
006318c6 : CALL 0x0063097b
006318cb : OR dword ptr [EBP + -0x6c],0x2
006318cf : CMP dword ptr [EAX + 0x14],0x0
006318d3 : MOV byte ptr [EBP + -0x4],0x5
006318d7 : JBE 0x0063190c
006318d9 : LEA EAX,[EBP + 0xffffff10]
006318df : PUSH EAX
006318e0 : MOV ECX,EDI
006318e2 : CALL 0x0063097b
006318e7 : OR dword ptr [EBP + -0x6c],0x4
006318eb : PUSH 0x0
006318ed : MOV ECX,EAX
006318ef : MOV dword ptr [EBP + -0x4],0x6
006318f6 : CALL 0x004d3b30
006318fb : MOV ECX,EBX
006318fd : MOV ESI,EAX
006318ff : CALL 0x0062317a
00631904 : MOV byte ptr [EBP + -0x6d],0x1
00631908 : CMP byte ptr [ESI],AL
0063190a : JZ 0x00631910
0063190c : MOV byte ptr [EBP + -0x6d],0x0
00631910 : XOR ESI,ESI
00631912 : TEST byte ptr [EBP + -0x6c],0x4
00631916 : JZ 0x0063192a
00631918 : AND dword ptr [EBP + -0x6c],0xfffffffb
0063191c : PUSH ESI
0063191d : PUSH 0x1
0063191f : LEA ECX,[EBP + 0xffffff10]
00631925 : CALL 0x00405260
0063192a : TEST byte ptr [EBP + -0x6c],0x2
0063192e : MOV dword ptr [EBP + -0x4],0x3
00631935 : JZ 0x00631949
00631937 : AND dword ptr [EBP + -0x6c],0xfffffffd
0063193b : PUSH ESI
0063193c : PUSH 0x1
0063193e : LEA ECX,[EBP + 0xfffffed8]
00631944 : CALL 0x00405260
00631949 : CMP byte ptr [EBP + -0x6d],0x0
0063194d : JZ 0x00631980
0063194f : MOV ECX,EBX
00631951 : CALL 0x006230d9
00631956 : LEA EAX,[EBP + 0xfffffea0]
0063195c : PUSH EAX
0063195d : MOV ECX,EDI
0063195f : CALL 0x0063097b
00631964 : PUSH -0x1
00631966 : PUSH ESI
00631967 : PUSH EAX
00631968 : LEA ECX,[EBP + -0x64]
0063196b : MOV byte ptr [EBP + -0x4],0x7
0063196f : CALL 0x00405110
00631974 : PUSH ESI
00631975 : LEA ECX,[EBP + 0xfffffea0]
0063197b : JMP 0x00631b6f
00631980 : LEA EAX,[EBP + 0xfffffebc]
00631986 : PUSH EAX
00631987 : MOV ECX,EDI
00631989 : CALL 0x006269e0
0063198e : OR dword ptr [EBP + -0x6c],0x8
00631992 : MOV byte ptr [EBP + -0x4],0x8
00631996 : CMP dword ptr [EAX + 0x14],ESI
00631999 : JBE 0x006319ce
0063199b : LEA EAX,[EBP + 0xfffffef4]
006319a1 : PUSH EAX
006319a2 : MOV ECX,EDI
006319a4 : CALL 0x006269e0
006319a9 : OR dword ptr [EBP + -0x6c],0x10
006319ad : PUSH 0x0
006319af : MOV ECX,EAX
006319b1 : MOV dword ptr [EBP + -0x4],0x9
006319b8 : CALL 0x004d3b30
006319bd : MOV ECX,EBX
006319bf : MOV ESI,EAX
006319c1 : CALL 0x0062317a
006319c6 : CMP byte ptr [ESI],AL
006319c8 : JNZ 0x006319ce
006319ca : MOV BL,0x1
006319cc : JMP 0x006319d0
006319ce : XOR BL,BL
006319d0 : TEST byte ptr [EBP + -0x6c],0x10
006319d4 : JZ 0x006319e9
006319d6 : AND dword ptr [EBP + -0x6c],0xffffffef
006319da : PUSH 0x0
006319dc : PUSH 0x1
006319de : LEA ECX,[EBP + 0xfffffef4]
006319e4 : CALL 0x00405260
006319e9 : TEST byte ptr [EBP + -0x6c],0x8
006319ed : MOV dword ptr [EBP + -0x4],0x3
006319f4 : JZ 0x00631a09
006319f6 : AND dword ptr [EBP + -0x6c],0xfffffff7
006319fa : PUSH 0x0
006319fc : PUSH 0x1
006319fe : LEA ECX,[EBP + 0xfffffebc]
00631a04 : CALL 0x00405260
00631a09 : TEST BL,BL
00631a0b : JZ 0x00631ba5
00631a11 : MOV ECX,dword ptr [EBP + 0xffffff6c]
00631a17 : CALL 0x006230d9
00631a1c : MOV ECX,dword ptr [EBP + 0xffffff70]
00631a22 : LEA EAX,[EBP + 0xfffffe84]
00631a28 : PUSH EAX
00631a29 : CALL 0x006269e0
00631a2e : PUSH -0x1
00631a30 : PUSH 0x0
00631a32 : PUSH EAX
00631a33 : LEA ECX,[EBP + -0x64]
00631a36 : MOV byte ptr [EBP + -0x4],0xa
00631a3a : CALL 0x00405110
00631a3f : PUSH 0x0
00631a41 : PUSH 0x1
00631a43 : LEA ECX,[EBP + 0xfffffe84]
00631a49 : MOV byte ptr [EBP + -0x4],0x3
00631a4d : CALL 0x00405260
00631a52 : MOV byte ptr [EBP + -0x75],0x1
00631a56 : JMP 0x00631ba5
00631a5b : LEA EAX,[EBP + -0x2c]
00631a5e : PUSH EAX
00631a5f : MOV ECX,EDI
00631a61 : CALL 0x00626a5e
00631a66 : MOV EAX,dword ptr [EBP + 0xffffff7c]
00631a6c : TEST byte ptr [EAX + 0x10],0x8
00631a70 : MOV byte ptr [EBP + -0x4],0x4
00631a74 : JNZ 0x00631a8d
00631a76 : CMP dword ptr [EBP + -0x14],0x10
00631a7a : MOV ESI,dword ptr [EBP + -0x28]
00631a7d : JNC 0x00631a82
00631a7f : LEA ESI,[EBP + -0x28]
00631a82 : MOV ECX,EBX
00631a84 : CALL 0x0062317a
00631a89 : CMP AL,byte ptr [ESI]
00631a8b : JNZ 0x00631ac1
00631a8d : CMP dword ptr [EBP + 0xffffff68],0x3
00631a94 : JNZ 0x00631acd
00631a96 : CMP dword ptr [EBP + -0x50],0x1
00631a9a : JA 0x00631acd
00631a9c : PUSH dword ptr [EBP + -0x74]
00631a9f : MOV ECX,EBX
00631aa1 : CALL 0x00623123
00631aa6 : TEST AL,AL
00631aa8 : JNZ 0x00631ac1
00631aaa : CMP dword ptr [EBP + -0x14],0x10
00631aae : MOV ESI,dword ptr [EBP + -0x28]
00631ab1 : JNC 0x00631ab6
00631ab3 : LEA ESI,[EBP + -0x28]
00631ab6 : MOV ECX,EBX
00631ab8 : CALL 0x0062317a
00631abd : CMP AL,byte ptr [ESI]
00631abf : JZ 0x00631acd
00631ac1 : PUSH -0x1
00631ac3 : PUSH 0x0
00631ac5 : LEA ECX,[EBP + -0x2c]
00631ac8 : CALL 0x00404de0
00631acd : LEA EAX,[EBP + 0xffffff2c]
00631ad3 : PUSH EAX
00631ad4 : LEA ECX,[EBP + -0x2c]
00631ad7 : CALL 0x00438b10
00631adc : MOV ECX,dword ptr [EAX]
00631ade : MOV EAX,dword ptr [EAX + 0x4]
00631ae1 : MOV dword ptr [EBP + 0xffffff60],ECX
00631ae7 : MOV dword ptr [EBP + 0xffffff64],EAX
00631aed : JMP 0x00631b38
00631aef : LEA EAX,[EBP + 0xffffff34]
00631af5 : PUSH EAX
00631af6 : LEA ECX,[EBP + -0x2c]
00631af9 : CALL 0x00435d10
00631afe : PUSH EAX
00631aff : LEA ECX,[EBP + 0xffffff60]
00631b05 : CALL 0x0063085b
00631b0a : TEST AL,AL
00631b0c : JZ 0x00631b47
00631b0e : LEA ECX,[EBP + 0xffffff60]
00631b14 : CALL 0x00412cf0
00631b19 : MOV ECX,EBX
00631b1b : MOV ESI,EAX
00631b1d : CALL 0x0062317a
00631b22 : CMP AL,byte ptr [ESI]
00631b24 : JNZ 0x00631b47
00631b26 : LEA ECX,[EBP + 0xffffff60]
00631b2c : CALL 0x0063066c
00631b31 : MOV ECX,EBX
00631b33 : CALL 0x006230d9
00631b38 : PUSH dword ptr [EBP + -0x74]
00631b3b : PUSH EBX
00631b3c : CALL 0x0062318f
00631b41 : POP ECX
00631b42 : POP ECX
00631b43 : TEST AL,AL
00631b45 : JNZ 0x00631aef
00631b47 : LEA EAX,[EBP + 0xffffff3c]
00631b4d : PUSH EAX
00631b4e : LEA ECX,[EBP + -0x2c]
00631b51 : CALL 0x00435d10
00631b56 : PUSH EAX
00631b57 : LEA ECX,[EBP + 0xffffff60]
00631b5d : CALL 0x0063085b
00631b62 : TEST AL,AL
00631b64 : JZ 0x00631b6a
00631b66 : MOV byte ptr [EBP + -0x65],0x1
00631b6a : LEA ECX,[EBP + -0x2c]
00631b6d : PUSH 0x0
00631b6f : PUSH 0x1
00631b71 : MOV byte ptr [EBP + -0x4],0x3
00631b75 : CALL 0x00405260
00631b7a : JMP 0x00631ba5
00631b7c : MOV ECX,EBX
00631b7e : CALL 0x0062317a
00631b83 : MOV ECX,dword ptr [ESI + 0x10]
00631b86 : MOVZX EAX,AL
00631b89 : TEST byte ptr [ECX + EAX*0x2],0x48
00631b8d : JZ 0x00631ba5
00631b8f : MOV ECX,EBX
00631b91 : CALL 0x006230d9
00631b96 : PUSH dword ptr [EBP + -0x74]
00631b99 : PUSH EBX
00631b9a : CALL 0x0062318f
00631b9f : POP ECX
00631ba0 : POP ECX
00631ba1 : TEST AL,AL
00631ba3 : JNZ 0x00631b7c
00631ba5 : INC dword ptr [EBP + 0xffffff68]
00631bab : CMP byte ptr [EBP + -0x65],0x0
00631baf : MOV EBX,dword ptr [EBP + 0xffffff6c]
00631bb5 : JZ 0x00631573
00631bbb : CMP byte ptr [EBP + -0x65],0x0
00631bbf : JNZ 0x00631c72
00631bc5 : CMP dword ptr [EBP + -0x50],0x1
00631bc9 : JBE 0x00631c80
00631bcf : AND dword ptr [EBP + 0xffffff74],0x0
00631bd6 : AND dword ptr [EBP + 0xffffff78],0x0
00631bdd : LEA EAX,[EBP + 0xffffff3c]
00631be3 : PUSH EAX
00631be4 : LEA ECX,[EBP + -0x64]
00631be7 : CALL 0x00438b10
00631bec : MOV ECX,dword ptr [EAX]
00631bee : MOV dword ptr [EBP + 0xffffff74],ECX
00631bf4 : MOV EAX,dword ptr [EAX + 0x4]
00631bf7 : MOV dword ptr [EBP + 0xffffff78],EAX
00631bfd : JMP 0x00631c2d
00631bff : PUSH dword ptr [EBP + -0x74]
00631c02 : PUSH EBX
00631c03 : CALL 0x0062318f
00631c08 : POP ECX
00631c09 : POP ECX
00631c0a : TEST AL,AL
00631c0c : JZ 0x00631c53
00631c0e : LEA ECX,[EBP + 0xffffff74]
00631c14 : CALL 0x00412cf0
00631c19 : MOV ECX,EBX
00631c1b : MOV ESI,EAX
00631c1d : CALL 0x0062317a
00631c22 : CMP AL,byte ptr [ESI]
00631c24 : JNZ 0x00631c53
00631c26 : MOV ECX,EBX
00631c28 : CALL 0x006230d9
00631c2d : LEA EAX,[EBP + 0xffffff60]
00631c33 : PUSH EAX
00631c34 : LEA ECX,[EBP + -0x64]
00631c37 : CALL 0x00435d10
00631c3c : PUSH EAX
00631c3d : LEA ECX,[EBP + 0xffffff74]
00631c43 : CALL 0x0063066c
00631c48 : MOV ECX,EAX
00631c4a : CALL 0x0063085b
00631c4f : TEST AL,AL
00631c51 : JNZ 0x00631bff
00631c53 : LEA EAX,[EBP + 0xffffff3c]
00631c59 : PUSH EAX
00631c5a : LEA ECX,[EBP + -0x64]
00631c5d : CALL 0x00435d10
00631c62 : PUSH EAX
00631c63 : LEA ECX,[EBP + 0xffffff74]
00631c69 : CALL 0x0063085b
00631c6e : TEST AL,AL
00631c70 : JZ 0x00631c80
00631c72 : MOV ECX,dword ptr [EBP + -0x7c]
00631c75 : PUSH -0x1
00631c77 : PUSH 0x0
00631c79 : CALL 0x00404de0
00631c7e : JMP 0x00631c94
00631c80 : CMP byte ptr [EBP + -0x75],0x0
00631c84 : JZ 0x00631c94
00631c86 : MOV ECX,dword ptr [EBP + -0x7c]
00631c89 : PUSH 0x2d
00631c8b : PUSH 0x1
00631c8d : PUSH 0x0
00631c8f : CALL 0x004360a0
00631c94 : PUSH 0x0
00631c96 : PUSH 0x1
00631c98 : LEA ECX,[EBP + -0x64]
00631c9b : CALL 0x00405260
00631ca0 : MOV EAX,dword ptr [EBP + -0x7c]
00631ca3 : CALL 0x00640ed0
00631ca8 : RET 0x14
