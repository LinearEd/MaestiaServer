PROGRAM  : Maestia.exe
FUNCTION : FUN_006012c0
ENTRY    : 006012c0
BODY     : [[006012c0, 00601309] [00601310, 0060150e]]

============================================================
DECOMPILED C CODE
============================================================

undefined4 FUN_006012c0(int param_1,undefined4 param_2,float param_3)

{
  float *pfVar1;
  undefined2 *puVar2;
  int iVar3;
  int iVar4;
  int *piVar5;
  float fVar6;
  undefined4 uVar7;
  bool bVar8;
  bool bVar9;
  undefined4 uVar10;
  uint uVar11;
  uint *in_ECX;
  code *pcVar12;
  int iVar13;
  undefined4 local_10;
  uint local_c;
  uint local_8;
  
  FUN_005f8d90(*in_ECX);
  iVar3 = **(int **)(param_1 + 0xc);
  if (in_ECX[0x20] == 0) {
    local_8 = 0;
  }
  else {
    local_8 = in_ECX[0x21];
  }
  local_c = 0;
  if (*in_ECX != 0) {
    do {
      iVar4 = *(int *)(in_ECX[3] + (local_c >> 8) * 4);
      pfVar1 = (float *)(iVar4 + (local_c & 0xff) * 0xc);
      iVar13 = *(int *)(*(int *)(param_1 + 0xc) + 4) * local_c + *(int *)(param_1 + 8);
      piVar5 = *(int **)(*(int *)(param_1 + 0xc) + 8);
      (**(code **)(*piVar5 + 4))
                (iVar13,param_3 * *pfVar1,*(float *)(iVar4 + 4 + (local_c & 0xff) * 0xc) * param_3,0
                );
      fVar6 = pfVar1[2];
      uVar11 = (uint)fVar6 & 0xffffff;
      bVar8 = (int)local_8 <= (int)uVar11;
      if ((bVar8) || (*(char *)(in_ECX[0x20] + uVar11 * 0x28) == '\0')) {
        bVar9 = true;
      }
      else {
        bVar9 = false;
      }
      if (((uint)fVar6 & 0x80000000) == 0) {
        if (bVar8) {
          local_10 = 0xffffffff;
LAB_0060148d:
          (**(code **)(*piVar5 + 0x10))(iVar13,local_10);
        }
        else if (bVar9) {
          uVar7 = *(undefined4 *)(in_ECX[0x20] + 4 + uVar11 * 0x28);
          local_10._1_3_ = (undefined3)((uint)uVar7 >> 8);
          local_10 = CONCAT31(local_10._1_3_,(char)((uint)uVar7 >> 0x10));
          uVar10 = local_10;
          local_10._3_1_ = (undefined1)((uint)uVar7 >> 0x18);
          local_10._0_2_ = (undefined2)uVar10;
          local_10._0_3_ = CONCAT12((char)uVar7,(undefined2)local_10);
          goto LAB_0060148d;
        }
        uVar11 = in_ECX[0x23] | 0xff000000;
LAB_006014a3:
        pcVar12 = *(code **)(*piVar5 + 0x14);
LAB_006014a9:
        (*pcVar12)(iVar13,uVar11);
      }
      else {
        if (iVar3 != 3) {
          if (bVar8) {
            (**(code **)(*piVar5 + 0x10))(iVar13,0xffffffff);
            uVar11 = in_ECX[0x23];
          }
          else {
            if (!bVar9) {
              pcVar12 = *(code **)(*piVar5 + 0x14);
              uVar11 = 0xffffff;
              goto LAB_006014a9;
            }
            uVar7 = *(undefined4 *)(in_ECX[0x20] + 4 + uVar11 * 0x28);
            local_10._1_3_ = (undefined3)((uint)uVar7 >> 8);
            local_10 = CONCAT31(local_10._1_3_,(char)((uint)uVar7 >> 0x10));
            uVar10 = local_10;
            local_10._3_1_ = (undefined1)((uint)uVar7 >> 0x18);
            local_10._0_2_ = (undefined2)uVar10;
            local_10._0_3_ = CONCAT12((char)uVar7,(undefined2)local_10);
            (**(code **)(*piVar5 + 0x10))(iVar13,local_10);
            uVar11 = in_ECX[0x23];
          }
          goto LAB_006014a3;
        }
        if (bVar8) {
          pcVar12 = *(code **)(*piVar5 + 0x10);
          uVar11 = 0xffffff;
          goto LAB_006014a9;
        }
        if (bVar9) {
          uVar7 = *(undefined4 *)(in_ECX[0x20] + 4 + uVar11 * 0x28);
          local_10._1_3_ = (undefined3)((uint)uVar7 >> 8);
          local_10 = CONCAT31(local_10._1_3_,(char)((uint)uVar7 >> 0x10));
          local_10._0_3_ = CONCAT12((char)uVar7,(undefined2)local_10);
          pcVar12 = *(code **)(*piVar5 + 0x10);
          uVar11 = (uint)(uint3)local_10;
          goto LAB_006014a9;
        }
      }
      local_c = local_c + 1;
    } while (local_c < *in_ECX);
  }
  uVar11 = 0;
  if (in_ECX[0x17] != 0) {
    do {
      iVar3 = *(int *)(in_ECX[0x1a] + (uVar11 >> 8) * 4);
      puVar2 = (undefined2 *)(iVar3 + (uVar11 & 0xff) * 0xc);
      FUN_005da450(*puVar2,puVar2[2],*(undefined2 *)(iVar3 + 8 + (uVar11 & 0xff) * 0xc));
      uVar11 = uVar11 + 1;
    } while (uVar11 < in_ECX[0x17]);
  }
  return 1;
}



============================================================
DISASSEMBLY
============================================================
006012c0 : SUB ESP,0x10
006012c3 : PUSH EBP
006012c4 : PUSH ESI
006012c5 : MOV EBP,ECX
006012c7 : MOV EAX,dword ptr [EBP]
006012ca : PUSH EDI
006012cb : MOV EDI,dword ptr [ESP + 0x20]
006012cf : PUSH EAX
006012d0 : MOV ECX,EDI
006012d2 : CALL 0x005f8d90
006012d7 : MOV ECX,dword ptr [EDI + 0xc]
006012da : MOV EDX,dword ptr [ECX]
006012dc : XOR ECX,ECX
006012de : MOV dword ptr [ESP + 0x18],EDX
006012e2 : CMP dword ptr [EBP + 0x80],ECX
006012e8 : JZ 0x006012f6
006012ea : MOV EAX,dword ptr [EBP + 0x84]
006012f0 : MOV dword ptr [ESP + 0x14],EAX
006012f4 : JMP 0x006012fa
006012f6 : MOV dword ptr [ESP + 0x14],ECX
006012fa : MOV dword ptr [ESP + 0x10],ECX
006012fe : CMP dword ptr [EBP],ECX
00601301 : JBE 0x006014c1
00601307 : PUSH EBX
00601308 : JMP 0x00601318
00601310 : MOV ECX,dword ptr [ESP + 0x14]
00601314 : MOV EDI,dword ptr [ESP + 0x24]
00601318 : MOV ESI,dword ptr [EBP + 0xc]
0060131b : FLD float ptr [ESP + 0x2c]
0060131f : MOV EDX,ECX
00601321 : MOV EAX,ECX
00601323 : AND EAX,0xff
00601328 : SHR EDX,0x8
0060132b : MOV EDX,dword ptr [ESI + EDX*0x4]
0060132e : LEA EAX,[EAX + EAX*0x2]
00601331 : FLD float ptr [EDX + EAX*0x4 + 0x4]
00601335 : LEA EBX,[EDX + EAX*0x4]
00601338 : MOV EAX,dword ptr [EDI + 0xc]
0060133b : FMUL ST1
0060133d : MOV ESI,dword ptr [EAX + 0x4]
00601340 : IMUL ESI,ECX
00601343 : FSTP float ptr [ESP + 0x10]
00601347 : FLD float ptr [ESP + 0x10]
0060134b : ADD ESI,dword ptr [EDI + 0x8]
0060134e : MOV EDI,dword ptr [EAX + 0x8]
00601351 : MOV EAX,dword ptr [EDI]
00601353 : MOV EDX,dword ptr [EAX + 0x4]
00601356 : PUSH 0x0
00601358 : SUB ESP,0x8
0060135b : MOV ECX,EDI
0060135d : FSTP float ptr [ESP + 0x4]
00601361 : FMUL float ptr [EBX]
00601363 : FSTP float ptr [ESP + 0x1c]
00601367 : FLD float ptr [ESP + 0x1c]
0060136b : FSTP float ptr [ESP]
0060136e : PUSH ESI
0060136f : CALL EDX
00601371 : MOV EAX,dword ptr [EBX + 0x8]
00601374 : MOV dword ptr [ESP + 0x10],EAX
00601378 : AND EAX,0xffffff
0060137d : CMP EAX,dword ptr [ESP + 0x18]
00601381 : SETGE CL
00601384 : TEST CL,CL
00601386 : JNZ 0x0060139a
00601388 : MOV EBX,dword ptr [EBP + 0x80]
0060138e : LEA EDX,[EAX + EAX*0x4]
00601391 : CMP byte ptr [EBX + EDX*0x8],CL
00601394 : JZ 0x0060139a
00601396 : XOR DL,DL
00601398 : JMP 0x0060139c
0060139a : MOV DL,0x1
0060139c : TEST dword ptr [ESP + 0x10],0x80000000
006013a4 : JZ 0x0060145e
006013aa : CMP dword ptr [ESP + 0x1c],0x3
006013af : JNZ 0x006013fe
006013b1 : TEST CL,CL
006013b3 : JZ 0x006013c4
006013b5 : MOV EAX,dword ptr [EDI]
006013b7 : MOV EDX,dword ptr [EAX + 0x10]
006013ba : PUSH 0xffffff
006013bf : JMP 0x006014a9
006013c4 : TEST DL,DL
006013c6 : JZ 0x006014ae
006013cc : MOV ECX,dword ptr [EBP + 0x80]
006013d2 : LEA EAX,[EAX + EAX*0x4]
006013d5 : MOV EAX,dword ptr [ECX + EAX*0x8 + 0x4]
006013d9 : MOV EDX,EAX
006013db : MOV dword ptr [ESP + 0x10],EAX
006013df : SHR EDX,0x10
006013e2 : MOV byte ptr [ESP + 0x10],DL
006013e6 : MOV byte ptr [ESP + 0x12],AL
006013ea : MOV EAX,dword ptr [EDI]
006013ec : MOV ECX,dword ptr [ESP + 0x10]
006013f0 : MOV EDX,dword ptr [EAX + 0x10]
006013f3 : AND ECX,0xffffff
006013f9 : JMP 0x006014a8
006013fe : TEST CL,CL
00601400 : JZ 0x00601419
00601402 : MOV EAX,dword ptr [EDI]
00601404 : MOV EDX,dword ptr [EAX + 0x10]
00601407 : PUSH -0x1
00601409 : PUSH ESI
0060140a : MOV ECX,EDI
0060140c : CALL EDX
0060140e : MOV ECX,dword ptr [EBP + 0x8c]
00601414 : JMP 0x006014a3
00601419 : TEST DL,DL
0060141b : JZ 0x00601452
0060141d : MOV ECX,dword ptr [EBP + 0x80]
00601423 : LEA EAX,[EAX + EAX*0x4]
00601426 : MOV EAX,dword ptr [ECX + EAX*0x8 + 0x4]
0060142a : MOV EDX,EAX
0060142c : MOV dword ptr [ESP + 0x10],EAX
00601430 : SHR EDX,0x10
00601433 : MOV byte ptr [ESP + 0x10],DL
00601437 : MOV byte ptr [ESP + 0x12],AL
0060143b : MOV ECX,dword ptr [ESP + 0x10]
0060143f : MOV EAX,dword ptr [EDI]
00601441 : MOV EDX,dword ptr [EAX + 0x10]
00601444 : PUSH ECX
00601445 : PUSH ESI
00601446 : MOV ECX,EDI
00601448 : CALL EDX
0060144a : MOV ECX,dword ptr [EBP + 0x8c]
00601450 : JMP 0x006014a3
00601452 : MOV EAX,dword ptr [EDI]
00601454 : MOV EDX,dword ptr [EAX + 0x14]
00601457 : PUSH 0xffffff
0060145c : JMP 0x006014a9
0060145e : TEST CL,CL
00601460 : JZ 0x00601466
00601462 : PUSH -0x1
00601464 : JMP 0x0060148d
00601466 : TEST DL,DL
00601468 : JZ 0x00601497
0060146a : MOV ECX,dword ptr [EBP + 0x80]
00601470 : LEA EAX,[EAX + EAX*0x4]
00601473 : MOV EAX,dword ptr [ECX + EAX*0x8 + 0x4]
00601477 : MOV EDX,EAX
00601479 : MOV dword ptr [ESP + 0x10],EAX
0060147d : SHR EDX,0x10
00601480 : MOV byte ptr [ESP + 0x10],DL
00601484 : MOV byte ptr [ESP + 0x12],AL
00601488 : MOV ECX,dword ptr [ESP + 0x10]
0060148c : PUSH ECX
0060148d : MOV EAX,dword ptr [EDI]
0060148f : MOV EDX,dword ptr [EAX + 0x10]
00601492 : PUSH ESI
00601493 : MOV ECX,EDI
00601495 : CALL EDX
00601497 : MOV ECX,dword ptr [EBP + 0x8c]
0060149d : OR ECX,0xff000000
006014a3 : MOV EAX,dword ptr [EDI]
006014a5 : MOV EDX,dword ptr [EAX + 0x14]
006014a8 : PUSH ECX
006014a9 : PUSH ESI
006014aa : MOV ECX,EDI
006014ac : CALL EDX
006014ae : MOV EAX,dword ptr [ESP + 0x14]
006014b2 : INC EAX
006014b3 : MOV dword ptr [ESP + 0x14],EAX
006014b7 : CMP EAX,dword ptr [EBP]
006014ba : JC 0x00601310
006014c0 : POP EBX
006014c1 : XOR ESI,ESI
006014c3 : CMP dword ptr [EBP + 0x5c],ESI
006014c6 : JBE 0x00601504
006014c8 : MOV EDI,dword ptr [ESP + 0x24]
006014cc : LEA ESP,[ESP]
006014d0 : MOV EDX,dword ptr [EBP + 0x68]
006014d3 : MOV ECX,ESI
006014d5 : SHR ECX,0x8
006014d8 : MOV ECX,dword ptr [EDX + ECX*0x4]
006014db : MOV EAX,ESI
006014dd : AND EAX,0xff
006014e2 : LEA EAX,[EAX + EAX*0x2]
006014e5 : MOVZX EDX,word ptr [ECX + EAX*0x4 + 0x8]
006014ea : LEA EAX,[ECX + EAX*0x4]
006014ed : MOVZX ECX,word ptr [EAX + 0x4]
006014f1 : PUSH EDX
006014f2 : MOVZX EDX,word ptr [EAX]
006014f5 : PUSH ECX
006014f6 : PUSH EDX
006014f7 : MOV ECX,EDI
006014f9 : CALL 0x005da450
006014fe : INC ESI
006014ff : CMP ESI,dword ptr [EBP + 0x5c]
00601502 : JC 0x006014d0
00601504 : POP EDI
00601505 : POP ESI
00601506 : MOV AL,0x1
00601508 : POP EBP
00601509 : ADD ESP,0x10
0060150c : RET 0xc
