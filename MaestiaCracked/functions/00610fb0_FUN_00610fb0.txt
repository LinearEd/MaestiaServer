PROGRAM  : Maestia.exe
FUNCTION : FUN_00610fb0
ENTRY    : 00610fb0
BODY     : [[00610fb0, 00611353]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00610fb0(int param_1,int *param_2,int param_3,uint param_4,int param_5)

{
  uint *puVar1;
  byte bVar2;
  int iVar3;
  short sVar4;
  int iVar5;
  int iVar6;
  int in_ECX;
  undefined2 uVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  int *piVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 local_18;
  int local_14;
  int local_10;
  int local_c;
  uint local_8;
  int local_4;
  
  sVar4 = *(short *)(in_ECX + 0x6c) * -4;
  puVar1 = (uint *)(in_ECX + 0x30);
  *puVar1 = 0;
  uVar10 = *puVar1 >> 6;
  local_18 = CONCAT22(sVar4,sVar4);
  local_10 = in_ECX;
  if (*(uint *)(in_ECX + 0x34) <= uVar10) {
    FUN_00610bf0(uVar10);
  }
  iVar6 = (int)param_2;
  *(undefined4 *)(*(int *)(*(int *)(in_ECX + 0x3c) + uVar10 * 4) + (*puVar1 & 0x3f) * 4) = local_18;
  *puVar1 = *puVar1 + 1;
  iVar9 = *(int *)(in_ECX + 0x6c);
  local_14 = -0x7fff;
  local_c = ((int)(iVar9 + (int)param_2 + param_4) / (int)param_2) * (int)param_2 - iVar9;
  param_2 = (int *)(((iVar9 + (int)param_2 + param_5) / (int)param_2) * (int)param_2 - iVar9);
  if (param_1 == 1) {
    sVar4 = *(short *)(in_ECX + 0x58);
  }
  else {
    sVar4 = *(short *)(in_ECX + 0x5a);
  }
  iVar8 = (int)sVar4;
  local_8 = 0;
  iVar9 = in_ECX;
  local_4 = iVar8;
  if (*(int *)(in_ECX + 0x28) != 0) {
    do {
      bVar2 = *(byte *)(local_8 + *(int *)(iVar9 + 0x24));
      uVar7 = (undefined2)iVar8;
      iVar3 = local_14;
      if ((param_3 < iVar8) && (param_1 != 1)) {
        if ((bVar2 & 2) != 0) {
          if (param_5 == 0) {
LAB_00611151:
            iVar5 = ((iVar8 + *(int *)(iVar9 + 0x6c) + iVar6) / iVar6) * iVar6 -
                    *(int *)(iVar9 + 0x6c);
            if (((iVar8 <= iVar6 + 1 + local_14) ||
                (iVar5 <= *(short *)(*(int *)(*(int *)(in_ECX + 0x3c) + (*puVar1 - 1 >> 6) * 4) + 2
                                    + (*puVar1 - 1 & 0x3f) * 4) + iVar6)) && (*puVar1 != 0)) {
              *puVar1 = *puVar1 - 1;
            }
            goto LAB_006111d8;
          }
          if ((iVar8 < param_5) || (iVar6 + 1 + param_5 <= iVar8)) {
            if ((iVar8 < (int)param_4) || ((int)(iVar6 + 1 + param_4) <= iVar8)) goto LAB_00611151;
            if (((iVar8 <= iVar6 + 1 + local_14) ||
                (local_c <=
                 *(short *)(*(int *)(*(int *)(in_ECX + 0x3c) + (*puVar1 - 1 >> 6) * 4) + 2 +
                           (*puVar1 - 1 & 0x3f) * 4) + iVar6)) && (*puVar1 != 0)) {
              *puVar1 = *puVar1 - 1;
            }
            local_18 = CONCAT22((undefined2)local_c,uVar7);
            FUN_00610e70(&local_18);
            iVar3 = iVar8;
          }
          else {
            if (((iVar8 <= iVar6 + 1 + local_14) ||
                ((int)param_2 <=
                 *(short *)(*(int *)(*(int *)(in_ECX + 0x3c) + (*puVar1 - 1 >> 6) * 4) + 2 +
                           (*puVar1 - 1 & 0x3f) * 4) + iVar6)) && (*puVar1 != 0)) {
              *puVar1 = *puVar1 - 1;
            }
            local_18 = CONCAT22((short)param_2,uVar7);
            FUN_00610e70(&local_18);
            iVar3 = iVar8;
          }
        }
      }
      else if (((bVar2 & 1) != 0) &&
              ((iVar6 + 1 + local_14 < iVar8 &&
               (iVar5 = ((iVar6 / 2 + *(int *)(iVar9 + 0x6c) + 1 + iVar8) / iVar6) * iVar6 -
                        *(int *)(iVar9 + 0x6c), iVar9 = local_10, iVar3 = iVar8,
               *(short *)(*(int *)(*(int *)(in_ECX + 0x3c) + (*puVar1 - 1 >> 6) * 4) + 2 +
                         (*puVar1 - 1 & 0x3f) * 4) != iVar5)))) {
LAB_006111d8:
        uVar10 = *puVar1 >> 6;
        local_18 = CONCAT22((short)iVar5,uVar7);
        if (*(uint *)(in_ECX + 0x34) <= uVar10) {
          FUN_00610bf0(uVar10);
        }
        *(undefined4 *)(*(int *)(*(int *)(in_ECX + 0x3c) + uVar10 * 4) + (*puVar1 & 0x3f) * 4) =
             local_18;
        *puVar1 = *puVar1 + 1;
        iVar9 = local_10;
        iVar3 = iVar8;
      }
      local_14 = iVar3;
      local_8 = local_8 + 1;
      iVar8 = iVar8 + 1;
    } while (local_8 < *(uint *)(iVar9 + 0x28));
  }
  sVar4 = *(short *)(iVar9 + 0x6c) * 4;
  uVar10 = *puVar1 >> 6;
  local_18 = CONCAT22(sVar4,sVar4);
  if (*(uint *)(in_ECX + 0x34) <= uVar10) {
    FUN_00610bf0(uVar10);
  }
  *(undefined4 *)(*(int *)(*(int *)(in_ECX + 0x3c) + uVar10 * 4) + (*puVar1 & 0x3f) * 4) = local_18;
  *puVar1 = *puVar1 + 1;
  piVar11 = (int *)(iVar9 + 0x40);
  if (param_1 != 1) {
    piVar11 = (int *)(iVar9 + 0x4c);
  }
  uVar10 = *(uint *)(iVar9 + 0x28);
  param_2 = piVar11;
  if ((uint)piVar11[2] < uVar10) {
    FUN_00515cf0(*piVar11);
    piVar11[2] = uVar10;
    if (uVar10 == 0) {
      iVar6 = 0;
    }
    else {
      param_1 = 2;
      iVar6 = FUN_00515d60(piVar11,uVar10 * 2,&param_1);
    }
    *piVar11 = iVar6;
  }
  piVar11[1] = uVar10;
  param_5 = *(undefined4 *)**(int **)(iVar9 + 0x3c);
  uVar10 = 0;
  param_4 = 2;
  if (*(int *)(iVar9 + 0x28) != 0) {
    param_1 = local_4;
    uVar12 = ((undefined4 *)**(int **)(iVar9 + 0x3c))[1];
    do {
      uVar13 = uVar12;
      if (((short)uVar12 <= param_1) && (param_4 < *puVar1)) {
        uVar13 = *(undefined4 *)
                  (*(int *)(*(int *)(iVar9 + 0x3c) + (param_4 >> 6) * 4) + (param_4 & 0x3f) * 4);
        param_4 = param_4 + 1;
        param_5 = uVar12;
      }
      sVar4 = (short)((uint)param_5 >> 0x10);
      iVar9 = param_1 - (short)param_5;
      param_1 = param_1 + 1;
      uVar10 = uVar10 + 1;
      *(short *)(*param_2 + -2 + uVar10 * 2) =
           ((short)((((int)(short)((uint)uVar13 >> 0x10) - (int)sVar4) * iVar9) /
                   ((int)(short)uVar13 - (int)(short)param_5)) - (short)local_4) + sVar4;
      iVar9 = local_10;
      uVar12 = uVar13;
    } while (uVar10 < *(uint *)(local_10 + 0x28));
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
00610fb0 : SUB ESP,0x18
00610fb3 : PUSH EBX
00610fb4 : PUSH EBP
00610fb5 : MOV EBP,ECX
00610fb7 : MOV AX,word ptr [EBP + 0x6c]
00610fbb : IMUL AX,AX,-0x4
00610fbf : PUSH ESI
00610fc0 : LEA ESI,[EBP + 0x30]
00610fc3 : PUSH EDI
00610fc4 : MOV dword ptr [ESI],0x0
00610fca : MOV EDI,dword ptr [ESI]
00610fcc : SHR EDI,0x6
00610fcf : MOV dword ptr [ESP + 0x18],EBP
00610fd3 : MOV word ptr [ESP + 0x10],AX
00610fd8 : MOV word ptr [ESP + 0x12],AX
00610fdd : CMP EDI,dword ptr [ESI + 0x4]
00610fe0 : JC 0x00610fea
00610fe2 : PUSH EDI
00610fe3 : MOV ECX,ESI
00610fe5 : CALL 0x00610bf0
00610fea : MOV EAX,dword ptr [ESI + 0xc]
00610fed : MOV EDX,dword ptr [EAX + EDI*0x4]
00610ff0 : MOV ECX,dword ptr [ESI]
00610ff2 : MOV EDI,dword ptr [ESP + 0x30]
00610ff6 : MOV EAX,dword ptr [ESP + 0x10]
00610ffa : AND ECX,0x3f
00610ffd : MOV dword ptr [EDX + ECX*0x4],EAX
00611000 : INC dword ptr [ESI]
00611002 : MOV ECX,dword ptr [EBP + 0x6c]
00611005 : LEA EAX,[ECX + EDI*0x1]
00611008 : ADD EAX,dword ptr [ESP + 0x38]
0061100c : MOV dword ptr [ESP + 0x14],0xffff8001
00611014 : CDQ
00611015 : IDIV EDI
00611017 : IMUL EAX,EDI
0061101a : SUB EAX,ECX
0061101c : MOV dword ptr [ESP + 0x1c],EAX
00611020 : LEA EAX,[ECX + EDI*0x1]
00611023 : ADD EAX,dword ptr [ESP + 0x3c]
00611027 : CDQ
00611028 : IDIV EDI
0061102a : IMUL EAX,EDI
0061102d : SUB EAX,ECX
0061102f : CMP dword ptr [ESP + 0x2c],0x1
00611034 : MOV dword ptr [ESP + 0x30],EAX
00611038 : JNZ 0x00611040
0061103a : MOVZX EAX,word ptr [EBP + 0x58]
0061103e : JMP 0x00611044
00611040 : MOVZX EAX,word ptr [EBP + 0x5a]
00611044 : MOVSX EBX,AX
00611047 : XOR EAX,EAX
00611049 : MOV dword ptr [ESP + 0x24],EBX
0061104d : MOV dword ptr [ESP + 0x20],EAX
00611051 : CMP dword ptr [EBP + 0x28],EAX
00611054 : JBE 0x00611223
0061105a : LEA EBX,[EBX]
00611060 : CMP EBX,dword ptr [ESP + 0x34]
00611064 : MOV ECX,dword ptr [EBP + 0x24]
00611067 : MOV AL,byte ptr [EAX + ECX*0x1]
0061106a : JLE 0x00611195
00611070 : CMP dword ptr [ESP + 0x2c],0x1
00611075 : JZ 0x00611195
0061107b : TEST AL,0x2
0061107d : JZ 0x00611210
00611083 : MOV EAX,dword ptr [ESP + 0x3c]
00611087 : TEST EAX,EAX
00611089 : JZ 0x00611151
0061108f : CMP EBX,EAX
00611091 : JL 0x006110ee
00611093 : LEA EDX,[EDI + EAX*0x1 + 0x1]
00611097 : CMP EBX,EDX
00611099 : JGE 0x006110ee
0061109b : MOV EAX,dword ptr [ESP + 0x14]
0061109f : LEA ECX,[EDI + EAX*0x1 + 0x1]
006110a3 : CMP EBX,ECX
006110a5 : JLE 0x006110c5
006110a7 : MOV EAX,dword ptr [ESI]
006110a9 : MOV ECX,dword ptr [ESI + 0xc]
006110ac : DEC EAX
006110ad : MOV EDX,EAX
006110af : SHR EDX,0x6
006110b2 : MOV EDX,dword ptr [ECX + EDX*0x4]
006110b5 : AND EAX,0x3f
006110b8 : MOVSX EAX,word ptr [EDX + EAX*0x4 + 0x2]
006110bd : ADD EAX,EDI
006110bf : CMP EAX,dword ptr [ESP + 0x30]
006110c3 : JL 0x006110ce
006110c5 : MOV EAX,dword ptr [ESI]
006110c7 : TEST EAX,EAX
006110c9 : JZ 0x006110ce
006110cb : DEC EAX
006110cc : MOV dword ptr [ESI],EAX
006110ce : MOV CX,word ptr [ESP + 0x30]
006110d3 : LEA EDX,[ESP + 0x10]
006110d7 : MOV word ptr [ESP + 0x12],CX
006110dc : PUSH EDX
006110dd : MOV ECX,ESI
006110df : MOV word ptr [ESP + 0x14],BX
006110e4 : CALL 0x00610e70
006110e9 : JMP 0x0061120c
006110ee : MOV EAX,dword ptr [ESP + 0x38]
006110f2 : CMP EBX,EAX
006110f4 : JL 0x00611151
006110f6 : LEA EAX,[EDI + EAX*0x1 + 0x1]
006110fa : CMP EBX,EAX
006110fc : JGE 0x00611151
006110fe : MOV ECX,dword ptr [ESP + 0x14]
00611102 : LEA EDX,[EDI + ECX*0x1 + 0x1]
00611106 : CMP EBX,EDX
00611108 : JLE 0x00611128
0061110a : MOV EAX,dword ptr [ESI]
0061110c : MOV EDX,dword ptr [ESI + 0xc]
0061110f : DEC EAX
00611110 : MOV ECX,EAX
00611112 : SHR ECX,0x6
00611115 : MOV ECX,dword ptr [EDX + ECX*0x4]
00611118 : AND EAX,0x3f
0061111b : MOVSX EDX,word ptr [ECX + EAX*0x4 + 0x2]
00611120 : ADD EDX,EDI
00611122 : CMP EDX,dword ptr [ESP + 0x1c]
00611126 : JL 0x00611131
00611128 : MOV EAX,dword ptr [ESI]
0061112a : TEST EAX,EAX
0061112c : JZ 0x00611131
0061112e : DEC EAX
0061112f : MOV dword ptr [ESI],EAX
00611131 : MOV AX,word ptr [ESP + 0x1c]
00611136 : LEA ECX,[ESP + 0x10]
0061113a : PUSH ECX
0061113b : MOV ECX,ESI
0061113d : MOV word ptr [ESP + 0x14],BX
00611142 : MOV word ptr [ESP + 0x16],AX
00611147 : CALL 0x00610e70
0061114c : JMP 0x0061120c
00611151 : MOV EBP,dword ptr [EBP + 0x6c]
00611154 : LEA EAX,[EBX + EBP*0x1]
00611157 : ADD EAX,EDI
00611159 : CDQ
0061115a : IDIV EDI
0061115c : MOV EDX,dword ptr [ESP + 0x14]
00611160 : LEA ECX,[EDI + EDX*0x1 + 0x1]
00611164 : IMUL EAX,EDI
00611167 : SUB EAX,EBP
00611169 : CMP EBX,ECX
0061116b : JLE 0x0061118a
0061116d : MOV ECX,dword ptr [ESI]
0061116f : MOV EBP,dword ptr [ESI + 0xc]
00611172 : DEC ECX
00611173 : MOV EDX,ECX
00611175 : SHR EDX,0x6
00611178 : MOV EDX,dword ptr [EBP + EDX*0x4]
0061117c : AND ECX,0x3f
0061117f : MOVSX ECX,word ptr [EDX + ECX*0x4 + 0x2]
00611184 : ADD ECX,EDI
00611186 : CMP ECX,EAX
00611188 : JL 0x006111d8
0061118a : MOV ECX,dword ptr [ESI]
0061118c : TEST ECX,ECX
0061118e : JZ 0x006111d8
00611190 : DEC ECX
00611191 : MOV dword ptr [ESI],ECX
00611193 : JMP 0x006111d8
00611195 : TEST AL,0x1
00611197 : JZ 0x00611210
00611199 : MOV EAX,dword ptr [ESP + 0x14]
0061119d : LEA ECX,[EDI + EAX*0x1 + 0x1]
006111a1 : CMP EBX,ECX
006111a3 : JLE 0x00611210
006111a5 : MOV ECX,dword ptr [EBP + 0x6c]
006111a8 : MOV EAX,EDI
006111aa : CDQ
006111ab : SUB EAX,EDX
006111ad : SAR EAX,0x1
006111af : ADD EAX,ECX
006111b1 : LEA EAX,[EAX + EBX*0x1 + 0x1]
006111b5 : CDQ
006111b6 : IDIV EDI
006111b8 : MOV EBP,dword ptr [ESI + 0xc]
006111bb : IMUL EAX,EDI
006111be : SUB EAX,ECX
006111c0 : MOV ECX,dword ptr [ESI]
006111c2 : DEC ECX
006111c3 : MOV EDX,ECX
006111c5 : SHR EDX,0x6
006111c8 : MOV EDX,dword ptr [EBP + EDX*0x4]
006111cc : AND ECX,0x3f
006111cf : MOVSX ECX,word ptr [EDX + ECX*0x4 + 0x2]
006111d4 : CMP ECX,EAX
006111d6 : JZ 0x00611208
006111d8 : MOV EBP,dword ptr [ESI]
006111da : SHR EBP,0x6
006111dd : MOV word ptr [ESP + 0x12],AX
006111e2 : MOV word ptr [ESP + 0x10],BX
006111e7 : CMP EBP,dword ptr [ESI + 0x4]
006111ea : JC 0x006111f4
006111ec : PUSH EBP
006111ed : MOV ECX,ESI
006111ef : CALL 0x00610bf0
006111f4 : MOV EDX,dword ptr [ESI + 0xc]
006111f7 : MOV EAX,dword ptr [ESI]
006111f9 : MOV ECX,dword ptr [EDX + EBP*0x4]
006111fc : MOV EDX,dword ptr [ESP + 0x10]
00611200 : AND EAX,0x3f
00611203 : MOV dword ptr [ECX + EAX*0x4],EDX
00611206 : INC dword ptr [ESI]
00611208 : MOV EBP,dword ptr [ESP + 0x18]
0061120c : MOV dword ptr [ESP + 0x14],EBX
00611210 : MOV EAX,dword ptr [ESP + 0x20]
00611214 : INC EAX
00611215 : INC EBX
00611216 : MOV dword ptr [ESP + 0x20],EAX
0061121a : CMP EAX,dword ptr [EBP + 0x28]
0061121d : JC 0x00611060
00611223 : MOV AX,word ptr [EBP + 0x6c]
00611227 : MOV EDI,dword ptr [ESI]
00611229 : ADD AX,AX
0061122c : ADD AX,AX
0061122f : SHR EDI,0x6
00611232 : MOV word ptr [ESP + 0x10],AX
00611237 : MOV word ptr [ESP + 0x12],AX
0061123c : CMP EDI,dword ptr [ESI + 0x4]
0061123f : JC 0x00611249
00611241 : PUSH EDI
00611242 : MOV ECX,ESI
00611244 : CALL 0x00610bf0
00611249 : MOV EAX,dword ptr [ESI + 0xc]
0061124c : MOV ECX,dword ptr [ESI]
0061124e : MOV EDX,dword ptr [EAX + EDI*0x4]
00611251 : MOV EAX,dword ptr [ESP + 0x10]
00611255 : AND ECX,0x3f
00611258 : MOV dword ptr [EDX + ECX*0x4],EAX
0061125b : INC dword ptr [ESI]
0061125d : CMP dword ptr [ESP + 0x2c],0x1
00611262 : LEA EDI,[EBP + 0x40]
00611265 : JZ 0x0061126a
00611267 : LEA EDI,[EBP + 0x4c]
0061126a : MOV EBX,dword ptr [EBP + 0x28]
0061126d : MOV dword ptr [ESP + 0x30],EDI
00611271 : CMP EBX,dword ptr [EDI + 0x8]
00611274 : JBE 0x006112a2
00611276 : MOV ECX,dword ptr [EDI]
00611278 : PUSH ECX
00611279 : CALL 0x00515cf0
0061127e : MOV dword ptr [EDI + 0x8],EBX
00611281 : TEST EBX,EBX
00611283 : JZ 0x0061129e
00611285 : LEA EDX,[ESP + 0x2c]
00611289 : PUSH EDX
0061128a : LEA EAX,[EBX + EBX*0x1]
0061128d : PUSH EAX
0061128e : PUSH EDI
0061128f : MOV dword ptr [ESP + 0x38],0x2
00611297 : CALL 0x00515d60
0061129c : JMP 0x006112a0
0061129e : XOR EAX,EAX
006112a0 : MOV dword ptr [EDI],EAX
006112a2 : MOV dword ptr [EDI + 0x4],EBX
006112a5 : MOV EAX,dword ptr [EBP + 0x3c]
006112a8 : MOV ECX,dword ptr [EAX]
006112aa : MOV EAX,dword ptr [ECX]
006112ac : MOV EDI,dword ptr [ECX + 0x4]
006112af : XOR EBX,EBX
006112b1 : MOV dword ptr [ESP + 0x3c],EAX
006112b5 : MOV dword ptr [ESP + 0x38],0x2
006112bd : CMP dword ptr [EBP + 0x28],EBX
006112c0 : JBE 0x0061134a
006112c6 : MOV ECX,dword ptr [ESP + 0x24]
006112ca : MOV dword ptr [ESP + 0x2c],ECX
006112ce : JMP 0x006112d8
006112d0 : MOV EAX,dword ptr [ESP + 0x3c]
006112d4 : MOV EBP,dword ptr [ESP + 0x18]
006112d8 : MOVSX EDX,DI
006112db : CMP dword ptr [ESP + 0x2c],EDX
006112df : JL 0x00611307
006112e1 : MOV ECX,dword ptr [ESP + 0x38]
006112e5 : CMP ECX,dword ptr [ESI]
006112e7 : JNC 0x00611307
006112e9 : MOV EAX,EDI
006112eb : MOV EDI,dword ptr [EBP + 0x3c]
006112ee : MOV EDX,ECX
006112f0 : MOV EBP,ECX
006112f2 : SHR EDX,0x6
006112f5 : MOV EDX,dword ptr [EDI + EDX*0x4]
006112f8 : AND EBP,0x3f
006112fb : MOV EDI,dword ptr [EDX + EBP*0x4]
006112fe : INC ECX
006112ff : MOV dword ptr [ESP + 0x3c],EAX
00611303 : MOV dword ptr [ESP + 0x38],ECX
00611307 : MOVSX EDX,AX
0061130a : MOV ECX,EAX
0061130c : SHR ECX,0x10
0061130f : MOV EAX,EDI
00611311 : SHR EAX,0x10
00611314 : CWDE
00611315 : MOVSX EBP,CX
00611318 : SUB EAX,EBP
0061131a : MOV EBP,dword ptr [ESP + 0x2c]
0061131e : SUB EBP,EDX
00611320 : IMUL EAX,EBP
00611323 : MOVSX EBP,DI
00611326 : SUB EBP,EDX
00611328 : CDQ
00611329 : IDIV EBP
0061132b : INC dword ptr [ESP + 0x2c]
0061132f : INC EBX
00611330 : SUB EAX,dword ptr [ESP + 0x24]
00611334 : ADD EAX,ECX
00611336 : MOV ECX,dword ptr [ESP + 0x30]
0061133a : MOV EDX,dword ptr [ECX]
0061133c : MOV word ptr [EDX + EBX*0x2 + -0x2],AX
00611341 : MOV EAX,dword ptr [ESP + 0x18]
00611345 : CMP EBX,dword ptr [EAX + 0x28]
00611348 : JC 0x006112d0
0061134a : POP EDI
0061134b : POP ESI
0061134c : POP EBP
0061134d : POP EBX
0061134e : ADD ESP,0x18
00611351 : RET 0x14
