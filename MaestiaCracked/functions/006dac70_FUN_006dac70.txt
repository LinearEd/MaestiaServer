PROGRAM  : Maestia.exe
FUNCTION : FUN_006dac70
ENTRY    : 006dac70
BODY     : [[006dac70, 006dae5c] [006dae60, 006daf31]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_006dac70(int *param_1,char param_2,int param_3,int *param_4)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  int *piVar5;
  int iVar6;
  int iVar7;
  undefined1 *puVar8;
  uint _Size;
  undefined1 *puVar9;
  int iVar10;
  int local_528;
  int iStack_524;
  int iStack_520;
  int iStack_51c;
  int iStack_518;
  int *local_514;
  int aiStack_510 [258];
  char acStack_108 [260];
  uint local_4;
  
  local_4 = DAT_00d66fa0 ^ (uint)&local_528;
  local_514 = param_1;
  if ((param_3 < 0) || (3 < param_3)) {
    *(undefined4 *)(*param_1 + 0x14) = 0x32;
    *(int *)(*param_1 + 0x18) = param_3;
    (**(code **)*param_1)(param_1);
  }
  if (param_2 == '\0') {
    iVar6 = param_1[param_3 + 0x2c];
  }
  else {
    iVar6 = param_1[param_3 + 0x28];
  }
  local_528 = iVar6;
  if (iVar6 == 0) {
    *(undefined4 *)(*param_1 + 0x14) = 0x32;
    *(int *)(*param_1 + 0x18) = param_3;
    (**(code **)*param_1)(param_1);
  }
  if (*param_4 == 0) {
    iVar2 = (**(code **)param_1[1])(param_1,1,0x590);
    *param_4 = iVar2;
  }
  iVar2 = *param_4;
  *(int *)(iVar2 + 0x8c) = iVar6;
  iVar6 = 1;
  iVar10 = 0;
  iStack_524 = iVar2;
  do {
    _Size = (uint)*(byte *)(local_528 + iVar6);
    if (0x100 < (int)(_Size + iVar10)) {
      *(undefined4 *)(*param_1 + 0x14) = 8;
      (**(code **)*param_1)(param_1);
      iVar2 = iStack_524;
    }
    if (_Size != 0) {
      _memset(acStack_108 + iVar10,iVar6,_Size);
      iVar10 = iVar10 + _Size;
      iVar2 = iStack_524;
    }
    iVar6 = iVar6 + 1;
  } while (iVar6 < 0x11);
  acStack_108[iVar10] = '\0';
  aiStack_510[0] = iVar10;
  iVar6 = 0;
  iVar10 = 0;
  iVar7 = (int)acStack_108[0];
  if (acStack_108[0] != '\0') {
    pcVar3 = acStack_108;
    do {
      cVar1 = *pcVar3;
      while (cVar1 == iVar7) {
        cVar1 = acStack_108[iVar10 + 1];
        aiStack_510[iVar10 + 1] = iVar6;
        iVar10 = iVar10 + 1;
        iVar6 = iVar6 + 1;
      }
      if (1 << ((byte)iVar7 & 0x1f) <= iVar6) {
        *(undefined4 *)(*param_1 + 0x14) = 8;
        (**(code **)*param_1)(param_1);
        iVar2 = iStack_524;
      }
      pcVar3 = acStack_108 + iVar10;
      iVar6 = iVar6 * 2;
      iVar7 = iVar7 + 1;
    } while (*pcVar3 != '\0');
  }
  iVar10 = 0;
  iVar6 = 1;
  do {
    if (*(char *)(iVar6 + local_528) == '\0') {
      *(undefined4 *)(iVar2 + iVar6 * 4) = 0xffffffff;
    }
    else {
      *(int *)(iVar2 + 0x48 + iVar6 * 4) = iVar10 - aiStack_510[iVar10 + 1];
      iVar10 = iVar10 + (uint)*(byte *)(iVar6 + local_528);
      *(int *)(iVar2 + iVar6 * 4) = aiStack_510[iVar10];
    }
    iVar6 = iVar6 + 1;
  } while (iVar6 < 0x11);
  *(undefined4 *)(iVar2 + 0x44) = 0xfffff;
  _memset((void *)(iVar2 + 0x90),0,0x400);
  iVar10 = aiStack_510[0];
  iVar2 = local_528;
  iVar7 = 0;
  iVar6 = 1;
  iStack_520 = 7;
  do {
    iStack_51c = 1;
    if (*(char *)(iVar6 + local_528) != '\0') {
      iStack_518 = 1 << ((byte)iStack_520 & 0x1f);
      puVar8 = (undefined1 *)(iVar7 + 0x11 + local_528);
      do {
        iVar4 = aiStack_510[iVar7 + 1] << ((byte)iStack_520 & 0x1f);
        if (0 < iStack_518) {
          puVar9 = (undefined1 *)(iVar4 + 0x490 + iStack_524);
          piVar5 = (int *)(iStack_524 + 0x90 + iVar4 * 4);
          iVar4 = iStack_518;
          do {
            *piVar5 = iVar6;
            *puVar9 = *puVar8;
            iVar4 = iVar4 + -1;
            piVar5 = piVar5 + 1;
            puVar9 = puVar9 + 1;
          } while (0 < iVar4);
        }
        iStack_51c = iStack_51c + 1;
        iVar7 = iVar7 + 1;
        puVar8 = puVar8 + 1;
      } while (iStack_51c <= (int)(uint)*(byte *)(iVar6 + local_528));
    }
    iVar6 = iVar6 + 1;
    iStack_520 = iStack_520 + -1;
  } while (-1 < iStack_520);
  if ((param_2 != '\0') && (iVar6 = 0, 0 < aiStack_510[0])) {
    do {
      if (0xf < *(byte *)(iVar2 + 0x11 + iVar6)) {
        *(undefined4 *)(*local_514 + 0x14) = 8;
        (**(code **)*local_514)(local_514);
      }
      iVar6 = iVar6 + 1;
    } while (iVar6 < iVar10);
  }
  __security_check_cookie(local_4 ^ (uint)&local_528);
  return;
}



============================================================
DISASSEMBLY
============================================================
006dac70 : SUB ESP,0x528
006dac76 : MOV EAX,[0x00d66fa0]
006dac7b : XOR EAX,ESP
006dac7d : MOV dword ptr [ESP + 0x524],EAX
006dac84 : PUSH EBX
006dac85 : MOV EBX,dword ptr [ESP + 0x530]
006dac8c : PUSH ESI
006dac8d : MOV ESI,dword ptr [ESP + 0x53c]
006dac94 : PUSH EDI
006dac95 : MOV EDI,dword ptr [ESP + 0x544]
006dac9c : MOV dword ptr [ESP + 0x20],EBX
006daca0 : TEST ESI,ESI
006daca2 : JL 0x006daca9
006daca4 : CMP ESI,0x4
006daca7 : JL 0x006dacc1
006daca9 : MOV EAX,dword ptr [EBX]
006dacab : MOV dword ptr [EAX + 0x14],0x32
006dacb2 : MOV ECX,dword ptr [EBX]
006dacb4 : MOV dword ptr [ECX + 0x18],ESI
006dacb7 : MOV EDX,dword ptr [EBX]
006dacb9 : MOV EAX,dword ptr [EDX]
006dacbb : PUSH EBX
006dacbc : CALL EAX
006dacbe : ADD ESP,0x4
006dacc1 : CMP byte ptr [ESP + 0x53c],0x0
006dacc9 : PUSH EBP
006dacca : JZ 0x006dacd9
006daccc : MOV EBP,dword ptr [EBX + ESI*0x4 + 0xa0]
006dacd3 : MOV dword ptr [ESP + 0x10],EBP
006dacd7 : JMP 0x006dace6
006dacd9 : MOV ECX,dword ptr [EBX + ESI*0x4 + 0xb0]
006dace0 : MOV dword ptr [ESP + 0x10],ECX
006dace4 : MOV EBP,ECX
006dace6 : TEST EBP,EBP
006dace8 : JNZ 0x006dad02
006dacea : MOV EDX,dword ptr [EBX]
006dacec : MOV dword ptr [EDX + 0x14],0x32
006dacf3 : MOV EAX,dword ptr [EBX]
006dacf5 : MOV dword ptr [EAX + 0x18],ESI
006dacf8 : MOV ECX,dword ptr [EBX]
006dacfa : MOV EDX,dword ptr [ECX]
006dacfc : PUSH EBX
006dacfd : CALL EDX
006dacff : ADD ESP,0x4
006dad02 : CMP dword ptr [EDI],0x0
006dad05 : JNZ 0x006dad1b
006dad07 : MOV EAX,dword ptr [EBX + 0x4]
006dad0a : MOV ECX,dword ptr [EAX]
006dad0c : PUSH 0x590
006dad11 : PUSH 0x1
006dad13 : PUSH EBX
006dad14 : CALL ECX
006dad16 : ADD ESP,0xc
006dad19 : MOV dword ptr [EDI],EAX
006dad1b : MOV EDX,dword ptr [EDI]
006dad1d : MOV dword ptr [EDX + 0x8c],EBP
006dad23 : MOV dword ptr [ESP + 0x14],EDX
006dad27 : XOR EDI,EDI
006dad29 : MOV EBP,0x1
006dad2e : MOV EDI,EDI
006dad30 : MOV EAX,dword ptr [ESP + 0x10]
006dad34 : MOVZX ESI,byte ptr [EAX + EBP*0x1]
006dad38 : TEST ESI,ESI
006dad3a : JL 0x006dad47
006dad3c : LEA ECX,[ESI + EDI*0x1]
006dad3f : CMP ECX,0x100
006dad45 : JLE 0x006dad5e
006dad47 : MOV EDX,dword ptr [EBX]
006dad49 : MOV dword ptr [EDX + 0x14],0x8
006dad50 : MOV EAX,dword ptr [EBX]
006dad52 : MOV ECX,dword ptr [EAX]
006dad54 : PUSH EBX
006dad55 : CALL ECX
006dad57 : MOV EDX,dword ptr [ESP + 0x18]
006dad5b : ADD ESP,0x4
006dad5e : TEST ESI,ESI
006dad60 : JZ 0x006dad7a
006dad62 : PUSH ESI
006dad63 : LEA EAX,[ESP + EDI*0x1 + 0x434]
006dad6a : PUSH EBP
006dad6b : PUSH EAX
006dad6c : CALL 0x0063b700
006dad71 : MOV EDX,dword ptr [ESP + 0x20]
006dad75 : ADD ESP,0xc
006dad78 : ADD EDI,ESI
006dad7a : INC EBP
006dad7b : CMP EBP,0x10
006dad7e : JLE 0x006dad30
006dad80 : MOV byte ptr [ESP + EDI*0x1 + 0x430],0x0
006dad88 : MOV AL,byte ptr [ESP + 0x430]
006dad8f : MOV dword ptr [ESP + 0x28],EDI
006dad93 : XOR EDI,EDI
006dad95 : XOR ESI,ESI
006dad97 : MOVSX EBP,AL
006dad9a : TEST AL,AL
006dad9c : JZ 0x006dadf5
006dad9e : LEA EAX,[ESP + 0x430]
006dada5 : MOVSX EAX,byte ptr [EAX]
006dada8 : CMP EAX,EBP
006dadaa : JNZ 0x006dadc2
006dadac : LEA ESP,[ESP]
006dadb0 : MOVSX ECX,byte ptr [ESP + ESI*0x1 + 0x431]
006dadb8 : MOV dword ptr [ESP + ESI*0x4 + 0x2c],EDI
006dadbc : INC ESI
006dadbd : INC EDI
006dadbe : CMP ECX,EBP
006dadc0 : JZ 0x006dadb0
006dadc2 : MOV EAX,0x1
006dadc7 : MOV ECX,EBP
006dadc9 : SHL EAX,CL
006dadcb : CMP EDI,EAX
006dadcd : JL 0x006dade6
006dadcf : MOV ECX,dword ptr [EBX]
006dadd1 : MOV dword ptr [ECX + 0x14],0x8
006dadd8 : MOV EDX,dword ptr [EBX]
006dadda : MOV EAX,dword ptr [EDX]
006daddc : PUSH EBX
006daddd : CALL EAX
006daddf : MOV EDX,dword ptr [ESP + 0x18]
006dade3 : ADD ESP,0x4
006dade6 : LEA EAX,[ESP + ESI*0x1 + 0x430]
006daded : ADD EDI,EDI
006dadef : INC EBP
006dadf0 : CMP byte ptr [EAX],0x0
006dadf3 : JNZ 0x006dada5
006dadf5 : XOR ECX,ECX
006dadf7 : MOV EAX,0x1
006dadfc : LEA ESP,[ESP]
006dae00 : MOV ESI,dword ptr [ESP + 0x10]
006dae04 : CMP byte ptr [EAX + ESI*0x1],0x0
006dae08 : JZ 0x006dae23
006dae0a : MOV EDI,ECX
006dae0c : SUB EDI,dword ptr [ESP + ECX*0x4 + 0x2c]
006dae10 : MOV dword ptr [EDX + EAX*0x4 + 0x48],EDI
006dae14 : MOVZX ESI,byte ptr [EAX + ESI*0x1]
006dae18 : ADD ECX,ESI
006dae1a : MOV ESI,dword ptr [ESP + ECX*0x4 + 0x28]
006dae1e : MOV dword ptr [EDX + EAX*0x4],ESI
006dae21 : JMP 0x006dae2a
006dae23 : MOV dword ptr [EDX + EAX*0x4],0xffffffff
006dae2a : INC EAX
006dae2b : CMP EAX,0x10
006dae2e : JLE 0x006dae00
006dae30 : PUSH 0x400
006dae35 : MOV dword ptr [EDX + 0x44],0xfffff
006dae3c : ADD EDX,0x90
006dae42 : PUSH 0x0
006dae44 : PUSH EDX
006dae45 : CALL 0x0063b700
006dae4a : ADD ESP,0xc
006dae4d : XOR EBX,EBX
006dae4f : MOV ECX,0x7
006dae54 : LEA EDI,[EBX + 0x1]
006dae57 : MOV dword ptr [ESP + 0x18],ECX
006dae5b : JMP 0x006dae60
006dae60 : MOV ESI,dword ptr [ESP + 0x10]
006dae64 : CMP byte ptr [EDI + ESI*0x1],0x1
006dae68 : MOV dword ptr [ESP + 0x1c],0x1
006dae70 : JC 0x006daecc
006dae72 : MOV EAX,0x1
006dae77 : SHL EAX,CL
006dae79 : LEA EBP,[EBX + ESI*0x1 + 0x11]
006dae7d : MOV dword ptr [ESP + 0x20],EAX
006dae81 : MOV EDX,dword ptr [ESP + EBX*0x4 + 0x2c]
006dae85 : MOV ECX,dword ptr [ESP + 0x18]
006dae89 : SHL EDX,CL
006dae8b : TEST EAX,EAX
006dae8d : JLE 0x006daeb9
006dae8f : MOV ECX,dword ptr [ESP + 0x14]
006dae93 : LEA ESI,[EDX + ECX*0x1 + 0x490]
006dae9a : LEA EDX,[ECX + EDX*0x4 + 0x90]
006daea1 : MOV dword ptr [EDX],EDI
006daea3 : MOV CL,byte ptr [EBP]
006daea6 : MOV byte ptr [ESI],CL
006daea8 : DEC EAX
006daea9 : ADD EDX,0x4
006daeac : INC ESI
006daead : TEST EAX,EAX
006daeaf : JG 0x006daea1
006daeb1 : MOV ESI,dword ptr [ESP + 0x10]
006daeb5 : MOV EAX,dword ptr [ESP + 0x20]
006daeb9 : MOV EDX,dword ptr [ESP + 0x1c]
006daebd : MOVZX ECX,byte ptr [EDI + ESI*0x1]
006daec1 : INC EDX
006daec2 : INC EBX
006daec3 : INC EBP
006daec4 : CMP EDX,ECX
006daec6 : MOV dword ptr [ESP + 0x1c],EDX
006daeca : JLE 0x006dae81
006daecc : MOV ECX,dword ptr [ESP + 0x18]
006daed0 : INC EDI
006daed1 : SUB ECX,0x1
006daed4 : MOV dword ptr [ESP + 0x18],ECX
006daed8 : JNS 0x006dae60
006daeda : CMP byte ptr [ESP + 0x540],0x0
006daee2 : POP EBP
006daee3 : JZ 0x006daf1a
006daee5 : MOV EBX,dword ptr [ESP + 0x24]
006daee9 : XOR EDI,EDI
006daeeb : TEST EBX,EBX
006daeed : JLE 0x006daf1a
006daeef : NOP
006daef0 : MOVZX EAX,byte ptr [ESI + EDI*0x1 + 0x11]
006daef5 : TEST EAX,EAX
006daef7 : JL 0x006daefe
006daef9 : CMP EAX,0xf
006daefc : JLE 0x006daf15
006daefe : MOV EAX,dword ptr [ESP + 0x20]
006daf02 : MOV EDX,dword ptr [EAX]
006daf04 : MOV dword ptr [EDX + 0x14],0x8
006daf0b : MOV ECX,dword ptr [EAX]
006daf0d : MOV EDX,dword ptr [ECX]
006daf0f : PUSH EAX
006daf10 : CALL EDX
006daf12 : ADD ESP,0x4
006daf15 : INC EDI
006daf16 : CMP EDI,EBX
006daf18 : JL 0x006daef0
006daf1a : MOV ECX,dword ptr [ESP + 0x530]
006daf21 : POP EDI
006daf22 : POP ESI
006daf23 : POP EBX
006daf24 : XOR ECX,ESP
006daf26 : CALL 0x00633e6b
006daf2b : ADD ESP,0x528
006daf31 : RET
