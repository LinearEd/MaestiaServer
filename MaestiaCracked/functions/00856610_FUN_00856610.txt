PROGRAM  : Maestia.exe
FUNCTION : FUN_00856610
ENTRY    : 00856610
BODY     : [[00856610, 00856777]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_00856610(char param_1)

{
  int *piVar1;
  int iVar2;
  char cVar3;
  short sVar4;
  int *in_ECX;
  code *pcVar5;
  bool bVar6;
  undefined1 uVar7;
  
  iVar2 = *in_ECX;
  if (param_1 == '\0') {
    if ((char)in_ECX[0x66d] == '\0') {
      (**(code **)(iVar2 + 0x264))(1,0);
      FUN_00854ed0(in_ECX,1);
      if ((((*DAT_00da9894 == 0) || (iVar2 = *(int *)(*DAT_00da9894 + 0x164), iVar2 == 0)) ||
          (*(int *)(iVar2 + 0x38) == 0)) || (*(char *)(iVar2 + 0x32) == '\0')) {
        uVar7 = *(undefined1 *)(DAT_017248cc + 0xc);
      }
      else {
        uVar7 = *(undefined1 *)(*(int *)(iVar2 + 0x38) + 0x40);
      }
      pcVar5 = *(code **)(*in_ECX + 0x2d8);
    }
    else {
      pcVar5 = *(code **)(iVar2 + 0x2d8);
      uVar7 = 1;
    }
    (*pcVar5)(uVar7);
    if (in_ECX[0xe3] != 0) {
      FUN_00a6b3b0(1);
    }
    iVar2 = *(int *)(in_ECX[0x4e] + 4);
    piVar1 = in_ECX + 0x33e;
    sVar4 = FUN_0043d970();
    if (sVar4 == 1000) {
      bVar6 = *(int **)((int)in_ECX + iVar2 + 0x13c) == piVar1;
    }
    else if (sVar4 == 2000) {
      bVar6 = *(int **)((int)in_ECX + iVar2 + 0x140) == piVar1;
    }
    else {
      bVar6 = *(int **)((int)in_ECX + iVar2 + 0x144) == piVar1;
    }
    if (((!bVar6) && (cVar3 = FUN_00876040(), cVar3 == '\0')) &&
       (cVar3 = FUN_00876040(), cVar3 == '\0')) {
      (**(code **)(*in_ECX + 0x4a8))(0);
    }
    if (in_ECX[0xe3] == 0) {
      return;
    }
    if (*(char *)((int)in_ECX + 0x198d) != '\0') {
      return;
    }
  }
  else {
    (**(code **)(iVar2 + 0x264))(0,0);
    if (in_ECX[0xe3] != 0) {
      FUN_00a6b3b0(0);
    }
    FUN_00854ed0(in_ECX,0);
    (**(code **)(*in_ECX + 0x2d8))(0);
  }
  (**(code **)(*(int *)in_ECX[0xfa] + 0x68))(1,0);
  return;
}



============================================================
DISASSEMBLY
============================================================
00856610 : PUSH EBP
00856611 : MOV EBP,ESP
00856613 : CMP byte ptr [EBP + 0x8],0x0
00856617 : PUSH EBX
00856618 : MOV EBX,ECX
0085661a : MOV EAX,dword ptr [EBX]
0085661c : PUSH EDI
0085661d : JZ 0x00856657
0085661f : MOV EDX,dword ptr [EAX + 0x264]
00856625 : PUSH 0x0
00856627 : PUSH 0x0
00856629 : CALL EDX
0085662b : MOV EDI,dword ptr [EBX + 0x38c]
00856631 : TEST EDI,EDI
00856633 : JZ 0x0085663c
00856635 : PUSH 0x0
00856637 : CALL 0x00a6b3b0
0085663c : PUSH 0x0
0085663e : PUSH EBX
0085663f : CALL 0x00854ed0
00856644 : MOV EAX,dword ptr [EBX]
00856646 : MOV EDX,dword ptr [EAX + 0x2d8]
0085664c : PUSH 0x0
0085664e : MOV ECX,EBX
00856650 : CALL EDX
00856652 : JMP 0x0085675f
00856657 : CMP byte ptr [EBX + 0x19b4],0x0
0085665e : JZ 0x0085666a
00856660 : MOV EDX,dword ptr [EAX + 0x2d8]
00856666 : PUSH 0x1
00856668 : JMP 0x008566c2
0085666a : MOV EDX,dword ptr [EAX + 0x264]
00856670 : PUSH 0x0
00856672 : PUSH 0x1
00856674 : CALL EDX
00856676 : PUSH 0x1
00856678 : PUSH EBX
00856679 : CALL 0x00854ed0
0085667e : MOV EAX,[0x00da9894]
00856683 : MOV EAX,dword ptr [EAX]
00856685 : TEST EAX,EAX
00856687 : JZ 0x008566a8
00856689 : MOV EAX,dword ptr [EAX + 0x164]
0085668f : TEST EAX,EAX
00856691 : JZ 0x008566a8
00856693 : MOV ECX,dword ptr [EAX + 0x38]
00856696 : TEST ECX,ECX
00856698 : JZ 0x008566a8
0085669a : CMP byte ptr [EAX + 0x32],0x0
0085669e : JZ 0x008566a8
008566a0 : MOV CL,byte ptr [ECX + 0x40]
008566a3 : MOV byte ptr [EBP + 0x8],CL
008566a6 : JMP 0x008566b4
008566a8 : MOV EDX,dword ptr [0x017248cc]
008566ae : MOV AL,byte ptr [EDX + 0xc]
008566b1 : MOV byte ptr [EBP + 0x8],AL
008566b4 : MOV EDX,dword ptr [EBX]
008566b6 : MOV EAX,dword ptr [EBP + 0x8]
008566b9 : MOV EDX,dword ptr [EDX + 0x2d8]
008566bf : PUSH EAX
008566c0 : MOV ECX,EBX
008566c2 : CALL EDX
008566c4 : MOV EDI,dword ptr [EBX + 0x38c]
008566ca : TEST EDI,EDI
008566cc : JZ 0x008566d5
008566ce : PUSH 0x1
008566d0 : CALL 0x00a6b3b0
008566d5 : MOV EAX,dword ptr [EBX + 0x138]
008566db : MOV ECX,dword ptr [EAX + 0x4]
008566de : MOV AX,word ptr [EBX + 0xd22]
008566e5 : PUSH ESI
008566e6 : LEA ESI,[EBX + 0xcf8]
008566ec : LEA EDI,[ECX + EBX*0x1 + 0x138]
008566f3 : CALL 0x0043d970
008566f8 : MOV EDX,0x3e8
008566fd : CMP AX,DX
00856700 : JNZ 0x00856707
00856702 : CMP dword ptr [EDI + 0x4],ESI
00856705 : JMP 0x00856719
00856707 : MOV ECX,0x7d0
0085670c : CMP AX,CX
0085670f : JNZ 0x00856716
00856711 : CMP dword ptr [EDI + 0x8],ESI
00856714 : JMP 0x00856719
00856716 : CMP dword ptr [EDI + 0xc],ESI
00856719 : SETZ AL
0085671c : TEST AL,AL
0085671e : JNZ 0x0085674c
00856720 : LEA ESI,[EBX + 0xf28]
00856726 : CALL 0x00876040
0085672b : TEST AL,AL
0085672d : JNZ 0x0085674c
0085672f : LEA ESI,[EBX + 0xf98]
00856735 : CALL 0x00876040
0085673a : TEST AL,AL
0085673c : JNZ 0x0085674c
0085673e : MOV EDX,dword ptr [EBX]
00856740 : MOV EAX,dword ptr [EDX + 0x4a8]
00856746 : PUSH 0x0
00856748 : MOV ECX,EBX
0085674a : CALL EAX
0085674c : CMP dword ptr [EBX + 0x38c],0x0
00856753 : POP ESI
00856754 : JZ 0x00856772
00856756 : CMP byte ptr [EBX + 0x198d],0x0
0085675d : JNZ 0x00856772
0085675f : MOV EBX,dword ptr [EBX + 0x3e8]
00856765 : MOV EDX,dword ptr [EBX]
00856767 : MOV EAX,dword ptr [EDX + 0x68]
0085676a : PUSH 0x0
0085676c : PUSH 0x1
0085676e : MOV ECX,EBX
00856770 : CALL EAX
00856772 : POP EDI
00856773 : POP EBX
00856774 : POP EBP
00856775 : RET 0x4
