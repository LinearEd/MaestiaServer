PROGRAM  : Maestia.exe
FUNCTION : FUN_005030c0
ENTRY    : 005030c0
BODY     : [[005030c0, 005032b8]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_005030c0(int param_1)

{
  int iVar1;
  undefined1 uVar2;
  undefined1 uVar3;
  int *piVar4;
  char cVar5;
  int iVar6;
  uint uVar7;
  GThread *this;
  GThread *this_00;
  int iVar8;
  int local_8;
  int *local_4;
  
  iVar8 = *(int *)(param_1 + 0x314);
  if (iVar8 == 0) {
    iVar8 = param_1 + 0x28;
  }
  *(undefined1 *)(iVar8 + 0x15) = 0;
  if (*(int *)(iVar8 + 0x30) - *(int *)(iVar8 + 0x2c) < 2) {
    FUN_00539fb0();
  }
  iVar6 = *(int *)(iVar8 + 0x2c);
  uVar2 = *(undefined1 *)(*(int *)(iVar8 + 0x3c) + 1 + iVar6);
  uVar3 = *(undefined1 *)(*(int *)(iVar8 + 0x3c) + iVar6);
  *(int *)(iVar8 + 0x2c) = iVar6 + 2;
  iVar8 = *(int *)(param_1 + 0x314);
  this_00 = (GThread *)(uint)CONCAT11(uVar2,uVar3);
  if (iVar8 == 0) {
    iVar8 = param_1 + 0x28;
  }
  FUN_0053a880();
  iVar6 = FUN_0053a880();
  *(undefined1 *)(iVar8 + 0x15) = 0;
  if (*(int *)(iVar8 + 0x30) - *(int *)(iVar8 + 0x2c) < 4) {
    FUN_00539fb0();
  }
  iVar1 = *(int *)(iVar8 + 0x2c) + 4;
  *(int *)(iVar8 + 0x2c) = iVar1;
  *(undefined1 *)(iVar8 + 0x15) = 0;
  if (*(int *)(iVar8 + 0x30) - iVar1 < 4) {
    FUN_00539fb0();
  }
  *(int *)(iVar8 + 0x2c) = *(int *)(iVar8 + 0x2c) + 4;
  cVar5 = FUN_00539cd0();
  if (cVar5 != '\0') {
    GThread::OnExit(this_00);
    GThread::OnExit((GThread *)(&PTR_DAT_00b8644c)[iVar6]);
    GThread::OnExit(this);
  }
  local_8 = 0;
  local_4 = (int *)0x0;
  cVar5 = FUN_00565560(&local_8,this_00);
  piVar4 = local_4;
  if (cVar5 != '\0') {
    if (local_8 != 0) {
      return;
    }
    if (local_4 == (int *)0x0) {
      return;
    }
    uVar7 = (**(code **)(*local_4 + 8))();
    if ((uVar7 & 0xff00) == 0x8300) {
      *(ushort *)(piVar4 + 0x14) = *(ushort *)(piVar4 + 0x14) | 0x400;
    }
    else {
      uVar7 = (**(code **)(*piVar4 + 8))();
      if ((uVar7 & 0xff00) == 0x8200) {
        *(byte *)(piVar4 + 0x11) = *(byte *)(piVar4 + 0x11) | 1;
      }
    }
  }
  if ((local_8 == 0) && (local_4 != (int *)0x0)) {
    FUN_00524240();
  }
  return;
}



============================================================
DISASSEMBLY
============================================================
005030c0 : SUB ESP,0x14
005030c3 : PUSH EBX
005030c4 : PUSH EBP
005030c5 : PUSH ESI
005030c6 : PUSH EDI
005030c7 : MOV EDI,dword ptr [ESP + 0x28]
005030cb : MOV ESI,dword ptr [EDI + 0x314]
005030d1 : XOR EBX,EBX
005030d3 : CMP ESI,EBX
005030d5 : JNZ 0x005030da
005030d7 : LEA ESI,[EDI + 0x28]
005030da : MOV EAX,dword ptr [ESI + 0x30]
005030dd : SUB EAX,dword ptr [ESI + 0x2c]
005030e0 : MOV byte ptr [ESI + 0x15],BL
005030e3 : CMP EAX,0x2
005030e6 : JGE 0x005030f1
005030e8 : PUSH 0x2
005030ea : MOV ECX,ESI
005030ec : CALL 0x00539fb0
005030f1 : MOV EAX,dword ptr [ESI + 0x2c]
005030f4 : MOV ECX,dword ptr [ESI + 0x3c]
005030f7 : MOVZX DX,byte ptr [ECX + EAX*0x1 + 0x1]
005030fd : ADD ECX,EAX
005030ff : MOVZX CX,byte ptr [ECX]
00503103 : ADD EAX,0x2
00503106 : SHL DX,0x8
0050310a : MOV dword ptr [ESI + 0x2c],EAX
0050310d : MOV ESI,dword ptr [EDI + 0x314]
00503113 : OR DX,CX
00503116 : MOVZX EBP,DX
00503119 : CMP ESI,EBX
0050311b : JNZ 0x00503120
0050311d : LEA ESI,[EDI + 0x28]
00503120 : PUSH 0x2
00503122 : MOV ECX,ESI
00503124 : CALL 0x0053a880
00503129 : PUSH 0x3
0050312b : MOV ECX,ESI
0050312d : MOV dword ptr [ESP + 0x2c],EAX
00503131 : CALL 0x0053a880
00503136 : MOV EDX,dword ptr [ESI + 0x30]
00503139 : SUB EDX,dword ptr [ESI + 0x2c]
0050313c : MOV dword ptr [ESP + 0x10],EAX
00503140 : CMP EDX,0x4
00503143 : MOV byte ptr [ESI + 0x15],BL
00503146 : JGE 0x00503151
00503148 : PUSH 0x4
0050314a : MOV ECX,ESI
0050314c : CALL 0x00539fb0
00503151 : MOV ECX,dword ptr [ESI + 0x2c]
00503154 : MOV EAX,dword ptr [ESI + 0x3c]
00503157 : MOVZX EDX,byte ptr [EAX + ECX*0x1 + 0x3]
0050315c : MOVZX EBX,byte ptr [EAX + ECX*0x1 + 0x2]
00503161 : ADD EAX,ECX
00503163 : SHL EDX,0x8
00503166 : OR EDX,EBX
00503168 : MOVZX EBX,byte ptr [EAX + 0x1]
0050316c : MOVZX EAX,byte ptr [EAX]
0050316f : SHL EDX,0x8
00503172 : OR EDX,EBX
00503174 : SHL EDX,0x8
00503177 : OR EDX,EAX
00503179 : LEA EAX,[ECX + 0x4]
0050317c : MOV ECX,dword ptr [ESI + 0x30]
0050317f : SUB ECX,EAX
00503181 : CMP ECX,0x4
00503184 : MOV dword ptr [ESP + 0x18],EDX
00503188 : MOV dword ptr [ESI + 0x2c],EAX
0050318b : MOV byte ptr [ESI + 0x15],0x0
0050318f : JGE 0x0050319a
00503191 : PUSH 0x4
00503193 : MOV ECX,ESI
00503195 : CALL 0x00539fb0
0050319a : MOV ECX,dword ptr [ESI + 0x2c]
0050319d : MOV EDX,dword ptr [ESI + 0x3c]
005031a0 : MOVZX EBX,byte ptr [EDX + ECX*0x1 + 0x2]
005031a5 : LEA EAX,[EDX + ECX*0x1]
005031a8 : MOVZX EDX,byte ptr [EAX + 0x3]
005031ac : SHL EDX,0x8
005031af : OR EDX,EBX
005031b1 : MOVZX EBX,byte ptr [EAX + 0x1]
005031b5 : MOVZX EAX,byte ptr [EAX]
005031b8 : SHL EDX,0x8
005031bb : OR EDX,EBX
005031bd : ADD ECX,0x4
005031c0 : SHL EDX,0x8
005031c3 : OR EDX,EAX
005031c5 : MOV dword ptr [ESI + 0x2c],ECX
005031c8 : MOV ECX,ESI
005031ca : MOV dword ptr [ESP + 0x14],EDX
005031ce : CALL 0x00539cd0
005031d3 : TEST AL,AL
005031d5 : JZ 0x00503232
005031d7 : MOVZX ECX,BP
005031da : PUSH ECX
005031db : LEA ESI,[EDI + 0x14]
005031de : PUSH 0xb8646c
005031e3 : PUSH ESI
005031e4 : CALL 0x0051d420
005031e9 : ADD ESP,0xc
005031ec : CMP dword ptr [ESP + 0x28],0x0
005031f1 : MOV EAX,0xb86464
005031f6 : JZ 0x005031fd
005031f8 : MOV EAX,0xb86458
005031fd : MOV EDX,dword ptr [ESP + 0x10]
00503201 : MOV ECX,dword ptr [EDX*0x4 + 0xb8644c]
00503208 : PUSH ECX
00503209 : PUSH EAX
0050320a : PUSH 0xb8642c
0050320f : PUSH ESI
00503210 : CALL 0x0051d420
00503215 : FLD float ptr [ESP + 0x24]
00503219 : FSTP double ptr [ESP + 0x8]
0050321d : FLD float ptr [ESP + 0x28]
00503221 : FSTP double ptr [ESP]
00503224 : PUSH 0xb86408
00503229 : PUSH ESI
0050322a : CALL 0x0051d420
0050322f : ADD ESP,0x18
00503232 : PUSH ECX
00503233 : MOVZX EAX,BP
00503236 : MOV ECX,ESP
00503238 : XOR EBX,EBX
0050323a : MOV dword ptr [ESP + 0x20],EBX
0050323e : MOV dword ptr [ESP + 0x24],EBX
00503242 : LEA EDX,[ESP + 0x20]
00503246 : MOV dword ptr [ECX],EAX
00503248 : MOV ECX,dword ptr [EDI + 0x20]
0050324b : PUSH EDX
0050324c : CALL 0x00565560
00503251 : CMP AL,BL
00503253 : JZ 0x0050329c
00503255 : CMP dword ptr [ESP + 0x1c],EBX
00503259 : JNZ 0x005032af
0050325b : MOV ECX,dword ptr [ESP + 0x20]
0050325f : MOV ESI,ECX
00503261 : CMP ECX,EBX
00503263 : JZ 0x005032af
00503265 : MOV EAX,dword ptr [ECX]
00503267 : MOV EDX,dword ptr [EAX + 0x8]
0050326a : CALL EDX
0050326c : AND EAX,0xff00
00503271 : CMP EAX,0x8300
00503276 : JNZ 0x00503283
00503278 : MOV EAX,0x400
0050327d : OR word ptr [ESI + 0x50],AX
00503281 : JMP 0x0050329c
00503283 : MOV EDX,dword ptr [ESI]
00503285 : MOV EAX,dword ptr [EDX + 0x8]
00503288 : MOV ECX,ESI
0050328a : CALL EAX
0050328c : AND EAX,0xff00
00503291 : CMP EAX,0x8200
00503296 : JNZ 0x0050329c
00503298 : OR byte ptr [ESI + 0x44],0x1
0050329c : CMP dword ptr [ESP + 0x1c],EBX
005032a0 : JNZ 0x005032af
005032a2 : MOV ECX,dword ptr [ESP + 0x20]
005032a6 : CMP ECX,EBX
005032a8 : JZ 0x005032af
005032aa : CALL 0x00524240
005032af : POP EDI
005032b0 : POP ESI
005032b1 : POP EBP
005032b2 : POP EBX
005032b3 : ADD ESP,0x14
005032b6 : RET 0x8
