PROGRAM  : Maestia.exe
FUNCTION : FUN_006c0530
ENTRY    : 006c0530
BODY     : [[006c0530, 006c0a92]]

============================================================
DECOMPILED C CODE
============================================================

void FUN_006c0530(undefined4 param_1)

{
  byte bVar1;
  undefined1 uVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  int iVar5;
  undefined1 *puVar6;
  int *in_EAX;
  int in_ECX;
  uint uVar7;
  undefined1 *puVar8;
  undefined1 *puVar9;
  uint uVar10;
  byte *pbVar11;
  uint local_18;
  int local_10;
  undefined1 *local_c;
  byte *local_8;
  
  local_18 = *(uint *)(in_ECX + 0x20);
  uVar10 = *(uint *)(in_ECX + 0x1c);
  local_10 = in_EAX[1];
  puVar3 = *(undefined4 **)(in_ECX + 4);
  pbVar11 = (byte *)*in_EAX;
  puVar9 = *(undefined1 **)(in_ECX + 0x34);
  if (puVar9 < *(undefined1 **)(in_ECX + 0x30)) {
    local_c = *(undefined1 **)(in_ECX + 0x30) + (-1 - (int)puVar9);
  }
  else {
    local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar9);
  }
  uVar4 = *puVar3;
  do {
    puVar8 = puVar9;
    switch(uVar4) {
    case 0:
      puVar3[3] = (uint)*(byte *)(puVar3 + 4);
      puVar3[2] = puVar3[5];
      *puVar3 = 1;
    case 1:
      for (; uVar10 < (uint)puVar3[3]; uVar10 = uVar10 + 8) {
        if (local_10 == 0) {
LAB_006c09c5:
          *(uint *)(in_ECX + 0x20) = local_18;
          *(uint *)(in_ECX + 0x1c) = uVar10;
          in_EAX[1] = 0;
          in_EAX[2] = (int)(pbVar11 + (in_EAX[2] - *in_EAX));
          *in_EAX = (int)pbVar11;
          *(undefined1 **)(in_ECX + 0x34) = puVar9;
          FUN_006c0400(param_1);
          return;
        }
        bVar1 = *pbVar11;
        local_10 = local_10 + -1;
        pbVar11 = pbVar11 + 1;
        param_1 = 0;
        local_18 = local_18 | (uint)bVar1 << ((byte)uVar10 & 0x1f);
      }
      local_8 = (byte *)(puVar3[2] + (*(uint *)(&DAT_00bed1e8 + puVar3[3] * 4) & local_18) * 8);
      local_18 = local_18 >> (local_8[1] & 0x1f);
      uVar10 = uVar10 - local_8[1];
      bVar1 = *local_8;
      uVar7 = (uint)bVar1;
      if (uVar7 == 0) {
        puVar3[2] = *(undefined4 *)(local_8 + 4);
        *puVar3 = 6;
      }
      else if ((bVar1 & 0x10) == 0) {
        if ((bVar1 & 0x40) == 0) {
LAB_006c063b:
          puVar3[3] = uVar7;
          puVar3[2] = local_8 + *(int *)(local_8 + 4) * 8;
        }
        else {
          if ((bVar1 & 0x20) == 0) {
            *puVar3 = 9;
            in_EAX[6] = (int)"invalid literal/length code";
            param_1 = 0xfffffffd;
            goto LAB_006c0998;
          }
          *puVar3 = 7;
        }
      }
      else {
        puVar3[2] = uVar7 & 0xf;
        puVar3[1] = *(undefined4 *)(local_8 + 4);
        *puVar3 = 2;
      }
LAB_006c098b:
      uVar4 = *puVar3;
      break;
    case 2:
      uVar7 = puVar3[2];
      for (; uVar10 < uVar7; uVar10 = uVar10 + 8) {
        if (local_10 == 0) goto LAB_006c09c5;
        bVar1 = *pbVar11;
        local_10 = local_10 + -1;
        pbVar11 = pbVar11 + 1;
        param_1 = 0;
        local_18 = local_18 | (uint)bVar1 << ((byte)uVar10 & 0x1f);
      }
      puVar3[1] = puVar3[1] + (*(uint *)(&DAT_00bed1e8 + uVar7 * 4) & local_18);
      local_18 = local_18 >> ((byte)uVar7 & 0x1f);
      uVar10 = uVar10 - uVar7;
      puVar3[3] = (uint)*(byte *)((int)puVar3 + 0x11);
      puVar3[2] = puVar3[6];
      *puVar3 = 3;
    case 3:
      for (; uVar10 < (uint)puVar3[3]; uVar10 = uVar10 + 8) {
        if (local_10 == 0) goto LAB_006c09c5;
        bVar1 = *pbVar11;
        local_10 = local_10 + -1;
        pbVar11 = pbVar11 + 1;
        param_1 = 0;
        local_18 = local_18 | (uint)bVar1 << ((byte)uVar10 & 0x1f);
      }
      local_8 = (byte *)(puVar3[2] + (*(uint *)(&DAT_00bed1e8 + puVar3[3] * 4) & local_18) * 8);
      local_18 = local_18 >> (local_8[1] & 0x1f);
      uVar10 = uVar10 - local_8[1];
      bVar1 = *local_8;
      uVar7 = (uint)bVar1;
      if ((bVar1 & 0x10) != 0) {
        puVar3[2] = uVar7 & 0xf;
        puVar3[3] = *(undefined4 *)(local_8 + 4);
        *puVar3 = 4;
        goto LAB_006c098b;
      }
      if ((bVar1 & 0x40) == 0) goto LAB_006c063b;
      *puVar3 = 9;
      in_EAX[6] = (int)"invalid distance code";
      param_1 = 0xfffffffd;
      goto LAB_006c0998;
    case 4:
      uVar7 = puVar3[2];
      for (; uVar10 < uVar7; uVar10 = uVar10 + 8) {
        if (local_10 == 0) goto LAB_006c09c5;
        bVar1 = *pbVar11;
        local_10 = local_10 + -1;
        pbVar11 = pbVar11 + 1;
        param_1 = 0;
        local_18 = local_18 | (uint)bVar1 << ((byte)uVar10 & 0x1f);
      }
      puVar3[3] = puVar3[3] + (*(uint *)(&DAT_00bed1e8 + uVar7 * 4) & local_18);
      local_18 = local_18 >> ((byte)uVar7 & 0x1f);
      uVar10 = uVar10 - uVar7;
      *puVar3 = 5;
    case 5:
      local_8 = puVar9 + -puVar3[3];
      if (local_8 < *(undefined1 **)(in_ECX + 0x28)) {
        do {
          local_8 = local_8 + (*(int *)(in_ECX + 0x2c) - (int)*(undefined1 **)(in_ECX + 0x28));
        } while (local_8 < *(undefined1 **)(in_ECX + 0x28));
      }
      iVar5 = puVar3[1];
      while (iVar5 != 0) {
        puVar8 = puVar9;
        if (local_c == (undefined1 *)0x0) {
          if (puVar9 == *(undefined1 **)(in_ECX + 0x2c)) {
            local_c = *(undefined1 **)(in_ECX + 0x30);
            puVar8 = *(undefined1 **)(in_ECX + 0x28);
            if (local_c != puVar8) {
              if (puVar8 < local_c) {
                local_c = local_c + (-1 - (int)puVar8);
              }
              else {
                local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar8);
              }
              puVar9 = puVar8;
              if (local_c != (undefined1 *)0x0) goto LAB_006c08a5;
            }
          }
          *(undefined1 **)(in_ECX + 0x34) = puVar9;
          param_1 = FUN_006c0400(param_1);
          puVar8 = *(undefined1 **)(in_ECX + 0x34);
          puVar9 = *(undefined1 **)(in_ECX + 0x30);
          if (puVar8 < puVar9) {
            local_c = puVar9 + (-1 - (int)puVar8);
          }
          else {
            local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar8);
          }
          if ((puVar8 == *(undefined1 **)(in_ECX + 0x2c)) &&
             (puVar6 = *(undefined1 **)(in_ECX + 0x28), puVar9 != puVar6)) {
            puVar8 = puVar6;
            if (puVar6 < puVar9) {
              local_c = puVar9 + (-1 - (int)puVar6);
            }
            else {
              local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar6);
            }
          }
          if (local_c == (undefined1 *)0x0) goto LAB_006c0a08;
        }
LAB_006c08a5:
        uVar2 = *local_8;
        local_8 = local_8 + 1;
        local_c = local_c + -1;
        *puVar8 = uVar2;
        puVar9 = puVar8 + 1;
        param_1 = 0;
        if (local_8 == *(undefined1 **)(in_ECX + 0x2c)) {
          local_8 = *(byte **)(in_ECX + 0x28);
        }
        puVar3[1] = puVar3[1] + -1;
        iVar5 = puVar3[1];
      }
LAB_006c0985:
      *puVar3 = 0;
      goto LAB_006c098b;
    case 6:
      if (local_c == (undefined1 *)0x0) {
        if (puVar9 == *(undefined1 **)(in_ECX + 0x2c)) {
          local_c = *(undefined1 **)(in_ECX + 0x30);
          puVar8 = *(undefined1 **)(in_ECX + 0x28);
          if (local_c != puVar8) {
            if (puVar8 < local_c) {
              local_c = local_c + (-1 - (int)puVar8);
            }
            else {
              local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar8);
            }
            puVar9 = puVar8;
            if (local_c != (undefined1 *)0x0) goto LAB_006c0973;
          }
        }
        *(undefined1 **)(in_ECX + 0x34) = puVar9;
        param_1 = FUN_006c0400(param_1);
        puVar8 = *(undefined1 **)(in_ECX + 0x34);
        puVar9 = *(undefined1 **)(in_ECX + 0x30);
        if (puVar8 < puVar9) {
          local_c = puVar9 + (-1 - (int)puVar8);
        }
        else {
          local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar8);
        }
        if ((puVar8 == *(undefined1 **)(in_ECX + 0x2c)) &&
           (puVar6 = *(undefined1 **)(in_ECX + 0x28), puVar9 != puVar6)) {
          puVar8 = puVar6;
          if (puVar6 < puVar9) {
            local_c = puVar9 + (-1 - (int)puVar6);
          }
          else {
            local_c = (undefined1 *)(*(int *)(in_ECX + 0x2c) - (int)puVar6);
          }
        }
        if (local_c == (undefined1 *)0x0) {
LAB_006c0a08:
          *(uint *)(in_ECX + 0x20) = local_18;
          *(uint *)(in_ECX + 0x1c) = uVar10;
          in_EAX[1] = local_10;
          in_EAX[2] = (int)(pbVar11 + (in_EAX[2] - *in_EAX));
          goto LAB_006c09b0;
        }
      }
LAB_006c0973:
      *puVar8 = *(undefined1 *)(puVar3 + 2);
      puVar9 = puVar8 + 1;
      local_c = local_c + -1;
      param_1 = 0;
      goto LAB_006c0985;
    case 7:
      if (7 < uVar10) {
        local_10 = local_10 + 1;
        uVar10 = uVar10 - 8;
        pbVar11 = pbVar11 + -1;
      }
      *(undefined1 **)(in_ECX + 0x34) = puVar9;
      param_1 = FUN_006c0400(param_1);
      puVar9 = *(undefined1 **)(in_ECX + 0x34);
      if (*(undefined1 **)(in_ECX + 0x30) == puVar9) {
        *puVar3 = 8;
switchD_006c0578_caseD_8:
        param_1 = 1;
LAB_006c0998:
        *(uint *)(in_ECX + 0x20) = local_18;
        *(uint *)(in_ECX + 0x1c) = uVar10;
        in_EAX[1] = local_10;
      }
      else {
        *(uint *)(in_ECX + 0x20) = local_18;
        *(uint *)(in_ECX + 0x1c) = uVar10;
        in_EAX[1] = local_10;
      }
      in_EAX[2] = (int)(pbVar11 + (in_EAX[2] - *in_EAX));
      puVar8 = puVar9;
LAB_006c09b0:
      *in_EAX = (int)pbVar11;
      *(undefined1 **)(in_ECX + 0x34) = puVar8;
      FUN_006c0400(param_1);
      return;
    case 8:
      goto switchD_006c0578_caseD_8;
    case 9:
      *(uint *)(in_ECX + 0x20) = local_18;
      *(uint *)(in_ECX + 0x1c) = uVar10;
      in_EAX[1] = local_10;
      in_EAX[2] = (int)(pbVar11 + (in_EAX[2] - *in_EAX));
      param_1 = 0xfffffffd;
      goto LAB_006c09b0;
    default:
      param_1 = 0xfffffffe;
      goto LAB_006c0998;
    }
  } while( true );
}



============================================================
DISASSEMBLY
============================================================
006c0530 : SUB ESP,0x18
006c0533 : PUSH EBX
006c0534 : PUSH EBP
006c0535 : PUSH ESI
006c0536 : MOV ESI,ECX
006c0538 : MOV EDX,dword ptr [ESI + 0x20]
006c053b : MOV EBX,dword ptr [ESI + 0x1c]
006c053e : PUSH EDI
006c053f : MOV EDI,EAX
006c0541 : MOV ECX,dword ptr [EDI + 0x4]
006c0544 : MOV EAX,dword ptr [ESI + 0x4]
006c0547 : MOV EBP,dword ptr [EDI]
006c0549 : MOV dword ptr [ESP + 0x18],ECX
006c054d : MOV ECX,dword ptr [ESI + 0x30]
006c0550 : MOV dword ptr [ESP + 0x10],EDX
006c0554 : MOV EDX,dword ptr [ESI + 0x34]
006c0557 : MOV dword ptr [ESP + 0x14],EAX
006c055b : CMP EDX,ECX
006c055d : JNC 0x006c0564
006c055f : SUB ECX,EDX
006c0561 : DEC ECX
006c0562 : JMP 0x006c0569
006c0564 : MOV ECX,dword ptr [ESI + 0x2c]
006c0567 : SUB ECX,EDX
006c0569 : MOV dword ptr [ESP + 0x1c],ECX
006c056d : MOV ECX,dword ptr [EAX]
006c056f : CMP ECX,0x9
006c0572 : JA 0x006c0996
006c0578 : JMP dword ptr [ECX*0x4 + 0x6c0a94]
006c057f : MOVZX ECX,byte ptr [EAX + 0x10]
006c0583 : MOV dword ptr [EAX + 0xc],ECX
006c0586 : MOV ECX,dword ptr [EAX + 0x14]
006c0589 : MOV dword ptr [EAX + 0x8],ECX
006c058c : MOV dword ptr [EAX],0x1
006c0592 : MOV EAX,dword ptr [EAX + 0xc]
006c0595 : MOV dword ptr [ESP + 0x20],EAX
006c0599 : CMP EBX,EAX
006c059b : JNC 0x006c05cf
006c059d : LEA ECX,[ECX]
006c05a0 : CMP dword ptr [ESP + 0x18],0x0
006c05a5 : JZ 0x006c09c5
006c05ab : MOVZX EAX,byte ptr [EBP]
006c05af : DEC dword ptr [ESP + 0x18]
006c05b3 : MOV ECX,EBX
006c05b5 : SHL EAX,CL
006c05b7 : ADD EBX,0x8
006c05ba : INC EBP
006c05bb : MOV dword ptr [ESP + 0x2c],0x0
006c05c3 : OR dword ptr [ESP + 0x10],EAX
006c05c7 : MOV EAX,dword ptr [ESP + 0x20]
006c05cb : CMP EBX,EAX
006c05cd : JC 0x006c05a0
006c05cf : MOV ECX,dword ptr [EAX*0x4 + 0xbed1e8]
006c05d6 : AND ECX,dword ptr [ESP + 0x10]
006c05da : MOV EAX,dword ptr [ESP + 0x14]
006c05de : MOV EAX,dword ptr [EAX + 0x8]
006c05e1 : LEA EAX,[EAX + ECX*0x8]
006c05e4 : MOVZX ECX,byte ptr [EAX + 0x1]
006c05e8 : SHR dword ptr [ESP + 0x10],CL
006c05ec : MOVZX ECX,byte ptr [EAX + 0x1]
006c05f0 : SUB EBX,ECX
006c05f2 : MOVZX ECX,byte ptr [EAX]
006c05f5 : MOV dword ptr [ESP + 0x20],EAX
006c05f9 : TEST ECX,ECX
006c05fb : JNZ 0x006c0612
006c05fd : MOV ECX,dword ptr [EAX + 0x4]
006c0600 : MOV EAX,dword ptr [ESP + 0x14]
006c0604 : MOV dword ptr [EAX + 0x8],ECX
006c0607 : MOV dword ptr [EAX],0x6
006c060d : JMP 0x006c098b
006c0612 : MOV EAX,dword ptr [ESP + 0x14]
006c0616 : TEST CL,0x10
006c0619 : JZ 0x006c0636
006c061b : AND ECX,0xf
006c061e : MOV dword ptr [EAX + 0x8],ECX
006c0621 : MOV ECX,dword ptr [ESP + 0x20]
006c0625 : MOV ECX,dword ptr [ECX + 0x4]
006c0628 : MOV dword ptr [EAX + 0x4],ECX
006c062b : MOV dword ptr [EAX],0x2
006c0631 : JMP 0x006c098b
006c0636 : TEST CL,0x40
006c0639 : JNZ 0x006c0654
006c063b : MOV dword ptr [EAX + 0xc],ECX
006c063e : MOV EAX,dword ptr [ESP + 0x20]
006c0642 : MOV ECX,dword ptr [EAX + 0x4]
006c0645 : LEA ECX,[EAX + ECX*0x8]
006c0648 : MOV EAX,dword ptr [ESP + 0x14]
006c064c : MOV dword ptr [EAX + 0x8],ECX
006c064f : JMP 0x006c098b
006c0654 : TEST CL,0x20
006c0657 : JZ 0x006c09f7
006c065d : MOV dword ptr [EAX],0x7
006c0663 : JMP 0x006c098b
006c0668 : MOV EAX,dword ptr [EAX + 0x8]
006c066b : MOV dword ptr [ESP + 0x20],EAX
006c066f : CMP EBX,EAX
006c0671 : JNC 0x006c06a2
006c0673 : CMP dword ptr [ESP + 0x18],0x0
006c0678 : JZ 0x006c09c5
006c067e : MOVZX EAX,byte ptr [EBP]
006c0682 : DEC dword ptr [ESP + 0x18]
006c0686 : MOV ECX,EBX
006c0688 : SHL EAX,CL
006c068a : ADD EBX,0x8
006c068d : INC EBP
006c068e : MOV dword ptr [ESP + 0x2c],0x0
006c0696 : OR dword ptr [ESP + 0x10],EAX
006c069a : MOV EAX,dword ptr [ESP + 0x20]
006c069e : CMP EBX,EAX
006c06a0 : JC 0x006c0673
006c06a2 : MOV ECX,dword ptr [EAX*0x4 + 0xbed1e8]
006c06a9 : AND ECX,dword ptr [ESP + 0x10]
006c06ad : MOV EAX,dword ptr [ESP + 0x14]
006c06b1 : ADD dword ptr [EAX + 0x4],ECX
006c06b4 : MOV ECX,dword ptr [ESP + 0x20]
006c06b8 : SHR dword ptr [ESP + 0x10],CL
006c06bc : SUB EBX,ECX
006c06be : MOVZX ECX,byte ptr [EAX + 0x11]
006c06c2 : MOV dword ptr [EAX + 0xc],ECX
006c06c5 : MOV ECX,dword ptr [EAX + 0x18]
006c06c8 : MOV dword ptr [EAX + 0x8],ECX
006c06cb : MOV dword ptr [EAX],0x3
006c06d1 : MOV EAX,dword ptr [EAX + 0xc]
006c06d4 : MOV dword ptr [ESP + 0x20],EAX
006c06d8 : CMP EBX,EAX
006c06da : JNC 0x006c070f
006c06dc : LEA ESP,[ESP]
006c06e0 : CMP dword ptr [ESP + 0x18],0x0
006c06e5 : JZ 0x006c09c5
006c06eb : MOVZX EAX,byte ptr [EBP]
006c06ef : DEC dword ptr [ESP + 0x18]
006c06f3 : MOV ECX,EBX
006c06f5 : SHL EAX,CL
006c06f7 : ADD EBX,0x8
006c06fa : INC EBP
006c06fb : MOV dword ptr [ESP + 0x2c],0x0
006c0703 : OR dword ptr [ESP + 0x10],EAX
006c0707 : MOV EAX,dword ptr [ESP + 0x20]
006c070b : CMP EBX,EAX
006c070d : JC 0x006c06e0
006c070f : MOV ECX,dword ptr [EAX*0x4 + 0xbed1e8]
006c0716 : AND ECX,dword ptr [ESP + 0x10]
006c071a : MOV EAX,dword ptr [ESP + 0x14]
006c071e : MOV EAX,dword ptr [EAX + 0x8]
006c0721 : LEA EAX,[EAX + ECX*0x8]
006c0724 : MOVZX ECX,byte ptr [EAX + 0x1]
006c0728 : SHR dword ptr [ESP + 0x10],CL
006c072c : MOVZX ECX,byte ptr [EAX + 0x1]
006c0730 : SUB EBX,ECX
006c0732 : MOVZX ECX,byte ptr [EAX]
006c0735 : MOV dword ptr [ESP + 0x20],EAX
006c0739 : MOV EAX,dword ptr [ESP + 0x14]
006c073d : TEST CL,0x10
006c0740 : JZ 0x006c075d
006c0742 : AND ECX,0xf
006c0745 : MOV dword ptr [EAX + 0x8],ECX
006c0748 : MOV ECX,dword ptr [ESP + 0x20]
006c074c : MOV ECX,dword ptr [ECX + 0x4]
006c074f : MOV dword ptr [EAX + 0xc],ECX
006c0752 : MOV dword ptr [EAX],0x4
006c0758 : JMP 0x006c098b
006c075d : TEST CL,0x40
006c0760 : JZ 0x006c063b
006c0766 : MOV dword ptr [EAX],0x9
006c076c : MOV dword ptr [EDI + 0x18],0xbed388
006c0773 : PUSH -0x3
006c0775 : JMP 0x006c0998
006c077a : MOV EAX,dword ptr [EAX + 0x8]
006c077d : MOV dword ptr [ESP + 0x20],EAX
006c0781 : CMP EBX,EAX
006c0783 : JNC 0x006c07b4
006c0785 : CMP dword ptr [ESP + 0x18],0x0
006c078a : JZ 0x006c09c5
006c0790 : MOVZX EAX,byte ptr [EBP]
006c0794 : DEC dword ptr [ESP + 0x18]
006c0798 : MOV ECX,EBX
006c079a : SHL EAX,CL
006c079c : ADD EBX,0x8
006c079f : INC EBP
006c07a0 : MOV dword ptr [ESP + 0x2c],0x0
006c07a8 : OR dword ptr [ESP + 0x10],EAX
006c07ac : MOV EAX,dword ptr [ESP + 0x20]
006c07b0 : CMP EBX,EAX
006c07b2 : JC 0x006c0785
006c07b4 : MOV ECX,dword ptr [EAX*0x4 + 0xbed1e8]
006c07bb : AND ECX,dword ptr [ESP + 0x10]
006c07bf : MOV EAX,dword ptr [ESP + 0x14]
006c07c3 : ADD dword ptr [EAX + 0xc],ECX
006c07c6 : MOV ECX,dword ptr [ESP + 0x20]
006c07ca : SHR dword ptr [ESP + 0x10],CL
006c07ce : SUB EBX,ECX
006c07d0 : MOV dword ptr [EAX],0x5
006c07d6 : MOV ECX,EDX
006c07d8 : SUB ECX,dword ptr [EAX + 0xc]
006c07db : MOV EAX,dword ptr [ESI + 0x28]
006c07de : MOV dword ptr [ESP + 0x20],ECX
006c07e2 : CMP ECX,EAX
006c07e4 : JNC 0x006c0804
006c07e6 : MOV ECX,dword ptr [ESI + 0x2c]
006c07e9 : SUB ECX,EAX
006c07eb : MOV EAX,dword ptr [ESP + 0x20]
006c07ef : MOV dword ptr [ESP + 0x24],ECX
006c07f3 : JMP 0x006c07f9
006c07f5 : MOV ECX,dword ptr [ESP + 0x24]
006c07f9 : ADD EAX,ECX
006c07fb : CMP EAX,dword ptr [ESI + 0x28]
006c07fe : JC 0x006c07f5
006c0800 : MOV dword ptr [ESP + 0x20],EAX
006c0804 : MOV EAX,dword ptr [ESP + 0x14]
006c0808 : CMP dword ptr [EAX + 0x4],0x0
006c080c : JZ 0x006c0985
006c0812 : CMP dword ptr [ESP + 0x1c],0x0
006c0817 : JNZ 0x006c08a5
006c081d : MOV EAX,dword ptr [ESI + 0x2c]
006c0820 : CMP EDX,EAX
006c0822 : JNZ 0x006c0846
006c0824 : MOV EAX,dword ptr [ESI + 0x30]
006c0827 : MOV ECX,dword ptr [ESI + 0x28]
006c082a : CMP EAX,ECX
006c082c : JZ 0x006c0846
006c082e : MOV EDX,ECX
006c0830 : CMP EDX,EAX
006c0832 : JNC 0x006c0839
006c0834 : SUB EAX,EDX
006c0836 : DEC EAX
006c0837 : JMP 0x006c083e
006c0839 : MOV EAX,dword ptr [ESI + 0x2c]
006c083c : SUB EAX,EDX
006c083e : MOV dword ptr [ESP + 0x1c],EAX
006c0842 : TEST EAX,EAX
006c0844 : JNZ 0x006c08a1
006c0846 : MOV dword ptr [ESI + 0x34],EDX
006c0849 : MOV EDX,dword ptr [ESP + 0x2c]
006c084d : PUSH EDX
006c084e : CALL 0x006c0400
006c0853 : MOV EDX,dword ptr [ESI + 0x34]
006c0856 : MOV dword ptr [ESP + 0x30],EAX
006c085a : MOV EAX,dword ptr [ESI + 0x30]
006c085d : ADD ESP,0x4
006c0860 : CMP EDX,EAX
006c0862 : JNC 0x006c086b
006c0864 : MOV ECX,EAX
006c0866 : SUB ECX,EDX
006c0868 : DEC ECX
006c0869 : JMP 0x006c0870
006c086b : MOV ECX,dword ptr [ESI + 0x2c]
006c086e : SUB ECX,EDX
006c0870 : MOV dword ptr [ESP + 0x1c],ECX
006c0874 : MOV ECX,dword ptr [ESI + 0x2c]
006c0877 : CMP EDX,ECX
006c0879 : JNZ 0x006c0896
006c087b : MOV ECX,dword ptr [ESI + 0x28]
006c087e : CMP EAX,ECX
006c0880 : JZ 0x006c0896
006c0882 : MOV EDX,ECX
006c0884 : CMP EDX,EAX
006c0886 : JNC 0x006c088d
006c0888 : SUB EAX,EDX
006c088a : DEC EAX
006c088b : JMP 0x006c0892
006c088d : MOV EAX,dword ptr [ESI + 0x2c]
006c0890 : SUB EAX,EDX
006c0892 : MOV dword ptr [ESP + 0x1c],EAX
006c0896 : CMP dword ptr [ESP + 0x1c],0x0
006c089b : JZ 0x006c0a08
006c08a1 : MOV EAX,dword ptr [ESP + 0x14]
006c08a5 : MOV ECX,dword ptr [ESP + 0x20]
006c08a9 : MOV CL,byte ptr [ECX]
006c08ab : INC dword ptr [ESP + 0x20]
006c08af : DEC dword ptr [ESP + 0x1c]
006c08b3 : MOV byte ptr [EDX],CL
006c08b5 : MOV ECX,dword ptr [ESP + 0x20]
006c08b9 : INC EDX
006c08ba : MOV dword ptr [ESP + 0x2c],0x0
006c08c2 : CMP ECX,dword ptr [ESI + 0x2c]
006c08c5 : JNZ 0x006c08ce
006c08c7 : MOV ECX,dword ptr [ESI + 0x28]
006c08ca : MOV dword ptr [ESP + 0x20],ECX
006c08ce : DEC dword ptr [EAX + 0x4]
006c08d1 : CMP dword ptr [EAX + 0x4],0x0
006c08d5 : JNZ 0x006c0812
006c08db : JMP 0x006c0985
006c08e0 : CMP dword ptr [ESP + 0x1c],0x0
006c08e5 : JNZ 0x006c0973
006c08eb : MOV EAX,dword ptr [ESI + 0x2c]
006c08ee : CMP EDX,EAX
006c08f0 : JNZ 0x006c0914
006c08f2 : MOV EAX,dword ptr [ESI + 0x30]
006c08f5 : MOV ECX,dword ptr [ESI + 0x28]
006c08f8 : CMP EAX,ECX
006c08fa : JZ 0x006c0914
006c08fc : MOV EDX,ECX
006c08fe : CMP EDX,EAX
006c0900 : JNC 0x006c0907
006c0902 : SUB EAX,EDX
006c0904 : DEC EAX
006c0905 : JMP 0x006c090c
006c0907 : MOV EAX,dword ptr [ESI + 0x2c]
006c090a : SUB EAX,EDX
006c090c : MOV dword ptr [ESP + 0x1c],EAX
006c0910 : TEST EAX,EAX
006c0912 : JNZ 0x006c096f
006c0914 : MOV dword ptr [ESI + 0x34],EDX
006c0917 : MOV EDX,dword ptr [ESP + 0x2c]
006c091b : PUSH EDX
006c091c : CALL 0x006c0400
006c0921 : MOV EDX,dword ptr [ESI + 0x34]
006c0924 : MOV dword ptr [ESP + 0x30],EAX
006c0928 : MOV EAX,dword ptr [ESI + 0x30]
006c092b : ADD ESP,0x4
006c092e : CMP EDX,EAX
006c0930 : JNC 0x006c0939
006c0932 : MOV ECX,EAX
006c0934 : SUB ECX,EDX
006c0936 : DEC ECX
006c0937 : JMP 0x006c093e
006c0939 : MOV ECX,dword ptr [ESI + 0x2c]
006c093c : SUB ECX,EDX
006c093e : MOV dword ptr [ESP + 0x1c],ECX
006c0942 : MOV ECX,dword ptr [ESI + 0x2c]
006c0945 : CMP EDX,ECX
006c0947 : JNZ 0x006c0964
006c0949 : MOV ECX,dword ptr [ESI + 0x28]
006c094c : CMP EAX,ECX
006c094e : JZ 0x006c0964
006c0950 : MOV EDX,ECX
006c0952 : CMP EDX,EAX
006c0954 : JNC 0x006c095b
006c0956 : SUB EAX,EDX
006c0958 : DEC EAX
006c0959 : JMP 0x006c0960
006c095b : MOV EAX,dword ptr [ESI + 0x2c]
006c095e : SUB EAX,EDX
006c0960 : MOV dword ptr [ESP + 0x1c],EAX
006c0964 : CMP dword ptr [ESP + 0x1c],0x0
006c0969 : JZ 0x006c0a08
006c096f : MOV EAX,dword ptr [ESP + 0x14]
006c0973 : MOV CL,byte ptr [EAX + 0x8]
006c0976 : MOV byte ptr [EDX],CL
006c0978 : INC EDX
006c0979 : DEC dword ptr [ESP + 0x1c]
006c097d : MOV dword ptr [ESP + 0x2c],0x0
006c0985 : MOV dword ptr [EAX],0x0
006c098b : MOV ECX,dword ptr [EAX]
006c098d : CMP ECX,0x9
006c0990 : JBE 0x006c0578
006c0996 : PUSH -0x2
006c0998 : MOV ECX,dword ptr [ESP + 0x14]
006c099c : MOV EAX,dword ptr [ESP + 0x1c]
006c09a0 : MOV dword ptr [ESI + 0x20],ECX
006c09a3 : MOV dword ptr [ESI + 0x1c],EBX
006c09a6 : MOV dword ptr [EDI + 0x4],EAX
006c09a9 : MOV ECX,EBP
006c09ab : SUB ECX,dword ptr [EDI]
006c09ad : ADD dword ptr [EDI + 0x8],ECX
006c09b0 : MOV dword ptr [EDI],EBP
006c09b2 : MOV dword ptr [ESI + 0x34],EDX
006c09b5 : CALL 0x006c0400
006c09ba : ADD ESP,0x4
006c09bd : POP EDI
006c09be : POP ESI
006c09bf : POP EBP
006c09c0 : POP EBX
006c09c1 : ADD ESP,0x18
006c09c4 : RET
006c09c5 : MOV EAX,dword ptr [ESP + 0x10]
006c09c9 : MOV dword ptr [ESI + 0x20],EAX
006c09cc : MOV dword ptr [ESI + 0x1c],EBX
006c09cf : MOV ECX,EBP
006c09d1 : SUB ECX,dword ptr [EDI]
006c09d3 : MOV dword ptr [EDI + 0x4],0x0
006c09da : ADD dword ptr [EDI + 0x8],ECX
006c09dd : MOV dword ptr [EDI],EBP
006c09df : MOV dword ptr [ESI + 0x34],EDX
006c09e2 : MOV EDX,dword ptr [ESP + 0x2c]
006c09e6 : PUSH EDX
006c09e7 : CALL 0x006c0400
006c09ec : ADD ESP,0x4
006c09ef : POP EDI
006c09f0 : POP ESI
006c09f1 : POP EBP
006c09f2 : POP EBX
006c09f3 : ADD ESP,0x18
006c09f6 : RET
006c09f7 : MOV dword ptr [EAX],0x9
006c09fd : MOV dword ptr [EDI + 0x18],0xbed36c
006c0a04 : PUSH -0x3
006c0a06 : JMP 0x006c0998
006c0a08 : MOV EAX,dword ptr [ESP + 0x10]
006c0a0c : MOV ECX,dword ptr [ESP + 0x18]
006c0a10 : MOV dword ptr [ESI + 0x20],EAX
006c0a13 : MOV dword ptr [ESI + 0x1c],EBX
006c0a16 : MOV EAX,EBP
006c0a18 : SUB EAX,dword ptr [EDI]
006c0a1a : MOV dword ptr [EDI + 0x4],ECX
006c0a1d : MOV ECX,dword ptr [ESP + 0x2c]
006c0a21 : ADD dword ptr [EDI + 0x8],EAX
006c0a24 : PUSH ECX
006c0a25 : JMP 0x006c09b0
006c0a27 : CMP EBX,0x7
006c0a2a : JBE 0x006c0a34
006c0a2c : INC dword ptr [ESP + 0x18]
006c0a30 : SUB EBX,0x8
006c0a33 : DEC EBP
006c0a34 : MOV dword ptr [ESI + 0x34],EDX
006c0a37 : MOV EDX,dword ptr [ESP + 0x2c]
006c0a3b : PUSH EDX
006c0a3c : CALL 0x006c0400
006c0a41 : MOV EDX,dword ptr [ESI + 0x34]
006c0a44 : ADD ESP,0x4
006c0a47 : CMP dword ptr [ESI + 0x30],EDX
006c0a4a : JZ 0x006c0a63
006c0a4c : MOV ECX,dword ptr [ESP + 0x10]
006c0a50 : MOV dword ptr [ESI + 0x20],ECX
006c0a53 : MOV ECX,dword ptr [ESP + 0x18]
006c0a57 : MOV dword ptr [ESI + 0x1c],EBX
006c0a5a : MOV dword ptr [EDI + 0x4],ECX
006c0a5d : PUSH EAX
006c0a5e : JMP 0x006c09a9
006c0a63 : MOV EAX,dword ptr [ESP + 0x14]
006c0a67 : MOV dword ptr [EAX],0x8
006c0a6d : PUSH 0x1
006c0a6f : JMP 0x006c0998
006c0a74 : MOV EAX,dword ptr [ESP + 0x10]
006c0a78 : MOV ECX,dword ptr [ESP + 0x18]
006c0a7c : MOV dword ptr [ESI + 0x20],EAX
006c0a7f : MOV dword ptr [ESI + 0x1c],EBX
006c0a82 : MOV EAX,EBP
006c0a84 : SUB EAX,dword ptr [EDI]
006c0a86 : MOV dword ptr [EDI + 0x4],ECX
006c0a89 : ADD dword ptr [EDI + 0x8],EAX
006c0a8c : PUSH -0x3
006c0a8e : JMP 0x006c09b0
